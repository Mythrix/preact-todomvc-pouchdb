{"version":3,"sources":["webpack:///index.js","webpack:///webpack/bootstrap dc842e0959297ac9a8b2","webpack:///./src/index.js","webpack:///./~/preact/dist/preact.js","webpack:///./~/process/browser.js","webpack:///./~/timers-browserify/main.js","webpack:///./src/app/util.js","webpack:///./~/decko/decko.js","webpack:///./~/preact-router/dist/preact-router.js","webpack:///./~/argsarray/index.js","webpack:///./src/app/footer.js","webpack:///./src/app/index.js","webpack:///./src/app/item.js","webpack:///./src/app/model.js","webpack:///./~/debug/browser.js","webpack:///./~/debug/debug.js","webpack:///./~/events/events.js","webpack:///./~/immediate/lib/index.js","webpack:///./~/inherits/inherits_browser.js","webpack:///./~/js-extend/extend.js","webpack:///./~/lie/lib/index.js","webpack:///./~/ms/index.js","webpack:///./~/pouchdb-collate/lib/index.js","webpack:///./~/pouchdb-collate/lib/utils.js","webpack:///./~/pouchdb-collections/index.js","webpack:///./~/pouchdb/lib/index-browser.js","webpack:///./~/scope-eval/scope_eval.js","webpack:///./~/spark-md5/spark-md5.js","webpack:///./~/todomvc-common/base.js","webpack:///./~/vuvuzela/index.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","id","loaded","call","m","c","p","_interopRequireDefault","obj","__esModule","default","_preact","_app","_app2","render","h","document","querySelector","setImmediate","global","factory","this","VNode","nodeName","attributes","children","extend","props","i","hasOwnProperty","clone","out","memoize","fn","mem","k","delve","key","split","length","toArray","arr","styleObjToCss","s","str","prop","val","empty","jsToCss","NON_DIMENSION_PROPS","hashToClassName","normalize","v","isString","optionsHook","name","a","b","hook","options","deepHook","type","_component","len","arguments","lastSimple","_p","falsey","join","SHARED_TEMP_ARRAY","j","child","simple","String","push","createLinkedState","component","eventPath","path","p0","e","_component$setState","t","state","match","checked","value","isFunction","setState","enqueueRender","items","debounceRendering","rerender","currentItems","itemsOffline","pop","_dirty","renderComponent","isFunctionalComponent","_ref","prototype","buildFunctionalComponent","vnode","context","getNodeProps","EMPTY","EMPTY_BASE","ensureNodeData","node","ATTR_KEY","getNodeType","nodeType","appendChildren","parent","many","into","createDocumentFragment","appendChild","getAccessor","cache","attrs","className","style","cssText","setAccessor","__html","innerHTML","removeAttribute","setComplexAccessor","substring","setAttribute","_type","normalizeEventName","l","_listeners","eventProxy","getNodeAttributes","getRawNodeAttributes","list","getNamedItem","getAttributesAsObject","item","isSameNodeType","_componentConstructor","toLowerCase","defaultProps","collectNode","cleanNode","normalizeName","nodes","createNode","createElement","parentNode","removeChild","diff","dom","originalAttributes","buildComponentFromVNode","TEXT_CONTENT","createTextNode","UNDEFINED_ELEMENT","childNodes","recollectNodeTree","innerDiffNode","diffAttributes","ref","keyed","keyedLen","childrenLen","vchildren","vlen","min","vchild","next","insertBefore","removeOrphanedChildren","unmountOnly","unmountComponent","old","collectComponent","constructor","components","createComponent","ctor","splice","triggerComponentRender","setComponentProps","opts","d","_disableRendering","prevContext","base","prevProps","renderSync","syncComponentUpdates","skip","rendered","previousProps","previousState","prevState","previousContext","isUpdate","childComponent","childContext","getChildContext","toUnmount","inst","childProps","SYNC_RENDER","_parentComponent","NO_RENDER","DOM_RENDER","cbase","build","replaceChild","componentRef","cb","_renderCallbacks","oldDom","isOwner","createComponentFromVNode","remove","inner","Component","_linkedStates","merge","existing","built","HAS_DOM","Symbol","boxFlex","boxFlexGroup","columnCount","fillOpacity","flex","flexGrow","flexPositive","flexShrink","flexNegative","fontWeight","lineClamp","lineHeight","opacity","order","orphans","strokeOpacity","widows","zIndex","zoom","x","replace","ch","MessageChannel","f","port1","onmessage","port2","postMessage","setTimeout","n","toUpperCase","linkState","cacheKey","callback","forceUpdate","preact","hooks","cleanUpNextTick","draining","currentQueue","queue","concat","queueIndex","drainQueue","timeout","run","clearTimeout","Item","fun","array","noop","process","nextTick","args","Array","apply","title","browser","env","argv","version","versions","on","addListener","once","off","removeListener","removeAllListeners","emit","binding","Error","cwd","chdir","dir","umask","clearImmediate","Timeout","clearFn","_id","_clearFn","Function","slice","immediateIds","nextImmediateId","window","setInterval","clearInterval","close","unref","enroll","msecs","_idleTimeoutId","_idleTimeout","unenroll","_unrefActive","active","_onTimeout","uuid","random","Math","toString","pluralize","count","word","store","namespace","data","localStorage","setItem","JSON","stringify","getItem","parse","__WEBPACK_AMD_DEFINE_FACTORY__","__WEBPACK_AMD_DEFINE_ARRAY__","__WEBPACK_AMD_DEFINE_RESULT__","undefined","multiMethod","deco","decorate","decorator","_len3","_key3","opt","target","desc","HOP","Object","fns","_len","_key","caseSensitive","debounce","delay","timer","_len2","_key2","bind","configurable","get","defineProperty","writable","exec","url","route","EMPTY$1","reg","matches","ret","r","decodeURIComponent","segmentize","max","charAt","param","flags","plus","indexOf","star","map","pathRankSort","aAttr","bAttr","rank","strip","history","replaceState","pushState","routeTo","routers","forEach","router","getCurrentUrl","location","pathname","search","handleLinkClick","getAttribute","stopImmediatePropagation","stopPropagation","preventDefault","babelHelpers","inherits","subClass","superClass","TypeError","create","enumerable","setPrototypeOf","__proto__","objectWithoutProperties","keys","_extends","assign","source","classCallCheck","instance","Constructor","addEventListener","Link","onClick","Router","_Component","getInitialState","componentWillMount","componentWillUnmount","_ref2","_ref3","onChange","sort","filter","_ref4","previous","previousUrl","current","Route","_ref5","RoutedComponent","argsArray","_classCallCheck","_possibleConstructorReturn","self","ReferenceError","_inherits","_preactRouter","_util","ALL_TODOS","ACTIVE_TODOS","COMPLETED_TODOS","TodoFooter","nowShowing","completedCount","onClearCompleted","class","href","selected","_objectDestructuringEmpty","_applyDecoratedDescriptor","property","decorators","descriptor","initializer","reverse","reduce","_FILTERS","_class","_decko","_model","_model2","_footer","_footer2","_item","_item2","REMOTE_DB_URL","ENTER_KEY","FILTERS","todo","completed","App","_this","model","subscribe","handleRoute","handleNewTodoKeyDown","keyCode","newTodo","trim","addTodo","toggleAll","event","toggle","todoToToggle","destroy","edit","editing","save","todoToSave","text","cancel","clearCompleted","_this2","_ref3$nowShowing","todos","shownTodos","activeTodoCount","Noop","placeholder","onKeyDown","onInput","autoFocus","onToggle","onDestroy","onEdit","onSave","onCancel","getOwnPropertyDescriptor","_Component2","ESCAPE_KEY","TodoItem","handleSubmit","editText","handleEdit","handleKeyDown","which","componentDidUpdate","focus","_ref2$todo","onDblClick","onBlur","_pouchdb","_pouchdb2","TodoModel","remoteDBURL","onChanges","localDB","changes","since","live","console","log","draw","syncAndDraw","err","remoteDB","allDocs","include_docs","descending","doc","next_todos","rows","publish","sync","info","Date","toISOString","put","result","completed_todos","_deleted","bulkDocs","useColors","documentElement","firebug","exception","table","navigator","userAgent","parseInt","RegExp","$1","formatArgs","humanize","color","index","lastC","namespaces","storage","removeItem","debug","load","localstorage","chrome","local","colors","formatters","enable","selectColor","prevColor","disabled","enabled","curr","ms","prevTime","prev","coerce","format","formatter","logFn","skips","substr","names","disable","test","stack","message","EventEmitter","_events","_maxListeners","arg","isNumber","isObject","isUndefined","defaultMaxListeners","setMaxListeners","isNaN","er","handler","listeners","error","listener","newListener","warned","trace","g","fired","position","listenerCount","evlistener","emitter","oldQueue","immediate","task","scheduleDrain","Mutation","MutationObserver","WebKitMutationObserver","called","observer","element","observe","characterData","scriptEl","onreadystatechange","channel","superCtor","super_","TempCtor","root","each","sources","INTERNAL","Promise","resolver","PENDING","outcome","handled","UNHANDLED","safelyResolveThenable","QueueItem","promise","onFulfilled","onRejected","callFulfilled","otherCallFulfilled","callRejected","otherCallRejected","unwrap","func","returnValue","handlers","reject","resolve","getThen","then","thenable","onError","onSuccess","tryToUnwrap","tryCatch","status","reason","all","iterable","allResolver","resolveFromAll","outValue","values","resolved","race","response","REJECTED","FULFILLED","parseFloat","y","short","round","long","plural","floor","ceil","indexify","numToIndexableString","isArray","toIndexableString","objKey","parseNumber","num","originalIdx","zero","neg","numAsString","magAsString","MAGNITUDE_DIGITS","magnitude","MIN_MAGNITUDE","metaStack","lastMetaElement","lastElementIndex","arrayCollate","collate","stringCollate","objectCollate","ak","bk","collationIndex","idx","expFormat","toExponential","magForComparison","magString","utils","padLeft","SEP","factor","abs","factorStr","toFixed","normalizeKey","ai","bi","Infinity","origKey","toJSON","parseIndexableString","parsedNum","parsedStr","arrayElement","objElement","pad","padWith","upToLength","padding","targetLength","padRight","stringLexCompare","aLen","bLen","aChar","bChar","intToDecimalForm","int","isNeg","remainder","LazyMap","LazySet","add","Map","Set","mangle","unmangle","mangled","set","has","_interopDefault","ex","pick","res","isBinaryObject","object","ArrayBuffer","Blob","cloneArrayBuffer","buff","byteLength","targetArray","Uint8Array","sourceArray","cloneBinaryObject","size","webkitSlice","newObject","getArguments","toPromise","usedCB","tempCB","resp","PouchPromise","fulfill","mesg","adapterFun","logApiCall","logArgs","_db_name","origCallback","responseArgs","_closed","_destroyed","taskqueue","isReady","addTask","failed","upsert","db","docId","diffFun","docRev","_rev","newDoc","tryAndPut","updated","rev","winningRev","metadata","winningId","winningPos","winningDeleted","toVisit","rev_tree","tree","ids","branches","pos","deleted","getTrees","isDeleted","evalFilter","input","scopedEval","evalView","parseDesignDocFunctionName","parts","normalizeDesignDocFunctionName","normalized","traverseRevTree","revs","newCtx","ctx","sortByPos","collectLeaves","leaves","isLeaf","acc","collectConflicts","win","conflicts","leaf","PouchError","createError","CustomPouchError","generateErrorFromResponse","errName","errType","errMsg","errReason","getErrorTypeByProp","missing","MISSING_DOC","DOC_VALIDATION","BAD_REQUEST","UNKNOWN_ERROR","Changes","events","complete","change","isCancelled","startSeq","seq","doChanges","processChange","changeList","_conflicts","bulkGet","collapseResults","results","perDocResults","docs","checkDone","numDone","numDocs","gotResult","requests","requestsById","request","docRequests","docOpts","open_revs","formatResult","ok","isLocalId","rootToLeaf","paths","getValue","radix","chars","toObject","invalidIdError","INVALID_ID","RESERVED_ID","MISSING_ID","parseRevisionInfo","INVALID_REV","left","right","prefix","makeRevTreeFromRevisions","revisions","start","revisionIds","parseDoc","newEdits","nRevNum","newRevId","revInfo","_rev_tree","_revisions","specialKey","reservedWords","dataWords","compare","arrayFirst","yankError","cleanDocs","_attachments","atts","att","compareByIdThenRev","idCompare","aStart","bStart","computeHeight","height","edges","prnt","from","to","edge","allDocsKeysQuery","api","limit","_allDocs","finalResults","offset","subOpts","jsExtend","optKey","total_rows","doNextCompaction","_compactionQueue","last_seq","_compact","shift","attachmentNameError","cacheUpdateRequired","designDocName","changesOpts","doc_ids","latestSeq","getDesignDocCache","_ddocCache","_get","propertyName","getDesignDocProperty","propertyElement","designDoc","AbstractPouchDB","TaskQueue","defaultCallback","prepareForDestruction","onDestroyed","onConstructorDestroyed","originalName","destructionListeners","_destructionListeners","PouchDB","__opts","oldCB","auto_compaction","backend","code","parseAdapter","adapter","_adapter","adapters","valid","fail","replicate","dbName","ready","isChromeApp","hasLocalStorage","hasLocal","setUpEventEmitter","Pouch","eventEmitter","destructListeners","pouchdbCollections","createBlob","properties","Builder","BlobBuilder","MSBlobBuilder","MozBlobBuilder","WebKitBlobBuilder","builder","append","getBlob","readAsArrayBuffer","blob","FileReader","FileReaderSync","reader","onloadend","wrappedFetch","wrappedPromise","fetch","fetchRequest","headers","Headers","fetchOptions","method","credentials","json","body","arrayBuffer","processData","fetchResponse","statusCode","binary","abort","xhRequest","xhr","abortReq","XMLHttpRequest","open","withCredentials","Accept","responseType","setRequestHeader","onprogress","upload","readyState","getResponseHeader","responseText","send","testXhr","ajax$1","hasXhr","defaultBody","ajaxCore","errParsed","errObj","err2","defaultOptions","encoding","content_type","ajax","ua","isSafari","isIE","isEdge","shouldCacheBust","hasArgs","now","parseUri","parser","uri","encoded","qName","qParser","$0","$2","binaryStringToArrayBuffer","bin","buf","charCodeAt","binStringToBluffer","binString","tryFilter","req","msg","filterChange","hasFilter","query","query_params","filterReturn","attachments","stub","explainError","updateCheckpoint","checkpoint","session","session_id","replicator","REPLICATOR","CHECKPOINT_VERSION","cancelled","unshift","CHECKPOINT_HISTORY_SIZE","Checkpointer","src","compareReplicationLogs","srcDoc","tgtDoc","sourceHistory","targetHistory","compareReplicationHistory","S","sourceRest","T","targetRest","LOWEST_SEQ","sourceId","hasSessionId","targetId","sessionId","rest","isForbiddenError","randomNumber","ratio","range","defaultBackOff","backOff","retry","back_off_function","current_back_off","STARTING_BACK_OFF","rawToBase64","raw","btoa$1","appendBuffer","buffer","end","appendString","appendBinary","sortObjectPropertiesByKey","queryParams","pouchCollate","generateReplicationId","docIds","filterFun","filterViewName","view","queryData","md5","md5sum","isGenOne","createBulkGetOpts","diffs","missingRevs","missingRev","getDocs","getAllDocs","bulkGetOpts","bulkGetResponse","bulkGetInfo","resultDocs","hasAttachments","fetchRevisionOneDocs","row","getRevisionOneDocs","returnDocs","initCheckpointer","checkpointer","repId","writeDocs","changedDocs","currentBatch","new_edits","completeReplication","errors","errorsById","doc_write_failures","allErrors","docs_written","non403s","other_errors","abortReplication","finishBatch","outResult","writingCheckpoint","writeCheckpoint","getChanges","getDiffs","revsDiff","getBatchDocs","docs_read","startNextBatch","batches","processPendingBatch","pendingBatch","continuous","changesCompleted","batch_size","replicationCompleted","end_time","onChangesComplete","changesPending","onChangesError","abortChanges","batches_limit","_changes","_abortChanges","startChanges","getCheckpoint","return_docs","heartbeat","onCheckpointError","start_time","_addedListeners","Replication","toPouch","PouchConstructor","replicateWrapper","replicateRet","srcPouch","targetPouch","replication","Sync","pullChange","direction","pushChange","pushDenied","pullDenied","pushPaused","pullPaused","pushActive","pullActive","removeAll","isChange","isDenied","isPaused","isActive","removed","canceled","optsPush","optsPull","pull","replicate$1","success","b64ToBluffer","b64","atob$1","arrayBufferToBinaryString","bytes","fromCharCode","readAsBinaryString","hasBinaryString","blobToBase64","blobOrBuffer","flatten","arrs","readAttachmentsAsBlobOrBuffer","filename","encodeDocId","encodeURIComponent","preprocessAttachments","attachment","getHost","user","password","auth","username","genDBUrl","genUrl","pathDel","protocol","host","port","paramsToStr","params","HttpPouch","userOpts","reqAjax","reqOpts","ajaxOpts","log$1","ajaxPromise","adapterFun$$","setup","skipSetup","skip_setup","setupPromise","checkExists","dbUrl","encodeAttachmentId","attachmentId","getHostFun","getUrl","getHeaders","nAuth","token","unescape","Authorization","compact","ping","compact_running","interval","doBulkGet","doBulkGetShim","onResult","batchNum","numBatches","batchSize","MAX_SIMULTANEOUS_REVS","supportsBulkGet","supportsBulkGetMap","_info","fetchAttachments","filenames","fetchAllAttachments","docOrDocs","revs_info","docOrId","optsOrRev","getAttachment","removeAttachment","putAttachment","BAD_ARG","Content-Type","_bulkDocs","start_key","startkey","end_key","endkey","inclusive_end","paramStr","keysAsString","MAX_URL_LENGTH","CHANGES_BATCH_SIZE","leftToFetch","feed","param_name","docIdsJson","lastFetchedSeq","aborted","xhrOpts","fetched","raw_results_length","finished","_close","_destroy","TaskQueue$1","md5$1","string","Md5","hash","createView","sourceDB","viewName","mapFun","reduceFun","temporary","viewSignature","_cachedViews","cachedView","diffFunction","views","fullViewName","depDbs","depDbName","db_name","registerDependentDatabase","lastSeqDoc","evalfunc","sum","parseViewName","isGenOne$1","emitError","tryCode","output","sortByKeyThenValue","keyCompare","collate$2","sliceResults","rowToDocId","readAttachmentsAsBlobOrBuffer$1","postprocessAttachments","createBuiltInError","BuiltInError","jLen","jNum","addHttpParam","paramName","asJson","coerceInteger","integerCandidate","asNumber","Number","coerceOptions","group_level","checkPositiveInteger","number","QueryParseError","checkQueryParseError","startkeyName","endkeyName","group","optionName","httpQuery","customQuery","_query","customViewCleanup","_viewCleanup","defaultsTo","getDocsToPersist","docIdsToChangesAndEmits","getMetaDoc","defaultMetaDoc","metaDocId","getKeyValueDocs","metaDoc","processKvDocs","kvDocsRes","kvDocs","oldKeysMap","indexableKeysToKeyValues","keyValue","newKeys","kvDoc","uniq","docData","saveKeyValues","seqDocId","listOfDocsToPersist","docsToPersist","getQueue","persistentQueues","updateView","sequentialize","updateViewInQueue","mapResults","origMap","log$2","currentSeq","finish","processNextBatch","CHANGES_BATCH_SIZE$1","lastKey","jl","complexKey","indexableKey","reduceView","shouldGroup","builtInReduce","groups","lvl","POSITIVE_INFINITY","last","groupKey","reduceTry","queryView","queryViewInQueue","fetchFromView","viewOpts","totalRows","expectedKeys","parsedKeyAndDocId","onMapResultsReady","shouldReduce","allDocsRes","docIdsToDocs","fetchPromises","inclusiveEnd","keyStart","keyEnd","httpViewCleanup","localViewCleanup","docsToViews","viewsToStatus","ddocName","viewDBNames","statusIsGood","viewDBName","dbsToDelete","destroyPromises","queryPromised","createViewOpts","tempViewQueue","cleanup","fin","getView","stale","captureStackTrace","arrayBufferToBase64","preprocessAttachments$1","docInfos","blobType","parseBase64","preprocessAttachment","asBinary","digest","done","docv","overallErr","docInfo","processedAttachment","recv","sortByPos$1","binarySearch","comparator","mid","low","high","insertSorted","pathToTree","numStemmed","currentLeaf","compareTree","mergeTree","in_tree1","in_tree2","tree1","tree2","merged","doMerge","dontExpand","restree","branch","t1","t2","candidateParents","trees","parentIdx","elements","elementsLen","el","stem","depth","maybeStem","stemmed","stemmedNode","revHash","newTree","stemmedRevs","revExists","splitRev","targetPos","updateDoc","revLimit","writeDoc","previousWinningRev","previouslyDeleted","isRoot","inConflict","REV_CONFLICT","newRev","rev_map","newRevIsDeleted","winningRev$$","winningRevIsDeleted","delta","rootIsMissing","processDocs","fetchedDocs","tx","overallCallback","insertDoc","resultsIdx","checkAllDocsDone","docsDone","docsToDo","idsToDocs","currentDoc","docWritten","nextDoc","compactTree","slowJsonParse","vuvuzela","safeJsonParse","safeJsonStringify","tryCode$1","that","applyNext","taskQueue","running","action","idbError","evt","IDB_ERROR","encodeMetadata","deletedOrLocal","decodeMetadata","storedObject","decodeDoc","_doc_id_rev","lastIndexOf","readBlobData","asBlob","fetchAttachmentsIfNecessary","txn","fetchAttachment","attObj","objectStore","ATTACH_STORE","onsuccess","postProcessAttachments","attNames","compactRevs","deleteOrphanedAttachments","possiblyOrphanedDigests","countReq","attAndSeqStore","IDBKeyRange","bound","attStore","seqStore","BY_SEQ_STORE","ATTACH_AND_SEQ_STORE","getKey","cursor","openCursor","only","digestSeq","primaryKey","openTransactionSafely","idb","stores","mode","transaction","idbBulkDocs","dbOpts","idbChanges","startTransaction","DOC_STORE","LOCAL_STORE","txnResult","onabort","ontimeout","oncomplete","docStore","bySeqStore","attachStore","attachAndSeqStore","verifyAttachments","preconditionErrored","fetchExistingDocs","idbProcessDocs","revs_limit","numFetched","readMetadata","notify","_meta","docCount","docCountDelta","verifyAttachment","MISSING_STUB","digests","attErr","writeAttachments","finishDoc","autoCompact","revsToDelete","afterPutDoc","metadataToStore","metaDataReq","afterPutMetadata","afterPutDocError","getKeyReq","putReq","insertAttachmentMappings","onerror","collectResults","attachmentSaved","saveAttachment","attsAdded","attsToAdd","newAtt","docInfoError","blobSupport","createKeyRange","upperBound","lowerBound","handleKeyRangeError","idbAllDocs","allDocsQuery","fetchDocAsynchronously","docIdRevIndex","allDocsInner","onGetCursor","onResultsReady","onTxnComplete","keyRange","checkBlobSupport","DETECT_BLOB_SUPPORT_STORE","matchedChrome","matchedEdge","attachBrowserEvents","onChanged","newValue","attachEvent","Changes$1","IdbPouch","thisCallback","init","createSchema","createObjectStore","keyPath","autoIncrement","createIndex","unique","META_STORE","addDeletedOrLocalIndex","createLocalStoreSchema","migrateLocalStore","localStore","docIdRev","seqCursor","addAttachAndSeqStore","migrateAttsAndSeqs","digestMap","migrateMetadata","decodeMetadataCompat","fetchMetadataSeq","metadataSeq","onGetMetadataSeq","instanceId","_getAttachment","blobData","cachedDBs","updateSeq","doc_count","update_seq","idb_attachment_format","onGetMetadata","lastSeq","onGetWinningDoc","fetchWinningDoc","winningDoc","filtered","numResults","docIdsToMetadata","fetchChanges","objectStores","NOT_OPEN","_getRevisionTree","_doCompaction","_getLocal","_putLocal","oldRev","oStore","oldDoc","_removeLocal","openReq","openReqList","indexedDB","deleteDatabase","cached","tryStorageOption","ADAPTER_VERSION","onupgradeneeded","migration","migrations","oldVersion","currentTarget","onversionchange","checkSetupComplete","meta","blobSupportPromise","decodeUtf8","escape","hexToInt","charCode","parseHexUtf8","parseHexUtf16","parseHexString","quote","createOpenDBFunction","sqlitePlugin","openDatabase","description","SQLitePlugin","escapeBlob","unescapeBlob","stringifyDoc","unstringifyDoc","qMarks","select","selector","joiner","where","orderBy","compactRevs$1","deleteOrphans","seqs","sql","ATTACH_AND_SEQ_STORE$1","executeSql","digestsToCheck","nonOrphanedDigests","ATTACH_STORE$1","BY_SEQ_STORE$1","websqlError","errorNameMatch","errorName","errorReason","WSQ_ERROR","getSize","isAndroid","openDBSafely","openDBFunction","openDB","cachedResult","cachedDatabases","openDBFun","_sqlitePlugin","websqlBulkDocs","websqlChanges","_name","_docCount","cnt","sqlArgs","deletedInt","insertId","dataWritten","fetchSql","attachmentErr","DOC_STORE$1","metadataStr","websqlProcessDocs","userDocs","docInfoErrors","fetchAttachmentsIfNecessary$1","attOpts","_","WebSqlPouch","dbCreated","runMigration2","DOC_STORE_WINNINGSEQ_INDEX_SQL","BY_SEQ_STORE_DELETED_INDEX_SQL","runMigration3","LOCAL_STORE$1","doNext","runMigration4","updateRows","doc_id_rev","hex","doc_id","BY_SEQ_STORE_DOC_ID_REV_INDEX_SQL","runMigration5","nextPage","SELECT_DOCS","DOC_STORE_AND_BY_SEQ_JOINER","pageSize","addDigestSeq","digestSeqs","digestSeqPairs","pair","attachAndRev","ATTACH_AND_SEQ_STORE_ATTACH_INDEX_SQL","ATTACH_AND_SEQ_STORE_SEQ_INDEX_SQL","runMigration6","runMigration7","checkEncoding","onGetInstanceId","idRequests","idCallback","onGetVersion","dbVersion","META_STORE$1","attach","initSeq","initSeqArgs","ADAPTER_VERSION$1","setupDone","migrated","dbid","tasks","nextMigration","fetchVersion","db_version","countDocs","openDBResult","POUCH_VERSION","createFromLocation","androidDatabaseImplementation","readTransaction","sqlite_plugin","websql_encoding","criteria","selectStmt","reportChange","maxSeq","escaped","putLocal","rowsAffected","removeLocal","jsExtend__default","lie","pouchCollate__default","UNAUTHORIZED","MISSING_BULK_DOCS","INVALID_REQUEST","QUERY_PARSE_ERROR","NOT_AN_OBJECT","DB_MISSING","LDB_ERROR","FORBIDDEN","FILE_EXISTS","INVALID_URL","filterChanges","newPromise","filterName","getFilter","post","temp","temptype","createAttachment","was_delete","addToMissing","revId","processDoc","missingForId","missingObj","compactDocument","maxHeight","revTree","candidates","promises","onComplete","finishOpenRevs","indexOfRev","howMany","_revs_info","incompatibleOpt","attachmentError","dependentDb","dependentDbs","depDB","destroyDb","usePrefix","use_prefix","localDoc","deletedMap","trueName","execute","preferredAdapters","adapterName","skipIdb","addToPreferredAdapters","plugin","defaults","defaultOpts","PouchAlt","atob","btoa","extend$1","binaryStringToBlobOrBuffer","collate$1","updateTarget","updateSource","readOnlySource","comparisons","targetDoc","sourceDoc","1","setImmediateShim","MD5_CHUNK_SIZE","loadNextChunk","currentChunk","chunkSize","chunks","base64","inputIsString","_readyCalled","promiseFactory","promisedCallback$1","callbackify$1","fin$1","finalPromiseFactory","sequentialize$1","uniq$1","utils$1","callbackify","promisedCallback","_sum","_count","_stats","sumsqr","_sumsqr","viewCleanup","mapreduce","eventFunction","inprogress","notifyLocalWindows","platform","websql","Errors","hasProp","scope","cmn","q","add32","ff","gg","hh","ii","md5cycle","md5blk","md5blks","md5blk_array","md51","tail","tmp","lo","hi","md51_array","subarray","rhex","hex_chr","toUtf8","utf8Str2ArrayBuffer","returnUInt8Array","arrayBuffer2Utf8Str","concatenateArrayBuffers","first","second","hexToBinaryString","SparkMD5","reset","lsw","msw","clamp","begin","contents","_buff","_length","_hash","_finish","getState","hashBinary","content","redirect","hostname","findRoot","getFile","file","onload","Learn","learnJSON","config","template","framework","templates","todomvc","dataset","frameworkJSON","issueLabel","fetchIssueCount","argsIndex","argsLength","templateSettings","evaluate","interpolate","noMatch","escapes","'","\\","\r","\n","\t"," "," ","escaper","settings","matcher","variable","o","getElementsByTagName","async","ga","aside","sourceLinks","heading","firstElementChild","sourceLink","lastElementChild","outerHTML","demoLinks","querySelectorAll","demoLink","insertAdjacentHTML","issueLink","getElementById","parsedResponse","display","arrayPrefix","objPrefix","numChar","parsedString","lastCh","numConsecutiveSlashes"],"mappings":"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","file":"index.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar _preact = __webpack_require__(1);\n\t\n\tvar _app = __webpack_require__(9);\n\t\n\tvar _app2 = _interopRequireDefault(_app);\n\t\n\t__webpack_require__(28);\n\t\n\t__webpack_require__(16);\n\t\n\t__webpack_require__(15);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\t(0, _preact.render)((0, _preact.h)(_app2.default, null), document.querySelector('.todoapp'));\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(setImmediate) {!function(global, factory) {\n\t     true ? module.exports = factory() : 'function' == typeof define && define.amd ? define(factory) : global.preact = factory();\n\t}(this, function() {\n\t    'use strict';\n\t    function VNode(nodeName, attributes, children) {\n\t        this.nodeName = nodeName;\n\t        this.attributes = attributes;\n\t        this.children = children;\n\t    }\n\t    function extend(obj, props) {\n\t        for (var i in props) if (hasOwnProperty.call(props, i)) obj[i] = props[i];\n\t        return obj;\n\t    }\n\t    function clone(obj) {\n\t        var out = {};\n\t        for (var i in obj) out[i] = obj[i];\n\t        return out;\n\t    }\n\t    function memoize(fn, mem) {\n\t        mem = mem || {};\n\t        return function(k) {\n\t            return hasOwnProperty.call(mem, k) ? mem[k] : mem[k] = fn(k);\n\t        };\n\t    }\n\t    function delve(obj, key) {\n\t        for (var p = key.split('.'), i = 0; i < p.length && obj; i++) obj = obj[p];\n\t        return obj;\n\t    }\n\t    function toArray(obj) {\n\t        var arr = [], i = obj.length;\n\t        for (;i--; ) arr[i] = obj[i];\n\t        return arr;\n\t    }\n\t    function styleObjToCss(s) {\n\t        var str = '';\n\t        for (var prop in s) if (hasOwnProperty.call(s, prop)) {\n\t            var val = s[prop];\n\t            if (!empty(val)) {\n\t                str += jsToCss(prop);\n\t                str += ': ';\n\t                str += val;\n\t                if ('number' == typeof val && !NON_DIMENSION_PROPS[prop]) str += 'px';\n\t                str += '; ';\n\t            }\n\t        }\n\t        return str;\n\t    }\n\t    function hashToClassName(c) {\n\t        var str = '';\n\t        for (var prop in c) if (c[prop]) {\n\t            if (str) str += ' ';\n\t            str += prop;\n\t        }\n\t        return str;\n\t    }\n\t    function normalize(obj, prop, fn) {\n\t        var v = obj[prop];\n\t        if (v && !isString(v)) obj[prop] = fn(v);\n\t    }\n\t    function optionsHook(name, a, b) {\n\t        return hook(options, name, a, b);\n\t    }\n\t    function hook(obj, name, a, b, c) {\n\t        if (obj[name]) return obj[name](a, b, c); else ;\n\t    }\n\t    function deepHook(obj, type) {\n\t        do hook(obj, type); while (obj = obj._component);\n\t    }\n\t    function h(nodeName, attributes) {\n\t        var len = arguments.length, children = void 0, arr = void 0, lastSimple = void 0;\n\t        if (len > 2) {\n\t            children = [];\n\t            for (var i = 2; len > i; i++) {\n\t                var _p = arguments[i];\n\t                if (!falsey(_p)) {\n\t                    if (_p.join) arr = _p; else {\n\t                        arr = SHARED_TEMP_ARRAY;\n\t                        arr[0] = _p;\n\t                    }\n\t                    for (var j = 0; j < arr.length; j++) {\n\t                        var child = arr[j], simple = !(falsey(child) || child instanceof VNode);\n\t                        if (simple) child = String(child);\n\t                        if (simple && lastSimple) children[children.length - 1] += child; else if (!falsey(child)) children.push(child);\n\t                        lastSimple = simple;\n\t                    }\n\t                } else ;\n\t            }\n\t        }\n\t        if (attributes && attributes.children) delete attributes.children;\n\t        var p = new VNode(nodeName, attributes || void 0, children || void 0);\n\t        optionsHook('vnode', p);\n\t        return p;\n\t    }\n\t    function createLinkedState(component, key, eventPath) {\n\t        var path = key.split('.'), p0 = path[0], len = path.length;\n\t        return function(e) {\n\t            var _component$setState;\n\t            var t = this, s = component.state, obj = s, v = void 0, i = void 0;\n\t            if (isString(eventPath)) {\n\t                v = delve(e, eventPath);\n\t                if (empty(v) && (t = t._component)) v = delve(t, eventPath);\n\t            } else v = (t.nodeName + t.type).match(/^input(checkbox|radio)$/i) ? t.checked : t.value;\n\t            if (isFunction(v)) v = v.call(t);\n\t            if (len > 1) {\n\t                for (i = 0; len - 1 > i; i++) obj = obj[path[i]] || (obj[path[i]] = {});\n\t                obj[path[i]] = v;\n\t                v = s[p0];\n\t            }\n\t            component.setState((_component$setState = {}, _component$setState[p0] = v, _component$setState));\n\t        };\n\t    }\n\t    function enqueueRender(component) {\n\t        if (1 === items.push(component)) (options.debounceRendering || setImmediate)(rerender);\n\t    }\n\t    function rerender() {\n\t        if (items.length) {\n\t            var currentItems = items, p = void 0;\n\t            items = itemsOffline;\n\t            itemsOffline = currentItems;\n\t            for (;p = currentItems.pop(); ) if (p._dirty) renderComponent(p);\n\t        }\n\t    }\n\t    function isFunctionalComponent(_ref) {\n\t        var nodeName = _ref.nodeName;\n\t        return isFunction(nodeName) && !nodeName.prototype.render;\n\t    }\n\t    function buildFunctionalComponent(vnode, context) {\n\t        return vnode.nodeName(getNodeProps(vnode), context || EMPTY) || EMPTY_BASE;\n\t    }\n\t    function ensureNodeData(node) {\n\t        return node[ATTR_KEY] || (node[ATTR_KEY] = {});\n\t    }\n\t    function getNodeType(node) {\n\t        return node.nodeType;\n\t    }\n\t    function appendChildren(parent, children) {\n\t        var len = children.length, many = len > 2, into = many ? document.createDocumentFragment() : parent;\n\t        for (var i = 0; len > i; i++) into.appendChild(children[i]);\n\t        if (many) parent.appendChild(into);\n\t    }\n\t    function getAccessor(node, name, value, cache) {\n\t        if ('type' !== name && 'style' !== name && name in node) return node[name];\n\t        var attrs = node[ATTR_KEY];\n\t        if (cache !== !1 && attrs && hasOwnProperty.call(attrs, name)) return attrs[name];\n\t        if ('class' === name) return node.className;\n\t        if ('style' === name) return node.style.cssText; else return value;\n\t    }\n\t    function setAccessor(node, name, value) {\n\t        if ('class' === name) node.className = value || ''; else if ('style' === name) node.style.cssText = value || ''; else if ('dangerouslySetInnerHTML' === name) {\n\t            if (value && value.__html) node.innerHTML = value.__html;\n\t        } else if ('key' === name || name in node && 'type' !== name) {\n\t            node[name] = value;\n\t            if (falsey(value)) node.removeAttribute(name);\n\t        } else setComplexAccessor(node, name, value);\n\t        ensureNodeData(node)[name] = value;\n\t    }\n\t    function setComplexAccessor(node, name, value) {\n\t        if ('on' !== name.substring(0, 2)) {\n\t            var type = typeof value;\n\t            if (falsey(value)) node.removeAttribute(name); else if ('function' !== type && 'object' !== type) node.setAttribute(name, value);\n\t        } else {\n\t            var _type = normalizeEventName(name), l = node._listeners || (node._listeners = {}), fn = !l[_type] ? 'add' : !value ? 'remove' : null;\n\t            if (fn) node[fn + 'EventListener'](_type, eventProxy);\n\t            l[_type] = value;\n\t        }\n\t    }\n\t    function eventProxy(e) {\n\t        var fn = this._listeners[normalizeEventName(e.type)];\n\t        if (fn) return fn.call(this, optionsHook('event', e) || e); else ;\n\t    }\n\t    function getNodeAttributes(node) {\n\t        return node[ATTR_KEY] || getRawNodeAttributes(node) || EMPTY;\n\t    }\n\t    function getRawNodeAttributes(node) {\n\t        var list = node.attributes;\n\t        if (!list || !list.getNamedItem) return list; else return getAttributesAsObject(list);\n\t    }\n\t    function getAttributesAsObject(list) {\n\t        var attrs = void 0;\n\t        for (var i = list.length; i--; ) {\n\t            var item = list[i];\n\t            if (!attrs) attrs = {};\n\t            attrs[item.name] = item.value;\n\t        }\n\t        return attrs;\n\t    }\n\t    function isSameNodeType(node, vnode) {\n\t        if (isFunctionalComponent(vnode)) return !0;\n\t        var nodeName = vnode.nodeName;\n\t        if (isFunction(nodeName)) return node._componentConstructor === nodeName;\n\t        if (3 === getNodeType(node)) return isString(vnode); else return toLowerCase(node.nodeName) === nodeName;\n\t    }\n\t    function getNodeProps(vnode) {\n\t        var props = clone(vnode.attributes), c = vnode.children;\n\t        if (c) props.children = c;\n\t        var defaultProps = vnode.nodeName.defaultProps;\n\t        if (defaultProps) for (var i in defaultProps) if (hasOwnProperty.call(defaultProps, i) && !(i in props)) props[i] = defaultProps[i];\n\t        return props;\n\t    }\n\t    function collectNode(node) {\n\t        cleanNode(node);\n\t        var name = normalizeName(node.nodeName), list = nodes[name];\n\t        if (list) list.push(node); else nodes[name] = [ node ];\n\t    }\n\t    function createNode(nodeName) {\n\t        var name = normalizeName(nodeName), list = nodes[name], node = list && list.pop() || document.createElement(nodeName);\n\t        ensureNodeData(node);\n\t        return node;\n\t    }\n\t    function cleanNode(node) {\n\t        var p = node.parentNode;\n\t        if (p) p.removeChild(node);\n\t        if (3 !== getNodeType(node)) {\n\t            if (!node[ATTR_KEY]) node[ATTR_KEY] = getRawNodeAttributes(node);\n\t            node._component = node._componentConstructor = null;\n\t        }\n\t    }\n\t    function diff(dom, vnode, context) {\n\t        var originalAttributes = vnode.attributes;\n\t        for (;isFunctionalComponent(vnode); ) vnode = buildFunctionalComponent(vnode, context);\n\t        if (isFunction(vnode.nodeName)) return buildComponentFromVNode(dom, vnode, context);\n\t        if (isString(vnode)) {\n\t            if (dom) {\n\t                var type = getNodeType(dom);\n\t                if (3 === type) {\n\t                    dom[TEXT_CONTENT] = vnode;\n\t                    return dom;\n\t                } else if (1 === type) collectNode(dom);\n\t            }\n\t            return document.createTextNode(vnode);\n\t        }\n\t        var out = dom, nodeName = vnode.nodeName || UNDEFINED_ELEMENT;\n\t        if (!dom) out = createNode(nodeName); else if (toLowerCase(dom.nodeName) !== nodeName) {\n\t            out = createNode(nodeName);\n\t            appendChildren(out, toArray(dom.childNodes));\n\t            recollectNodeTree(dom);\n\t        }\n\t        innerDiffNode(out, vnode, context);\n\t        diffAttributes(out, vnode);\n\t        if (originalAttributes && originalAttributes.ref) (out[ATTR_KEY].ref = originalAttributes.ref)(out);\n\t        return out;\n\t    }\n\t    function innerDiffNode(dom, vnode, context) {\n\t        var children = void 0, keyed = void 0, keyedLen = 0, len = dom.childNodes.length, childrenLen = 0;\n\t        if (len) {\n\t            children = [];\n\t            for (var i = 0; len > i; i++) {\n\t                var child = dom.childNodes[i], props = child._component && child._component.props, key = props ? props.key : getAccessor(child, 'key');\n\t                if (!empty(key)) {\n\t                    if (!keyed) keyed = {};\n\t                    keyed[key] = child;\n\t                    keyedLen++;\n\t                } else children[childrenLen++] = child;\n\t            }\n\t        }\n\t        var vchildren = vnode.children, vlen = vchildren && vchildren.length, min = 0;\n\t        if (vlen) for (var i = 0; vlen > i; i++) {\n\t            var vchild = vchildren[i], child = void 0;\n\t            if (keyedLen) {\n\t                var attrs = vchild.attributes, key = attrs && attrs.key;\n\t                if (!empty(key) && hasOwnProperty.call(keyed, key)) {\n\t                    child = keyed[key];\n\t                    keyed[key] = null;\n\t                    keyedLen--;\n\t                }\n\t            }\n\t            if (!child && childrenLen > min) for (var j = min; childrenLen > j; j++) {\n\t                var c = children[j];\n\t                if (c && isSameNodeType(c, vchild)) {\n\t                    child = c;\n\t                    children[j] = null;\n\t                    if (j === childrenLen - 1) childrenLen--;\n\t                    if (j === min) min++;\n\t                    break;\n\t                }\n\t            }\n\t            child = diff(child, vchild, context);\n\t            if (dom.childNodes[i] !== child) {\n\t                var c = child.parentNode !== dom && child._component, next = dom.childNodes[i + 1];\n\t                if (c) deepHook(c, 'componentWillMount');\n\t                if (next) dom.insertBefore(child, next); else dom.appendChild(child);\n\t                if (c) deepHook(c, 'componentDidMount');\n\t            }\n\t        }\n\t        if (keyedLen) for (var i in keyed) if (hasOwnProperty.call(keyed, i) && keyed[i]) children[min = childrenLen++] = keyed[i];\n\t        if (childrenLen > min) removeOrphanedChildren(children);\n\t    }\n\t    function removeOrphanedChildren(children, unmountOnly) {\n\t        for (var i = children.length; i--; ) {\n\t            var child = children[i];\n\t            if (child) recollectNodeTree(child, unmountOnly);\n\t        }\n\t    }\n\t    function recollectNodeTree(node, unmountOnly) {\n\t        var attrs = node[ATTR_KEY];\n\t        if (attrs) hook(attrs, 'ref', null);\n\t        var component = node._component;\n\t        if (component) unmountComponent(node, component, !unmountOnly); else {\n\t            if (!unmountOnly) {\n\t                if (1 !== getNodeType(node)) {\n\t                    var p = node.parentNode;\n\t                    if (p) p.removeChild(node);\n\t                    return;\n\t                }\n\t                collectNode(node);\n\t            }\n\t            var c = node.childNodes;\n\t            if (c && c.length) removeOrphanedChildren(c, unmountOnly);\n\t        }\n\t    }\n\t    function diffAttributes(dom, vnode) {\n\t        var old = getNodeAttributes(dom) || EMPTY, attrs = vnode.attributes || EMPTY, name = void 0, value = void 0;\n\t        for (name in old) if (empty(attrs[name])) setAccessor(dom, name, null);\n\t        if (attrs !== EMPTY) for (name in attrs) if (hasOwnProperty.call(attrs, name)) {\n\t            value = attrs[name];\n\t            if (!empty(value) && value != getAccessor(dom, name)) setAccessor(dom, name, value);\n\t        }\n\t    }\n\t    function collectComponent(component) {\n\t        var name = component.constructor.name, list = components[name];\n\t        if (list) list.push(component); else components[name] = [ component ];\n\t    }\n\t    function createComponent(ctor, props, context) {\n\t        var list = components[ctor.name], len = list && list.length, c = void 0;\n\t        for (var i = 0; len > i; i++) {\n\t            c = list[i];\n\t            if (c.constructor === ctor) {\n\t                list.splice(i, 1);\n\t                return c;\n\t            }\n\t        }\n\t        return new ctor(props, context);\n\t    }\n\t    function triggerComponentRender(component) {\n\t        if (!component._dirty) {\n\t            component._dirty = !0;\n\t            enqueueRender(component);\n\t        }\n\t    }\n\t    function setComponentProps(component, props, opts, context) {\n\t        var d = component._disableRendering;\n\t        component._ref = props.ref;\n\t        delete props.ref;\n\t        delete props.key;\n\t        component._disableRendering = !0;\n\t        if (context) {\n\t            if (!component.prevContext) component.prevContext = component.context;\n\t            component.context = context;\n\t        }\n\t        if (component.base) hook(component, 'componentWillReceiveProps', props, component.context);\n\t        if (!component.prevProps) component.prevProps = component.props;\n\t        component.props = props;\n\t        component._disableRendering = d;\n\t        if (!opts || opts.render !== !1) if (opts && opts.renderSync || options.syncComponentUpdates !== !1) renderComponent(component); else triggerComponentRender(component);\n\t        hook(component, '_ref', component);\n\t    }\n\t    function renderComponent(component, opts) {\n\t        if (!component._disableRendering) {\n\t            var skip = void 0, rendered = void 0, props = component.props, state = component.state, context = component.context, previousProps = component.prevProps || props, previousState = component.prevState || state, previousContext = component.prevContext || context, isUpdate = component.base;\n\t            if (isUpdate) {\n\t                component.props = previousProps;\n\t                component.state = previousState;\n\t                component.context = previousContext;\n\t                if (hook(component, 'shouldComponentUpdate', props, state, context) === !1) skip = !0; else hook(component, 'componentWillUpdate', props, state, context);\n\t                component.props = props;\n\t                component.state = state;\n\t                component.context = context;\n\t            }\n\t            component.prevProps = component.prevState = component.prevContext = null;\n\t            component._dirty = !1;\n\t            if (!skip) {\n\t                rendered = hook(component, 'render', props, state, context);\n\t                var childComponent = rendered && rendered.nodeName, childContext = component.getChildContext ? component.getChildContext() : context, toUnmount = void 0, base = void 0;\n\t                if (isFunction(childComponent) && childComponent.prototype.render) {\n\t                    var inst = component._component;\n\t                    if (inst && inst.constructor !== childComponent) {\n\t                        toUnmount = inst;\n\t                        inst = null;\n\t                    }\n\t                    var childProps = getNodeProps(rendered);\n\t                    if (inst) setComponentProps(inst, childProps, SYNC_RENDER, childContext); else {\n\t                        inst = createComponent(childComponent, childProps, childContext);\n\t                        inst._parentComponent = component;\n\t                        component._component = inst;\n\t                        if (component.base) deepHook(inst, 'componentWillMount');\n\t                        setComponentProps(inst, childProps, NO_RENDER, childContext);\n\t                        renderComponent(inst, DOM_RENDER);\n\t                        if (component.base) deepHook(inst, 'componentDidMount');\n\t                    }\n\t                    base = inst.base;\n\t                } else {\n\t                    var cbase = component.base;\n\t                    toUnmount = component._component;\n\t                    if (toUnmount) cbase = component._component = null;\n\t                    if (component.base || opts && opts.build) base = diff(cbase, rendered || EMPTY_BASE, childContext);\n\t                }\n\t                if (component.base && base !== component.base) {\n\t                    var p = component.base.parentNode;\n\t                    if (p) p.replaceChild(base, component.base);\n\t                }\n\t                if (toUnmount) unmountComponent(toUnmount.base, toUnmount, !0);\n\t                component.base = base;\n\t                if (base) {\n\t                    var componentRef = component, t = component;\n\t                    for (;t = t._parentComponent; ) componentRef = t;\n\t                    base._component = componentRef;\n\t                    base._componentConstructor = componentRef.constructor;\n\t                }\n\t                if (isUpdate) hook(component, 'componentDidUpdate', previousProps, previousState, previousContext);\n\t            }\n\t            var cb = component._renderCallbacks, fn = void 0;\n\t            if (cb) for (;fn = cb.pop(); ) fn.call(component);\n\t            return rendered;\n\t        }\n\t    }\n\t    function buildComponentFromVNode(dom, vnode, context) {\n\t        var c = dom && dom._component, oldDom = dom;\n\t        var isOwner = c && dom._componentConstructor === vnode.nodeName;\n\t        for (;c && !isOwner && (c = c._parentComponent); ) isOwner = c.constructor === vnode.nodeName;\n\t        if (isOwner) {\n\t            setComponentProps(c, getNodeProps(vnode), SYNC_RENDER, context);\n\t            dom = c.base;\n\t        } else {\n\t            if (c) {\n\t                unmountComponent(dom, c, !0);\n\t                dom = oldDom = null;\n\t            }\n\t            dom = createComponentFromVNode(vnode, dom, context);\n\t            if (oldDom && dom !== oldDom) recollectNodeTree(oldDom);\n\t        }\n\t        return dom;\n\t    }\n\t    function createComponentFromVNode(vnode, dom, context) {\n\t        var props = getNodeProps(vnode);\n\t        var component = createComponent(vnode.nodeName, props, context);\n\t        if (dom && !component.base) component.base = dom;\n\t        setComponentProps(component, props, NO_RENDER, context);\n\t        renderComponent(component, DOM_RENDER);\n\t        return component.base;\n\t    }\n\t    function unmountComponent(dom, component, remove) {\n\t        hook(component, '_ref', null);\n\t        hook(component, 'componentWillUnmount');\n\t        var inner = component._component;\n\t        if (inner) unmountComponent(dom, inner);\n\t        var base = component.base;\n\t        if (base) {\n\t            if (remove !== !1) {\n\t                var p = base.parentNode;\n\t                if (p) p.removeChild(base);\n\t            }\n\t            removeOrphanedChildren(base.childNodes, !0);\n\t        }\n\t        if (remove) {\n\t            component._parentComponent = null;\n\t            collectComponent(component);\n\t        }\n\t        hook(component, 'componentDidUnmount');\n\t    }\n\t    function Component(props, context) {\n\t        this._dirty = this._disableRendering = !1;\n\t        this._linkedStates = {};\n\t        this._renderCallbacks = [];\n\t        this.prevState = this.prevProps = this.prevContext = this.base = this._parentComponent = this._component = this._ref = null;\n\t        this.context = context || {};\n\t        this.props = props || {};\n\t        this.state = hook(this, 'getInitialState') || {};\n\t    }\n\t    function render(vnode, parent, merge) {\n\t        var existing = merge && merge._component && merge._componentConstructor === vnode.nodeName, built = diff(merge, vnode), c = !existing && built._component;\n\t        if (c) deepHook(c, 'componentWillMount');\n\t        if (built.parentNode !== parent) parent.appendChild(built);\n\t        if (c) deepHook(c, 'componentDidMount');\n\t        return built;\n\t    }\n\t    var NO_RENDER = {\n\t        render: !1\n\t    };\n\t    var SYNC_RENDER = {\n\t        renderSync: !0\n\t    };\n\t    var DOM_RENDER = {\n\t        build: !0\n\t    };\n\t    var EMPTY = {};\n\t    var EMPTY_BASE = '';\n\t    var HAS_DOM = 'undefined' != typeof document;\n\t    var TEXT_CONTENT = !HAS_DOM || 'textContent' in document ? 'textContent' : 'nodeValue';\n\t    var ATTR_KEY = 'undefined' != typeof Symbol ? Symbol('preactattr') : '__preactattr_';\n\t    var UNDEFINED_ELEMENT = 'undefined';\n\t    var NON_DIMENSION_PROPS = {\n\t        boxFlex: 1,\n\t        boxFlexGroup: 1,\n\t        columnCount: 1,\n\t        fillOpacity: 1,\n\t        flex: 1,\n\t        flexGrow: 1,\n\t        flexPositive: 1,\n\t        flexShrink: 1,\n\t        flexNegative: 1,\n\t        fontWeight: 1,\n\t        lineClamp: 1,\n\t        lineHeight: 1,\n\t        opacity: 1,\n\t        order: 1,\n\t        orphans: 1,\n\t        strokeOpacity: 1,\n\t        widows: 1,\n\t        zIndex: 1,\n\t        zoom: 1\n\t    };\n\t    var isFunction = function(obj) {\n\t        return 'function' == typeof obj;\n\t    };\n\t    var isString = function(obj) {\n\t        return 'string' == typeof obj;\n\t    };\n\t    var hasOwnProperty = {}.hasOwnProperty;\n\t    var empty = function(x) {\n\t        return null == x;\n\t    };\n\t    var falsey = function(value) {\n\t        return value === !1 || null == value;\n\t    };\n\t    var jsToCss = memoize(function(s) {\n\t        return s.replace(/([A-Z])/g, '-$1').toLowerCase();\n\t    });\n\t    var toLowerCase = memoize(function(s) {\n\t        return s.toLowerCase();\n\t    });\n\t    var ch = void 0;\n\t    try {\n\t        ch = new MessageChannel();\n\t    } catch (e) {}\n\t    var setImmediate = ch ? function(f) {\n\t        ch.port1.onmessage = f;\n\t        ch.port2.postMessage('');\n\t    } : setTimeout;\n\t    var options = {\n\t        vnode: function(n) {\n\t            var attrs = n.attributes;\n\t            if (attrs && !isFunction(n.nodeName)) {\n\t                var p = attrs.className;\n\t                if (p) {\n\t                    attrs['class'] = p;\n\t                    delete attrs.className;\n\t                }\n\t                if (attrs['class']) normalize(attrs, 'class', hashToClassName);\n\t                if (attrs.style) normalize(attrs, 'style', styleObjToCss);\n\t            }\n\t        }\n\t    };\n\t    var SHARED_TEMP_ARRAY = [];\n\t    var items = [];\n\t    var itemsOffline = [];\n\t    var normalizeEventName = memoize(function(t) {\n\t        return t.replace(/^on/i, '').toLowerCase();\n\t    });\n\t    var nodes = {};\n\t    var normalizeName = memoize(function(name) {\n\t        return name.toUpperCase();\n\t    });\n\t    var components = {};\n\t    extend(Component.prototype, {\n\t        linkState: function(key, eventPath) {\n\t            var c = this._linkedStates, cacheKey = key + '|' + (eventPath || '');\n\t            return c[cacheKey] || (c[cacheKey] = createLinkedState(this, key, eventPath));\n\t        },\n\t        setState: function(state, callback) {\n\t            var s = this.state;\n\t            if (!this.prevState) this.prevState = clone(s);\n\t            extend(s, isFunction(state) ? state(s, this.props) : state);\n\t            if (callback) this._renderCallbacks.push(callback);\n\t            triggerComponentRender(this);\n\t        },\n\t        forceUpdate: function() {\n\t            renderComponent(this);\n\t        },\n\t        render: function() {\n\t            return null;\n\t        }\n\t    });\n\t    var preact = {\n\t        h: h,\n\t        Component: Component,\n\t        render: render,\n\t        rerender: rerender,\n\t        options: options,\n\t        hooks: options\n\t    };\n\t    return preact;\n\t});\n\t//# sourceMappingURL=preact.js.map\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3).setImmediate))\n\n/***/ },\n/* 2 */\n/***/ function(module, exports) {\n\n\t// shim for using process in browser\n\t\n\tvar process = module.exports = {};\n\tvar queue = [];\n\tvar draining = false;\n\tvar currentQueue;\n\tvar queueIndex = -1;\n\t\n\tfunction cleanUpNextTick() {\n\t    draining = false;\n\t    if (currentQueue.length) {\n\t        queue = currentQueue.concat(queue);\n\t    } else {\n\t        queueIndex = -1;\n\t    }\n\t    if (queue.length) {\n\t        drainQueue();\n\t    }\n\t}\n\t\n\tfunction drainQueue() {\n\t    if (draining) {\n\t        return;\n\t    }\n\t    var timeout = setTimeout(cleanUpNextTick);\n\t    draining = true;\n\t\n\t    var len = queue.length;\n\t    while(len) {\n\t        currentQueue = queue;\n\t        queue = [];\n\t        while (++queueIndex < len) {\n\t            if (currentQueue) {\n\t                currentQueue[queueIndex].run();\n\t            }\n\t        }\n\t        queueIndex = -1;\n\t        len = queue.length;\n\t    }\n\t    currentQueue = null;\n\t    draining = false;\n\t    clearTimeout(timeout);\n\t}\n\t\n\tprocess.nextTick = function (fun) {\n\t    var args = new Array(arguments.length - 1);\n\t    if (arguments.length > 1) {\n\t        for (var i = 1; i < arguments.length; i++) {\n\t            args[i - 1] = arguments[i];\n\t        }\n\t    }\n\t    queue.push(new Item(fun, args));\n\t    if (queue.length === 1 && !draining) {\n\t        setTimeout(drainQueue, 0);\n\t    }\n\t};\n\t\n\t// v8 likes predictible objects\n\tfunction Item(fun, array) {\n\t    this.fun = fun;\n\t    this.array = array;\n\t}\n\tItem.prototype.run = function () {\n\t    this.fun.apply(null, this.array);\n\t};\n\tprocess.title = 'browser';\n\tprocess.browser = true;\n\tprocess.env = {};\n\tprocess.argv = [];\n\tprocess.version = ''; // empty string to avoid regexp issues\n\tprocess.versions = {};\n\t\n\tfunction noop() {}\n\t\n\tprocess.on = noop;\n\tprocess.addListener = noop;\n\tprocess.once = noop;\n\tprocess.off = noop;\n\tprocess.removeListener = noop;\n\tprocess.removeAllListeners = noop;\n\tprocess.emit = noop;\n\t\n\tprocess.binding = function (name) {\n\t    throw new Error('process.binding is not supported');\n\t};\n\t\n\tprocess.cwd = function () { return '/' };\n\tprocess.chdir = function (dir) {\n\t    throw new Error('process.chdir is not supported');\n\t};\n\tprocess.umask = function() { return 0; };\n\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(setImmediate, clearImmediate) {var nextTick = __webpack_require__(2).nextTick;\n\tvar apply = Function.prototype.apply;\n\tvar slice = Array.prototype.slice;\n\tvar immediateIds = {};\n\tvar nextImmediateId = 0;\n\t\n\t// DOM APIs, for completeness\n\t\n\texports.setTimeout = function() {\n\t  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);\n\t};\n\texports.setInterval = function() {\n\t  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);\n\t};\n\texports.clearTimeout =\n\texports.clearInterval = function(timeout) { timeout.close(); };\n\t\n\tfunction Timeout(id, clearFn) {\n\t  this._id = id;\n\t  this._clearFn = clearFn;\n\t}\n\tTimeout.prototype.unref = Timeout.prototype.ref = function() {};\n\tTimeout.prototype.close = function() {\n\t  this._clearFn.call(window, this._id);\n\t};\n\t\n\t// Does not start the time, just sets up the members needed.\n\texports.enroll = function(item, msecs) {\n\t  clearTimeout(item._idleTimeoutId);\n\t  item._idleTimeout = msecs;\n\t};\n\t\n\texports.unenroll = function(item) {\n\t  clearTimeout(item._idleTimeoutId);\n\t  item._idleTimeout = -1;\n\t};\n\t\n\texports._unrefActive = exports.active = function(item) {\n\t  clearTimeout(item._idleTimeoutId);\n\t\n\t  var msecs = item._idleTimeout;\n\t  if (msecs >= 0) {\n\t    item._idleTimeoutId = setTimeout(function onTimeout() {\n\t      if (item._onTimeout)\n\t        item._onTimeout();\n\t    }, msecs);\n\t  }\n\t};\n\t\n\t// That's not how node.js implements it but the exposed api is the same.\n\texports.setImmediate = typeof setImmediate === \"function\" ? setImmediate : function(fn) {\n\t  var id = nextImmediateId++;\n\t  var args = arguments.length < 2 ? false : slice.call(arguments, 1);\n\t\n\t  immediateIds[id] = true;\n\t\n\t  nextTick(function onNextTick() {\n\t    if (immediateIds[id]) {\n\t      // fn.call() is faster so we optimize for the common use-case\n\t      // @see http://jsperf.com/call-apply-segu\n\t      if (args) {\n\t        fn.apply(null, args);\n\t      } else {\n\t        fn.call(null);\n\t      }\n\t      // Prevent ids from leaking\n\t      exports.clearImmediate(id);\n\t    }\n\t  });\n\t\n\t  return id;\n\t};\n\t\n\texports.clearImmediate = typeof clearImmediate === \"function\" ? clearImmediate : function(id) {\n\t  delete immediateIds[id];\n\t};\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3).setImmediate, __webpack_require__(3).clearImmediate))\n\n/***/ },\n/* 4 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\texports.__esModule = true;\n\texports.uuid = uuid;\n\texports.pluralize = pluralize;\n\texports.store = store;\n\tfunction uuid() {\n\t\tvar uuid = '';\n\t\tfor (var i = 0; i < 32; i++) {\n\t\t\tvar random = Math.random() * 16 | 0;\n\t\t\tif (i === 8 || i === 12 || i === 16 || i === 20) {\n\t\t\t\tuuid += '-';\n\t\t\t}\n\t\t\tuuid += (i === 12 ? 4 : i === 16 ? random & 3 | 8 : random).toString(16);\n\t\t}\n\t\treturn uuid;\n\t}\n\t\n\tfunction pluralize(count, word) {\n\t\treturn count === 1 ? word : word + 's';\n\t}\n\t\n\tfunction store(namespace, data) {\n\t\tif (data) {\n\t\t\treturn localStorage.setItem(namespace, JSON.stringify(data));\n\t\t}\n\t\n\t\tvar store = localStorage.getItem(namespace);\n\t\treturn store && JSON.parse(store) || [];\n\t}\n\n/***/ },\n/* 5 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(global,factory){if(true){!(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));}else if(typeof exports !== 'undefined'){factory(exports);}else {var mod={exports:{}};factory(mod.exports);global.decko = mod.exports;}})(this,function(exports){'use strict';exports.__esModule = true;var EMPTY={};var HOP=Object.prototype.hasOwnProperty;var fns={memoize:function memoize(fn){var opt=arguments.length <= 1 || arguments[1] === undefined?EMPTY:arguments[1];var cache=opt.cache || {};return function(){for(var _len=arguments.length,a=Array(_len),_key=0;_key < _len;_key++) {a[_key] = arguments[_key];}var k=String(a[0]);if(opt.caseSensitive === false)k = k.toLowerCase();return HOP.call(cache,k)?cache[k]:cache[k] = fn.apply(this,a);};},debounce:function debounce(fn,opts){if(typeof opts === 'function'){var p=fn;fn = opts;opts = p;}var delay=opts && opts.delay || opts || 0,args=undefined,context=undefined,timer=undefined;return function(){for(var _len2=arguments.length,a=Array(_len2),_key2=0;_key2 < _len2;_key2++) {a[_key2] = arguments[_key2];}args = a;context = this;if(!timer)timer = setTimeout(function(){fn.apply(context,args);args = context = timer = null;},delay);};},bind:function bind(target,key,_ref){var fn=_ref.value;return {configurable:true,get:function get(){var value=fn.bind(this);Object.defineProperty(this,key,{value:value,configurable:true,writable:true});return value;}};}};var memoize=multiMethod(fns.memoize),debounce=multiMethod(fns.debounce),bind=multiMethod(function(f,c){return f.bind(c);},function(){return fns.bind;});exports.memoize = memoize;exports.debounce = debounce;exports.bind = bind;exports['default'] = {memoize:memoize,debounce:debounce,bind:bind};function multiMethod(inner,deco){deco = deco || inner.decorate || decorator(inner);var d=deco();return function(){for(var _len3=arguments.length,args=Array(_len3),_key3=0;_key3 < _len3;_key3++) {args[_key3] = arguments[_key3];}var l=args.length;return (l < 2?deco:l > 2?d:inner).apply(undefined,args);};}function decorator(fn){return function(opt){return typeof opt === 'function'?fn(opt):function(target,key,desc){desc.value = fn(desc.value,opt,target,key,desc);};};}});\n\t\n\t//# sourceMappingURL=decko.js.map\n\n/***/ },\n/* 6 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t(function (global, factory) {\n\t\t true ? module.exports = factory(__webpack_require__(1)) :\n\t\ttypeof define === 'function' && define.amd ? define(['preact'], factory) :\n\t\t(global.preactRouter = factory(global.preact));\n\t}(this, function (preact) { 'use strict';\n\t\n\t\tvar babelHelpers = {};\n\t\n\t\tbabelHelpers.inherits = function (subClass, superClass) {\n\t\t  if (typeof superClass !== \"function\" && superClass !== null) {\n\t\t    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n\t\t  }\n\t\n\t\t  subClass.prototype = Object.create(superClass && superClass.prototype, {\n\t\t    constructor: {\n\t\t      value: subClass,\n\t\t      enumerable: false,\n\t\t      writable: true,\n\t\t      configurable: true\n\t\t    }\n\t\t  });\n\t\t  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n\t\t};\n\t\n\t\tbabelHelpers.objectWithoutProperties = function (obj, keys) {\n\t\t  var target = {};\n\t\n\t\t  for (var i in obj) {\n\t\t    if (keys.indexOf(i) >= 0) continue;\n\t\t    if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;\n\t\t    target[i] = obj[i];\n\t\t  }\n\t\n\t\t  return target;\n\t\t};\n\t\n\t\tbabelHelpers._extends = Object.assign || function (target) {\n\t\t  for (var i = 1; i < arguments.length; i++) {\n\t\t    var source = arguments[i];\n\t\n\t\t    for (var key in source) {\n\t\t      if (Object.prototype.hasOwnProperty.call(source, key)) {\n\t\t        target[key] = source[key];\n\t\t      }\n\t\t    }\n\t\t  }\n\t\n\t\t  return target;\n\t\t};\n\t\n\t\tbabelHelpers.classCallCheck = function (instance, Constructor) {\n\t\t  if (!(instance instanceof Constructor)) {\n\t\t    throw new TypeError(\"Cannot call a class as a function\");\n\t\t  }\n\t\t};\n\t\tvar EMPTY$1 = {};\n\t\n\t\tfunction exec(url, route) {\n\t\t\tvar opts = arguments.length <= 2 || arguments[2] === undefined ? EMPTY$1 : arguments[2];\n\t\n\t\t\tvar reg = /(?:\\?([^#]*))?(#.*)?$/,\n\t\t\t    c = url.match(reg),\n\t\t\t    matches = {},\n\t\t\t    ret = undefined;\n\t\t\tif (c && c[1]) {\n\t\t\t\tvar p = c[1].split('&');\n\t\t\t\tfor (var i = 0; i < p.length; i++) {\n\t\t\t\t\tvar r = p[i].split('=');\n\t\t\t\t\tmatches[decodeURIComponent(r[0])] = decodeURIComponent(r.slice(1).join('='));\n\t\t\t\t}\n\t\t\t}\n\t\t\turl = segmentize(url.replace(reg, ''));\n\t\t\troute = segmentize(route || '');\n\t\t\tvar max = Math.max(url.length, route.length);\n\t\t\tfor (var i = 0; i < max; i++) {\n\t\t\t\tif (route[i] && route[i].charAt(0) === ':') {\n\t\t\t\t\tvar param = route[i].replace(/(^\\:|[+*?]+$)/g, ''),\n\t\t\t\t\t    flags = (route[i].match(/[+*?]+$/) || EMPTY$1)[0] || '',\n\t\t\t\t\t    plus = ~flags.indexOf('+'),\n\t\t\t\t\t    star = ~flags.indexOf('*'),\n\t\t\t\t\t    val = url[i] || '';\n\t\t\t\t\tif (!val && !star && (flags.indexOf('?') < 0 || plus)) {\n\t\t\t\t\t\tret = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tmatches[param] = decodeURIComponent(val);\n\t\t\t\t\tif (plus || star) {\n\t\t\t\t\t\tmatches[param] = url.slice(i).map(decodeURIComponent).join('/');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (route[i] !== url[i]) {\n\t\t\t\t\t\tret = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (opts['default'] !== true && ret === false) return false;\n\t\t\treturn matches;\n\t\t}\n\t\n\t\tfunction pathRankSort(a, b) {\n\t\t\tvar aAttr = a.attributes || EMPTY$1,\n\t\t\t    bAttr = b.attributes || EMPTY$1;\n\t\t\tif (aAttr['default']) return 1;\n\t\t\tif (bAttr['default']) return -1;\n\t\t\tvar diff = rank(aAttr.path) - rank(bAttr.path);\n\t\t\treturn diff || aAttr.path.length - bAttr.path.length;\n\t\t}\n\t\n\t\tfunction segmentize(url) {\n\t\t\treturn strip(url).split('/');\n\t\t}\n\t\n\t\tfunction rank(url) {\n\t\t\treturn (strip(url).match(/\\/+/g) || '').length;\n\t\t}\n\t\n\t\tfunction strip(url) {\n\t\t\treturn url.replace(/(^\\/+|\\/+$)/g, '');\n\t\t}\n\t\n\t\tvar routers = [];\n\t\n\t\tvar EMPTY = {};\n\t\n\t\tfunction route(url) {\n\t\t\tvar replace = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];\n\t\n\t\t\tif (typeof url !== 'string' && url.url) {\n\t\t\t\treplace = url.replace;\n\t\t\t\turl = url.url;\n\t\t\t}\n\t\t\tif (history) {\n\t\t\t\tif (replace === true) {\n\t\t\t\t\thistory.replaceState(null, null, url);\n\t\t\t\t} else {\n\t\t\t\t\thistory.pushState(null, null, url);\n\t\t\t\t}\n\t\t\t}\n\t\t\trouteTo(url);\n\t\t}\n\t\n\t\tfunction routeTo(url) {\n\t\t\trouters.forEach(function (router) {\n\t\t\t\treturn router.routeTo(url);\n\t\t\t});\n\t\t}\n\t\n\t\tfunction getCurrentUrl() {\n\t\t\tvar url = typeof location !== 'undefined' ? location : EMPTY;\n\t\t\treturn '' + (url.pathname || '') + (url.search || '');\n\t\t}\n\t\n\t\tif (typeof addEventListener === 'function') {\n\t\t\taddEventListener('popstate', function () {\n\t\t\t\treturn routeTo(getCurrentUrl());\n\t\t\t});\n\t\t}\n\t\n\t\tfunction handleLinkClick(e) {\n\t\t\troute(this.getAttribute('href'));\n\t\t\tif (e.stopImmediatePropagation) e.stopImmediatePropagation();\n\t\t\te.stopPropagation();\n\t\t\te.preventDefault();\n\t\t\treturn false;\n\t\t}\n\t\n\t\tvar Link = function Link(_ref) {\n\t\t\tvar children = _ref.children;\n\t\t\tvar props = babelHelpers.objectWithoutProperties(_ref, ['children']);\n\t\t\treturn preact.h(\n\t\t\t\t'a',\n\t\t\t\tbabelHelpers._extends({}, props, { onClick: handleLinkClick }),\n\t\t\t\tchildren\n\t\t\t);\n\t\t};\n\t\n\t\tvar Router = (function (_Component) {\n\t\t\tbabelHelpers.inherits(Router, _Component);\n\t\n\t\t\tfunction Router() {\n\t\t\t\tbabelHelpers.classCallCheck(this, Router);\n\t\n\t\t\t\t_Component.apply(this, arguments);\n\t\t\t}\n\t\n\t\t\tRouter.prototype.getInitialState = function getInitialState() {\n\t\t\t\treturn { url: getCurrentUrl() };\n\t\t\t};\n\t\n\t\t\tRouter.prototype.routeTo = function routeTo(url) {\n\t\t\t\tthis.setState({ url: url });\n\t\t\t};\n\t\n\t\t\tRouter.prototype.componentWillMount = function componentWillMount() {\n\t\t\t\trouters.push(this);\n\t\t\t};\n\t\n\t\t\tRouter.prototype.componentWillUnmount = function componentWillUnmount() {\n\t\t\t\trouters.splice(routers.indexOf(this), 1);\n\t\t\t};\n\t\n\t\t\tRouter.prototype.render = function render(_ref2, _ref3) {\n\t\t\t\tvar children = _ref2.children;\n\t\t\t\tvar onChange = _ref2.onChange;\n\t\t\t\tvar url = _ref3.url;\n\t\n\t\t\t\tvar active = children.slice().sort(pathRankSort).filter(function (_ref4) {\n\t\t\t\t\tvar attributes = _ref4.attributes;\n\t\n\t\t\t\t\tvar path = attributes.path,\n\t\t\t\t\t    matches = exec(url, path, attributes);\n\t\t\t\t\tif (matches) {\n\t\t\t\t\t\tattributes.url = url;\n\t\t\t\t\t\tattributes.matches = matches;\n\t\t\t\t\t\t// copy matches onto props\n\t\t\t\t\t\tfor (var i in matches) {\n\t\t\t\t\t\t\tif (matches.hasOwnProperty(i)) {\n\t\t\t\t\t\t\t\tattributes[i] = matches[i];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tvar previous = this.previousUrl;\n\t\t\t\tif (url !== previous) {\n\t\t\t\t\tthis.previousUrl = url;\n\t\t\t\t\tif (typeof onChange === 'function') {\n\t\t\t\t\t\tonChange({\n\t\t\t\t\t\t\trouter: this,\n\t\t\t\t\t\t\turl: url,\n\t\t\t\t\t\t\tprevious: previous,\n\t\t\t\t\t\t\tactive: active,\n\t\t\t\t\t\t\tcurrent: active[0]\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn active[0] || null;\n\t\t\t};\n\t\n\t\t\treturn Router;\n\t\t})(preact.Component);\n\t\n\t\tvar Route = function Route(_ref5) {\n\t\t\tvar RoutedComponent = _ref5.component;\n\t\t\tvar url = _ref5.url;\n\t\t\tvar matches = _ref5.matches;\n\t\t\treturn preact.h(RoutedComponent, { url: url, matches: matches });\n\t\t};\n\t\n\t\tRouter.route = route;\n\t\tRouter.Router = Router;\n\t\tRouter.Route = Route;\n\t\tRouter.Link = Link;\n\t\n\t\treturn Router;\n\t\n\t}));\n\t//# sourceMappingURL=preact-router.js.map\n\n/***/ },\n/* 7 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tmodule.exports = argsArray;\n\t\n\tfunction argsArray(fun) {\n\t  return function () {\n\t    var len = arguments.length;\n\t    if (len) {\n\t      var args = [];\n\t      var i = -1;\n\t      while (++i < len) {\n\t        args[i] = arguments[i];\n\t      }\n\t      return fun.call(this, args);\n\t    } else {\n\t      return fun.call(this, []);\n\t    }\n\t  };\n\t}\n\n/***/ },\n/* 8 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\texports.__esModule = true;\n\texports.default = undefined;\n\t\n\tvar _preact = __webpack_require__(1);\n\t\n\tvar _preactRouter = __webpack_require__(6);\n\t\n\tvar _util = __webpack_require__(4);\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\t\n\tvar ALL_TODOS = 'all';\n\tvar ACTIVE_TODOS = 'active';\n\tvar COMPLETED_TODOS = 'completed';\n\t\n\tvar TodoFooter = function (_Component) {\n\t\t_inherits(TodoFooter, _Component);\n\t\n\t\tfunction TodoFooter() {\n\t\t\t_classCallCheck(this, TodoFooter);\n\t\n\t\t\treturn _possibleConstructorReturn(this, _Component.apply(this, arguments));\n\t\t}\n\t\n\t\tTodoFooter.prototype.render = function render(_ref) {\n\t\t\tvar nowShowing = _ref.nowShowing;\n\t\t\tvar count = _ref.count;\n\t\t\tvar completedCount = _ref.completedCount;\n\t\t\tvar onClearCompleted = _ref.onClearCompleted;\n\t\n\t\t\treturn (0, _preact.h)(\n\t\t\t\t'footer',\n\t\t\t\t{ 'class': 'footer' },\n\t\t\t\t(0, _preact.h)(\n\t\t\t\t\t'span',\n\t\t\t\t\t{ 'class': 'todo-count' },\n\t\t\t\t\t(0, _preact.h)(\n\t\t\t\t\t\t'strong',\n\t\t\t\t\t\tnull,\n\t\t\t\t\t\tcount\n\t\t\t\t\t),\n\t\t\t\t\t' ',\n\t\t\t\t\t(0, _util.pluralize)(count, 'item'),\n\t\t\t\t\t' left'\n\t\t\t\t),\n\t\t\t\t(0, _preact.h)(\n\t\t\t\t\t'ul',\n\t\t\t\t\t{ 'class': 'filters' },\n\t\t\t\t\t(0, _preact.h)(\n\t\t\t\t\t\t'li',\n\t\t\t\t\t\tnull,\n\t\t\t\t\t\t(0, _preact.h)(\n\t\t\t\t\t\t\t_preactRouter.Link,\n\t\t\t\t\t\t\t{ href: '/', 'class': { selected: nowShowing === ALL_TODOS } },\n\t\t\t\t\t\t\t'All'\n\t\t\t\t\t\t)\n\t\t\t\t\t),\n\t\t\t\t\t' ',\n\t\t\t\t\t(0, _preact.h)(\n\t\t\t\t\t\t'li',\n\t\t\t\t\t\tnull,\n\t\t\t\t\t\t(0, _preact.h)(\n\t\t\t\t\t\t\t_preactRouter.Link,\n\t\t\t\t\t\t\t{ href: '/active', 'class': { selected: nowShowing === ACTIVE_TODOS } },\n\t\t\t\t\t\t\t'Active'\n\t\t\t\t\t\t)\n\t\t\t\t\t),\n\t\t\t\t\t' ',\n\t\t\t\t\t(0, _preact.h)(\n\t\t\t\t\t\t'li',\n\t\t\t\t\t\tnull,\n\t\t\t\t\t\t(0, _preact.h)(\n\t\t\t\t\t\t\t_preactRouter.Link,\n\t\t\t\t\t\t\t{ href: '/completed', 'class': { selected: nowShowing === COMPLETED_TODOS } },\n\t\t\t\t\t\t\t'Completed'\n\t\t\t\t\t\t)\n\t\t\t\t\t)\n\t\t\t\t),\n\t\t\t\tcompletedCount > 0 ? (0, _preact.h)(\n\t\t\t\t\t'button',\n\t\t\t\t\t{ 'class': 'clear-completed', onClick: onClearCompleted },\n\t\t\t\t\t'Clear completed'\n\t\t\t\t) : null\n\t\t\t);\n\t\t};\n\t\n\t\treturn TodoFooter;\n\t}(_preact.Component);\n\n\texports.default = TodoFooter;\n\n/***/ },\n/* 9 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\texports.__esModule = true;\n\texports.default = undefined;\n\t\n\tvar _FILTERS, _desc, _value, _class;\n\t\n\tvar _preact = __webpack_require__(1);\n\t\n\tvar _preactRouter = __webpack_require__(6);\n\t\n\tvar _decko = __webpack_require__(5);\n\t\n\tvar _model = __webpack_require__(11);\n\t\n\tvar _model2 = _interopRequireDefault(_model);\n\t\n\tvar _footer = __webpack_require__(8);\n\t\n\tvar _footer2 = _interopRequireDefault(_footer);\n\t\n\tvar _item = __webpack_require__(10);\n\t\n\tvar _item2 = _interopRequireDefault(_item);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _objectDestructuringEmpty(obj) { if (obj == null) throw new TypeError(\"Cannot destructure undefined\"); }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\t\n\tfunction _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {\n\t\tvar desc = {};\n\t\tObject['ke' + 'ys'](descriptor).forEach(function (key) {\n\t\t\tdesc[key] = descriptor[key];\n\t\t});\n\t\tdesc.enumerable = !!desc.enumerable;\n\t\tdesc.configurable = !!desc.configurable;\n\t\n\t\tif ('value' in desc || desc.initializer) {\n\t\t\tdesc.writable = true;\n\t\t}\n\t\n\t\tdesc = decorators.slice().reverse().reduce(function (desc, decorator) {\n\t\t\treturn decorator(target, property, desc) || desc;\n\t\t}, desc);\n\t\n\t\tif (context && desc.initializer !== void 0) {\n\t\t\tdesc.value = desc.initializer ? desc.initializer.call(context) : void 0;\n\t\t\tdesc.initializer = undefined;\n\t\t}\n\t\n\t\tif (desc.initializer === void 0) {\n\t\t\tObject['define' + 'Property'](target, property, desc);\n\t\t\tdesc = null;\n\t\t}\n\t\n\t\treturn desc;\n\t}\n\t\n\t// You'll need couchdb or pouchdb-server running.\n\t// see : https://pouchdb.com/guides/setup-couchdb.html#installing-couchdb\n\tvar REMOTE_DB_URL = 'http://localhost:5984/todos';\n\t\n\tvar ENTER_KEY = 13;\n\t\n\tvar ALL_TODOS = 'all';\n\tvar ACTIVE_TODOS = 'active';\n\tvar COMPLETED_TODOS = 'completed';\n\t\n\tvar FILTERS = (_FILTERS = {}, _FILTERS[ALL_TODOS] = function (todo) {\n\t\treturn true;\n\t}, _FILTERS[ACTIVE_TODOS] = function (todo) {\n\t\treturn !todo.completed;\n\t}, _FILTERS[COMPLETED_TODOS] = function (todo) {\n\t\treturn todo.completed;\n\t}, _FILTERS);\n\t\n\tvar App = (_class = function (_Component) {\n\t\t_inherits(App, _Component);\n\t\n\t\tfunction App() {\n\t\t\t_classCallCheck(this, App);\n\t\n\t\t\tvar _this = _possibleConstructorReturn(this, _Component.call(this));\n\t\n\t\t\t_this.state = { nowShowing: ALL_TODOS };\n\t\n\t\t\t_this.model = new _model2.default(REMOTE_DB_URL);\n\t\t\t_this.model.subscribe(function () {\n\t\t\t\treturn _this.setState({});\n\t\t\t});\n\t\t\treturn _this;\n\t\t}\n\t\n\t\tApp.prototype.handleRoute = function handleRoute(_ref) {\n\t\t\tvar url = _ref.url;\n\t\n\t\t\tvar nowShowing = url.replace(/\\/$/, '').split('/').pop();\n\t\t\tif (!FILTERS[nowShowing]) {\n\t\t\t\tnowShowing = ALL_TODOS;\n\t\t\t}\n\t\t\tthis.setState({ nowShowing: nowShowing });\n\t\t};\n\t\n\t\tApp.prototype.handleNewTodoKeyDown = function handleNewTodoKeyDown(e) {\n\t\t\tif (e.keyCode !== ENTER_KEY) return;\n\t\t\te.preventDefault();\n\t\n\t\t\tvar val = this.state.newTodo.trim();\n\t\t\tif (val) {\n\t\t\t\tthis.model.addTodo(val);\n\t\t\t\tthis.setState({ newTodo: '' });\n\t\t\t}\n\t\t};\n\t\n\t\tApp.prototype.toggleAll = function toggleAll(event) {\n\t\t\tvar checked = event.target.checked;\n\t\t\tthis.model.toggleAll(checked);\n\t\t};\n\t\n\t\tApp.prototype.toggle = function toggle(todoToToggle) {\n\t\t\tthis.model.toggle(todoToToggle);\n\t\t};\n\t\n\t\tApp.prototype.destroy = function destroy(todo) {\n\t\t\tthis.model.destroy(todo);\n\t\t};\n\t\n\t\tApp.prototype.edit = function edit(todo) {\n\t\t\tthis.setState({ editing: todo._id });\n\t\t};\n\t\n\t\tApp.prototype.save = function save(todoToSave, text) {\n\t\t\tthis.model.save(todoToSave, text);\n\t\t\tthis.setState({ editing: null });\n\t\t};\n\t\n\t\tApp.prototype.cancel = function cancel() {\n\t\t\tthis.setState({ editing: null });\n\t\t};\n\t\n\t\tApp.prototype.clearCompleted = function clearCompleted() {\n\t\t\tthis.model.clearCompleted();\n\t\t};\n\t\n\t\tApp.prototype.render = function render(_ref2, _ref3) {\n\t\t\tvar _this2 = this;\n\t\n\t\t\tvar _ref3$nowShowing = _ref3.nowShowing;\n\t\t\tvar nowShowing = _ref3$nowShowing === undefined ? ALL_TODOS : _ref3$nowShowing;\n\t\t\tvar newTodo = _ref3.newTodo;\n\t\t\tvar editing = _ref3.editing;\n\t\n\t\t\t_objectDestructuringEmpty(_ref2);\n\t\n\t\t\tvar todos = this.model.todos;\n\t\t\tvar shownTodos = todos.filter(FILTERS[nowShowing]);\n\t\t\tvar activeTodoCount = todos.reduce(function (a, todo) {\n\t\t\t\treturn a + (todo.completed ? 0 : 1);\n\t\t\t}, 0);\n\t\t\tvar completedCount = todos.length - activeTodoCount;\n\t\n\t\t\treturn (0, _preact.h)(\n\t\t\t\t'div',\n\t\t\t\tnull,\n\t\t\t\t(0, _preact.h)(\n\t\t\t\t\t_preactRouter.Router,\n\t\t\t\t\t{ onChange: this.handleRoute },\n\t\t\t\t\t(0, _preact.h)(Noop, { path: '/' })\n\t\t\t\t),\n\t\t\t\t(0, _preact.h)(\n\t\t\t\t\t'header',\n\t\t\t\t\t{ 'class': 'header' },\n\t\t\t\t\t(0, _preact.h)(\n\t\t\t\t\t\t'h1',\n\t\t\t\t\t\tnull,\n\t\t\t\t\t\t'todos'\n\t\t\t\t\t),\n\t\t\t\t\t(0, _preact.h)('input', {\n\t\t\t\t\t\t'class': 'new-todo',\n\t\t\t\t\t\tplaceholder: 'What needs to be done?',\n\t\t\t\t\t\tvalue: newTodo,\n\t\t\t\t\t\tonKeyDown: this.handleNewTodoKeyDown,\n\t\t\t\t\t\tonInput: this.linkState('newTodo'),\n\t\t\t\t\t\tautoFocus: true\n\t\t\t\t\t})\n\t\t\t\t),\n\t\t\t\ttodos.length ? (0, _preact.h)(\n\t\t\t\t\t'section',\n\t\t\t\t\t{ 'class': 'main' },\n\t\t\t\t\t(0, _preact.h)('input', {\n\t\t\t\t\t\t'class': 'toggle-all',\n\t\t\t\t\t\ttype: 'checkbox',\n\t\t\t\t\t\tonChange: this.toggleAll,\n\t\t\t\t\t\tchecked: activeTodoCount === 0\n\t\t\t\t\t}),\n\t\t\t\t\t(0, _preact.h)(\n\t\t\t\t\t\t'ul',\n\t\t\t\t\t\t{ 'class': 'todo-list' },\n\t\t\t\t\t\tshownTodos.map(function (todo) {\n\t\t\t\t\t\t\treturn (0, _preact.h)(_item2.default, {\n\t\t\t\t\t\t\t\ttodo: todo,\n\t\t\t\t\t\t\t\tonToggle: _this2.toggle.bind(_this2, todo),\n\t\t\t\t\t\t\t\tonDestroy: _this2.destroy.bind(_this2, todo),\n\t\t\t\t\t\t\t\tonEdit: _this2.edit.bind(_this2, todo),\n\t\t\t\t\t\t\t\tediting: editing === todo._id,\n\t\t\t\t\t\t\t\tonSave: _this2.save.bind(_this2, todo),\n\t\t\t\t\t\t\t\tonCancel: _this2.cancel\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t})\n\t\t\t\t\t)\n\t\t\t\t) : null,\n\t\t\t\tactiveTodoCount || completedCount ? (0, _preact.h)(_footer2.default, {\n\t\t\t\t\tcount: activeTodoCount,\n\t\t\t\t\tcompletedCount: completedCount,\n\t\t\t\t\tnowShowing: nowShowing,\n\t\t\t\t\tonClearCompleted: this.clearCompleted\n\t\t\t\t}) : null\n\t\t\t);\n\t\t};\n\t\n\t\treturn App;\n\t}(_preact.Component), (_applyDecoratedDescriptor(_class.prototype, 'handleRoute', [_decko.bind], Object.getOwnPropertyDescriptor(_class.prototype, 'handleRoute'), _class.prototype), _applyDecoratedDescriptor(_class.prototype, 'handleNewTodoKeyDown', [_decko.bind], Object.getOwnPropertyDescriptor(_class.prototype, 'handleNewTodoKeyDown'), _class.prototype), _applyDecoratedDescriptor(_class.prototype, 'toggleAll', [_decko.bind], Object.getOwnPropertyDescriptor(_class.prototype, 'toggleAll'), _class.prototype), _applyDecoratedDescriptor(_class.prototype, 'toggle', [_decko.bind], Object.getOwnPropertyDescriptor(_class.prototype, 'toggle'), _class.prototype), _applyDecoratedDescriptor(_class.prototype, 'destroy', [_decko.bind], Object.getOwnPropertyDescriptor(_class.prototype, 'destroy'), _class.prototype), _applyDecoratedDescriptor(_class.prototype, 'edit', [_decko.bind], Object.getOwnPropertyDescriptor(_class.prototype, 'edit'), _class.prototype), _applyDecoratedDescriptor(_class.prototype, 'save', [_decko.bind], Object.getOwnPropertyDescriptor(_class.prototype, 'save'), _class.prototype), _applyDecoratedDescriptor(_class.prototype, 'cancel', [_decko.bind], Object.getOwnPropertyDescriptor(_class.prototype, 'cancel'), _class.prototype), _applyDecoratedDescriptor(_class.prototype, 'clearCompleted', [_decko.bind], Object.getOwnPropertyDescriptor(_class.prototype, 'clearCompleted'), _class.prototype)), _class);\n\t\n\t// just a fake component we can feed to router. yay.\n\t\n\texports.default = App;\n\t\n\tvar Noop = function (_Component2) {\n\t\t_inherits(Noop, _Component2);\n\t\n\t\tfunction Noop() {\n\t\t\t_classCallCheck(this, Noop);\n\t\n\t\t\treturn _possibleConstructorReturn(this, _Component2.apply(this, arguments));\n\t\t}\n\t\n\t\tNoop.prototype.render = function render() {\n\t\t\treturn null;\n\t\t};\n\t\n\t\treturn Noop;\n\t}(_preact.Component);\n\n/***/ },\n/* 10 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\texports.__esModule = true;\n\texports.default = undefined;\n\t\n\tvar _desc, _value, _class;\n\t\n\tvar _preact = __webpack_require__(1);\n\t\n\tvar _decko = __webpack_require__(5);\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\t\n\tfunction _applyDecoratedDescriptor(target, property, decorators, descriptor, context) {\n\t\tvar desc = {};\n\t\tObject['ke' + 'ys'](descriptor).forEach(function (key) {\n\t\t\tdesc[key] = descriptor[key];\n\t\t});\n\t\tdesc.enumerable = !!desc.enumerable;\n\t\tdesc.configurable = !!desc.configurable;\n\t\n\t\tif ('value' in desc || desc.initializer) {\n\t\t\tdesc.writable = true;\n\t\t}\n\t\n\t\tdesc = decorators.slice().reverse().reduce(function (desc, decorator) {\n\t\t\treturn decorator(target, property, desc) || desc;\n\t\t}, desc);\n\t\n\t\tif (context && desc.initializer !== void 0) {\n\t\t\tdesc.value = desc.initializer ? desc.initializer.call(context) : void 0;\n\t\t\tdesc.initializer = undefined;\n\t\t}\n\t\n\t\tif (desc.initializer === void 0) {\n\t\t\tObject['define' + 'Property'](target, property, desc);\n\t\t\tdesc = null;\n\t\t}\n\t\n\t\treturn desc;\n\t}\n\t\n\tvar ESCAPE_KEY = 27;\n\tvar ENTER_KEY = 13;\n\t\n\tvar TodoItem = (_class = function (_Component) {\n\t\t_inherits(TodoItem, _Component);\n\t\n\t\tfunction TodoItem() {\n\t\t\t_classCallCheck(this, TodoItem);\n\t\n\t\t\treturn _possibleConstructorReturn(this, _Component.apply(this, arguments));\n\t\t}\n\t\n\t\tTodoItem.prototype.handleSubmit = function handleSubmit() {\n\t\t\tvar val = this.state.editText.trim();\n\t\t\tif (val) {\n\t\t\t\tthis.props.onSave(val);\n\t\t\t\tthis.setState({ editText: val });\n\t\t\t} else {\n\t\t\t\tthis.props.onDestroy();\n\t\t\t}\n\t\t};\n\t\n\t\tTodoItem.prototype.handleEdit = function handleEdit() {\n\t\t\tthis.props.onEdit();\n\t\t\tthis.setState({ editText: this.props.todo.title });\n\t\t};\n\t\n\t\tTodoItem.prototype.toggle = function toggle(e) {\n\t\t\tthis.props.onToggle();\n\t\t\te.preventDefault();\n\t\t};\n\t\n\t\tTodoItem.prototype.handleKeyDown = function handleKeyDown(e) {\n\t\t\tif (e.which === ESCAPE_KEY) {\n\t\t\t\tthis.setState({ editText: this.props.todo.title });\n\t\t\t\tthis.props.onCancel(e);\n\t\t\t} else if (e.which === ENTER_KEY) {\n\t\t\t\tthis.handleSubmit(e);\n\t\t\t}\n\t\t};\n\t\n\t\t// shouldComponentUpdate({ todo, editing, editText }) {\n\t\t// \treturn (\n\t\t// \t\ttodo !== this.props.todo ||\n\t\t// \t\tediting !== this.props.editing ||\n\t\t// \t\teditText !== this.state.editText\n\t\t// \t);\n\t\t// }\n\t\n\t\tTodoItem.prototype.componentDidUpdate = function componentDidUpdate(_ref) {\n\t\t\tvar editing = _ref.editing;\n\t\n\t\t\tvar node = this.base && this.base.querySelector('.edit');\n\t\t\tif (node) node.focus();\n\t\t};\n\t\n\t\tTodoItem.prototype.render = function render(_ref2, _ref3) {\n\t\t\tvar _ref2$todo = _ref2.todo;\n\t\t\tvar title = _ref2$todo.title;\n\t\t\tvar completed = _ref2$todo.completed;\n\t\t\tvar onToggle = _ref2.onToggle;\n\t\t\tvar onDestroy = _ref2.onDestroy;\n\t\t\tvar editing = _ref2.editing;\n\t\t\tvar editText = _ref3.editText;\n\t\n\t\t\treturn (0, _preact.h)(\n\t\t\t\t'li',\n\t\t\t\t{ 'class': { completed: completed, editing: editing } },\n\t\t\t\t(0, _preact.h)(\n\t\t\t\t\t'div',\n\t\t\t\t\t{ 'class': 'view' },\n\t\t\t\t\t(0, _preact.h)('input', {\n\t\t\t\t\t\t'class': 'toggle',\n\t\t\t\t\t\ttype: 'checkbox',\n\t\t\t\t\t\tchecked: completed || 0,\n\t\t\t\t\t\tonClick: this.toggle\n\t\t\t\t\t}),\n\t\t\t\t\t(0, _preact.h)(\n\t\t\t\t\t\t'label',\n\t\t\t\t\t\t{ onDblClick: this.handleEdit },\n\t\t\t\t\t\ttitle\n\t\t\t\t\t),\n\t\t\t\t\t(0, _preact.h)('button', { 'class': 'destroy', onClick: onDestroy })\n\t\t\t\t),\n\t\t\t\t(0, _preact.h)('input', {\n\t\t\t\t\t'class': 'edit',\n\t\t\t\t\tvalue: editing && editText || title,\n\t\t\t\t\tonBlur: this.handleSubmit,\n\t\t\t\t\tonChange: this.linkState('editText'),\n\t\t\t\t\tonKeyDown: this.handleKeyDown\n\t\t\t\t})\n\t\t\t);\n\t\t};\n\t\n\t\treturn TodoItem;\n\t}(_preact.Component), (_applyDecoratedDescriptor(_class.prototype, 'handleSubmit', [_decko.bind], Object.getOwnPropertyDescriptor(_class.prototype, 'handleSubmit'), _class.prototype), _applyDecoratedDescriptor(_class.prototype, 'handleEdit', [_decko.bind], Object.getOwnPropertyDescriptor(_class.prototype, 'handleEdit'), _class.prototype), _applyDecoratedDescriptor(_class.prototype, 'toggle', [_decko.bind], Object.getOwnPropertyDescriptor(_class.prototype, 'toggle'), _class.prototype), _applyDecoratedDescriptor(_class.prototype, 'handleKeyDown', [_decko.bind], Object.getOwnPropertyDescriptor(_class.prototype, 'handleKeyDown'), _class.prototype)), _class);\n\texports.default = TodoItem;\n\n/***/ },\n/* 11 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\texports.__esModule = true;\n\texports.default = undefined;\n\t\n\tvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\t\n\tvar _util = __webpack_require__(4);\n\t\n\tvar _pouchdb = __webpack_require__(25);\n\t\n\tvar _pouchdb2 = _interopRequireDefault(_pouchdb);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar TodoModel = function () {\n\t  function TodoModel(remoteDBURL) {\n\t    _classCallCheck(this, TodoModel);\n\t\n\t    var self = this;\n\t\n\t    this.remoteDBURL = remoteDBURL;\n\t    this.todos = [];\n\t    this.onChanges = [];\n\t\n\t    // init\n\t    this.localDB = new _pouchdb2.default('todos');\n\t    this.localDB.changes({\n\t      since: 'now',\n\t      live: true\n\t    }).on('change', function () {\n\t      // something change\n\t      console.log('localDB.change');\n\t      self.draw();\n\t      self.syncAndDraw();\n\t    }).on('error', function (err) {\n\t      // totally unhandled error (shouldn't happen)\n\t      console.log('localDB.error : ', err);\n\t    });\n\t\n\t    // draw with localDB\n\t    this.draw();\n\t\n\t    // then sync with remoteDB\n\t    this.remoteDB = new _pouchdb2.default(this.remoteDBURL);\n\t    this.syncAndDraw();\n\t  }\n\t\n\t  TodoModel.prototype.draw = function draw() {\n\t    var self = this;\n\t    this.localDB.allDocs({ include_docs: true, descending: true }, function (err, doc) {\n\t      var next_todos = doc.rows.map(function (todo) {\n\t        return todo.doc;\n\t      });\n\t      // TODO : dirty check\n\t      self.todos = next_todos;\n\t      self.publish();\n\t    });\n\t  };\n\t\n\t  TodoModel.prototype.subscribe = function subscribe(fn) {\n\t    this.onChanges.push(fn);\n\t  };\n\t\n\t  TodoModel.prototype.publish = function publish() {\n\t    this.onChanges.forEach(function (cb) {\n\t      return cb();\n\t    });\n\t  };\n\t\n\t  TodoModel.prototype.syncAndDraw = function syncAndDraw() {\n\t    var self = this;\n\t    // sync with remote\n\t    this.localDB.sync(this.remoteDB).on('change', function () {\n\t      // something change\n\t      console.log('remoteDB.change');\n\t      self.draw();\n\t    }).on('remoteDB.paused', function (info) {\n\t      // replication was paused, usually because of a lost connection\n\t      console.log('remoteDB.paused : ', info);\n\t    }).on('active', function (info) {\n\t      // replication was resumed\n\t      console.log('remoteDB.active : ', info);\n\t    }).on('error', function (err) {\n\t      // totally unhandled error (shouldn't happen)\n\t      console.log('remoteDB.error : ', err);\n\t    });\n\t  };\n\t\n\t  TodoModel.prototype.addTodo = function addTodo(title) {\n\t    var todo = {\n\t      \"_id\": new Date().toISOString(),\n\t      \"title\": title,\n\t      \"completed\": false\n\t    };\n\t\n\t    this.localDB.put(todo, function callback(err, result) {\n\t      if (!err) {\n\t        console.log('Successfully posted a todo!');\n\t      }\n\t    });\n\t  };\n\t\n\t  TodoModel.prototype.toggleAll = function toggleAll(completed) {\n\t    this.todos = this.todos.map(function (todo) {\n\t      return _extends({}, todo, { completed: completed });\n\t    });\n\t    this.publish();\n\t  };\n\t\n\t  TodoModel.prototype.toggle = function toggle(todoToToggle) {\n\t    todoToToggle.completed = !todoToToggle.completed;\n\t    this.localDB.put(todoToToggle);\n\t  };\n\t\n\t  TodoModel.prototype.destroy = function destroy(todo) {\n\t    this.localDB.remove(todo);\n\t  };\n\t\n\t  TodoModel.prototype.save = function save(todoToSave, title) {\n\t    this.localDB.put(todoToSave);\n\t  };\n\t\n\t  TodoModel.prototype.clearCompleted = function clearCompleted() {\n\t    this.completed_todos = this.todos.filter(function (todo) {\n\t      todo.completed ? todo._deleted = true : false;\n\t      return todo.completed;\n\t    });\n\t    this.localDB.bulkDocs(this.completed_todos);\n\t  };\n\t\n\t  return TodoModel;\n\t}();\n\n\texports.default = TodoModel;\n\n/***/ },\n/* 12 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t/**\n\t * This is the web browser implementation of `debug()`.\n\t *\n\t * Expose `debug()` as the module.\n\t */\n\t\n\texports = module.exports = __webpack_require__(13);\n\texports.log = log;\n\texports.formatArgs = formatArgs;\n\texports.save = save;\n\texports.load = load;\n\texports.useColors = useColors;\n\texports.storage = 'undefined' != typeof chrome\n\t               && 'undefined' != typeof chrome.storage\n\t                  ? chrome.storage.local\n\t                  : localstorage();\n\t\n\t/**\n\t * Colors.\n\t */\n\t\n\texports.colors = [\n\t  'lightseagreen',\n\t  'forestgreen',\n\t  'goldenrod',\n\t  'dodgerblue',\n\t  'darkorchid',\n\t  'crimson'\n\t];\n\t\n\t/**\n\t * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n\t * and the Firebug extension (any Firefox version) are known\n\t * to support \"%c\" CSS customizations.\n\t *\n\t * TODO: add a `localStorage` variable to explicitly enable/disable colors\n\t */\n\t\n\tfunction useColors() {\n\t  // is webkit? http://stackoverflow.com/a/16459606/376773\n\t  return ('WebkitAppearance' in document.documentElement.style) ||\n\t    // is firebug? http://stackoverflow.com/a/398120/376773\n\t    (window.console && (console.firebug || (console.exception && console.table))) ||\n\t    // is firefox >= v31?\n\t    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n\t    (navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31);\n\t}\n\t\n\t/**\n\t * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n\t */\n\t\n\texports.formatters.j = function(v) {\n\t  return JSON.stringify(v);\n\t};\n\t\n\t\n\t/**\n\t * Colorize log arguments if enabled.\n\t *\n\t * @api public\n\t */\n\t\n\tfunction formatArgs() {\n\t  var args = arguments;\n\t  var useColors = this.useColors;\n\t\n\t  args[0] = (useColors ? '%c' : '')\n\t    + this.namespace\n\t    + (useColors ? ' %c' : ' ')\n\t    + args[0]\n\t    + (useColors ? '%c ' : ' ')\n\t    + '+' + exports.humanize(this.diff);\n\t\n\t  if (!useColors) return args;\n\t\n\t  var c = 'color: ' + this.color;\n\t  args = [args[0], c, 'color: inherit'].concat(Array.prototype.slice.call(args, 1));\n\t\n\t  // the final \"%c\" is somewhat tricky, because there could be other\n\t  // arguments passed either before or after the %c, so we need to\n\t  // figure out the correct index to insert the CSS into\n\t  var index = 0;\n\t  var lastC = 0;\n\t  args[0].replace(/%[a-z%]/g, function(match) {\n\t    if ('%%' === match) return;\n\t    index++;\n\t    if ('%c' === match) {\n\t      // we only are interested in the *last* %c\n\t      // (the user may have provided their own)\n\t      lastC = index;\n\t    }\n\t  });\n\t\n\t  args.splice(lastC, 0, c);\n\t  return args;\n\t}\n\t\n\t/**\n\t * Invokes `console.log()` when available.\n\t * No-op when `console.log` is not a \"function\".\n\t *\n\t * @api public\n\t */\n\t\n\tfunction log() {\n\t  // this hackery is required for IE8/9, where\n\t  // the `console.log` function doesn't have 'apply'\n\t  return 'object' === typeof console\n\t    && console.log\n\t    && Function.prototype.apply.call(console.log, console, arguments);\n\t}\n\t\n\t/**\n\t * Save `namespaces`.\n\t *\n\t * @param {String} namespaces\n\t * @api private\n\t */\n\t\n\tfunction save(namespaces) {\n\t  try {\n\t    if (null == namespaces) {\n\t      exports.storage.removeItem('debug');\n\t    } else {\n\t      exports.storage.debug = namespaces;\n\t    }\n\t  } catch(e) {}\n\t}\n\t\n\t/**\n\t * Load `namespaces`.\n\t *\n\t * @return {String} returns the previously persisted debug modes\n\t * @api private\n\t */\n\t\n\tfunction load() {\n\t  var r;\n\t  try {\n\t    r = exports.storage.debug;\n\t  } catch(e) {}\n\t  return r;\n\t}\n\t\n\t/**\n\t * Enable namespaces listed in `localStorage.debug` initially.\n\t */\n\t\n\texports.enable(load());\n\t\n\t/**\n\t * Localstorage attempts to return the localstorage.\n\t *\n\t * This is necessary because safari throws\n\t * when a user disables cookies/localstorage\n\t * and you attempt to access it.\n\t *\n\t * @return {LocalStorage}\n\t * @api private\n\t */\n\t\n\tfunction localstorage(){\n\t  try {\n\t    return window.localStorage;\n\t  } catch (e) {}\n\t}\n\n\n/***/ },\n/* 13 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t/**\n\t * This is the common logic for both the Node.js and web browser\n\t * implementations of `debug()`.\n\t *\n\t * Expose `debug()` as the module.\n\t */\n\t\n\texports = module.exports = debug;\n\texports.coerce = coerce;\n\texports.disable = disable;\n\texports.enable = enable;\n\texports.enabled = enabled;\n\texports.humanize = __webpack_require__(21);\n\t\n\t/**\n\t * The currently active debug mode names, and names to skip.\n\t */\n\t\n\texports.names = [];\n\texports.skips = [];\n\t\n\t/**\n\t * Map of special \"%n\" handling functions, for the debug \"format\" argument.\n\t *\n\t * Valid key names are a single, lowercased letter, i.e. \"n\".\n\t */\n\t\n\texports.formatters = {};\n\t\n\t/**\n\t * Previously assigned color.\n\t */\n\t\n\tvar prevColor = 0;\n\t\n\t/**\n\t * Previous log timestamp.\n\t */\n\t\n\tvar prevTime;\n\t\n\t/**\n\t * Select a color.\n\t *\n\t * @return {Number}\n\t * @api private\n\t */\n\t\n\tfunction selectColor() {\n\t  return exports.colors[prevColor++ % exports.colors.length];\n\t}\n\t\n\t/**\n\t * Create a debugger with the given `namespace`.\n\t *\n\t * @param {String} namespace\n\t * @return {Function}\n\t * @api public\n\t */\n\t\n\tfunction debug(namespace) {\n\t\n\t  // define the `disabled` version\n\t  function disabled() {\n\t  }\n\t  disabled.enabled = false;\n\t\n\t  // define the `enabled` version\n\t  function enabled() {\n\t\n\t    var self = enabled;\n\t\n\t    // set `diff` timestamp\n\t    var curr = +new Date();\n\t    var ms = curr - (prevTime || curr);\n\t    self.diff = ms;\n\t    self.prev = prevTime;\n\t    self.curr = curr;\n\t    prevTime = curr;\n\t\n\t    // add the `color` if not set\n\t    if (null == self.useColors) self.useColors = exports.useColors();\n\t    if (null == self.color && self.useColors) self.color = selectColor();\n\t\n\t    var args = Array.prototype.slice.call(arguments);\n\t\n\t    args[0] = exports.coerce(args[0]);\n\t\n\t    if ('string' !== typeof args[0]) {\n\t      // anything else let's inspect with %o\n\t      args = ['%o'].concat(args);\n\t    }\n\t\n\t    // apply any `formatters` transformations\n\t    var index = 0;\n\t    args[0] = args[0].replace(/%([a-z%])/g, function(match, format) {\n\t      // if we encounter an escaped % then don't increase the array index\n\t      if (match === '%%') return match;\n\t      index++;\n\t      var formatter = exports.formatters[format];\n\t      if ('function' === typeof formatter) {\n\t        var val = args[index];\n\t        match = formatter.call(self, val);\n\t\n\t        // now we need to remove `args[index]` since it's inlined in the `format`\n\t        args.splice(index, 1);\n\t        index--;\n\t      }\n\t      return match;\n\t    });\n\t\n\t    if ('function' === typeof exports.formatArgs) {\n\t      args = exports.formatArgs.apply(self, args);\n\t    }\n\t    var logFn = enabled.log || exports.log || console.log.bind(console);\n\t    logFn.apply(self, args);\n\t  }\n\t  enabled.enabled = true;\n\t\n\t  var fn = exports.enabled(namespace) ? enabled : disabled;\n\t\n\t  fn.namespace = namespace;\n\t\n\t  return fn;\n\t}\n\t\n\t/**\n\t * Enables a debug mode by namespaces. This can include modes\n\t * separated by a colon and wildcards.\n\t *\n\t * @param {String} namespaces\n\t * @api public\n\t */\n\t\n\tfunction enable(namespaces) {\n\t  exports.save(namespaces);\n\t\n\t  var split = (namespaces || '').split(/[\\s,]+/);\n\t  var len = split.length;\n\t\n\t  for (var i = 0; i < len; i++) {\n\t    if (!split[i]) continue; // ignore empty strings\n\t    namespaces = split[i].replace(/\\*/g, '.*?');\n\t    if (namespaces[0] === '-') {\n\t      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));\n\t    } else {\n\t      exports.names.push(new RegExp('^' + namespaces + '$'));\n\t    }\n\t  }\n\t}\n\t\n\t/**\n\t * Disable debug output.\n\t *\n\t * @api public\n\t */\n\t\n\tfunction disable() {\n\t  exports.enable('');\n\t}\n\t\n\t/**\n\t * Returns true if the given mode name is enabled, false otherwise.\n\t *\n\t * @param {String} name\n\t * @return {Boolean}\n\t * @api public\n\t */\n\t\n\tfunction enabled(name) {\n\t  var i, len;\n\t  for (i = 0, len = exports.skips.length; i < len; i++) {\n\t    if (exports.skips[i].test(name)) {\n\t      return false;\n\t    }\n\t  }\n\t  for (i = 0, len = exports.names.length; i < len; i++) {\n\t    if (exports.names[i].test(name)) {\n\t      return true;\n\t    }\n\t  }\n\t  return false;\n\t}\n\t\n\t/**\n\t * Coerce `val`.\n\t *\n\t * @param {Mixed} val\n\t * @return {Mixed}\n\t * @api private\n\t */\n\t\n\tfunction coerce(val) {\n\t  if (val instanceof Error) return val.stack || val.message;\n\t  return val;\n\t}\n\n\n/***/ },\n/* 14 */\n/***/ function(module, exports) {\n\n\t// Copyright Joyent, Inc. and other Node contributors.\n\t//\n\t// Permission is hereby granted, free of charge, to any person obtaining a\n\t// copy of this software and associated documentation files (the\n\t// \"Software\"), to deal in the Software without restriction, including\n\t// without limitation the rights to use, copy, modify, merge, publish,\n\t// distribute, sublicense, and/or sell copies of the Software, and to permit\n\t// persons to whom the Software is furnished to do so, subject to the\n\t// following conditions:\n\t//\n\t// The above copyright notice and this permission notice shall be included\n\t// in all copies or substantial portions of the Software.\n\t//\n\t// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n\t// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n\t// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n\t// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n\t// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n\t// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n\t// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\t\n\tfunction EventEmitter() {\n\t  this._events = this._events || {};\n\t  this._maxListeners = this._maxListeners || undefined;\n\t}\n\tmodule.exports = EventEmitter;\n\t\n\t// Backwards-compat with node 0.10.x\n\tEventEmitter.EventEmitter = EventEmitter;\n\t\n\tEventEmitter.prototype._events = undefined;\n\tEventEmitter.prototype._maxListeners = undefined;\n\t\n\t// By default EventEmitters will print a warning if more than 10 listeners are\n\t// added to it. This is a useful default which helps finding memory leaks.\n\tEventEmitter.defaultMaxListeners = 10;\n\t\n\t// Obviously not all Emitters should be limited to 10. This function allows\n\t// that to be increased. Set to zero for unlimited.\n\tEventEmitter.prototype.setMaxListeners = function(n) {\n\t  if (!isNumber(n) || n < 0 || isNaN(n))\n\t    throw TypeError('n must be a positive number');\n\t  this._maxListeners = n;\n\t  return this;\n\t};\n\t\n\tEventEmitter.prototype.emit = function(type) {\n\t  var er, handler, len, args, i, listeners;\n\t\n\t  if (!this._events)\n\t    this._events = {};\n\t\n\t  // If there is no 'error' event listener then throw.\n\t  if (type === 'error') {\n\t    if (!this._events.error ||\n\t        (isObject(this._events.error) && !this._events.error.length)) {\n\t      er = arguments[1];\n\t      if (er instanceof Error) {\n\t        throw er; // Unhandled 'error' event\n\t      }\n\t      throw TypeError('Uncaught, unspecified \"error\" event.');\n\t    }\n\t  }\n\t\n\t  handler = this._events[type];\n\t\n\t  if (isUndefined(handler))\n\t    return false;\n\t\n\t  if (isFunction(handler)) {\n\t    switch (arguments.length) {\n\t      // fast cases\n\t      case 1:\n\t        handler.call(this);\n\t        break;\n\t      case 2:\n\t        handler.call(this, arguments[1]);\n\t        break;\n\t      case 3:\n\t        handler.call(this, arguments[1], arguments[2]);\n\t        break;\n\t      // slower\n\t      default:\n\t        args = Array.prototype.slice.call(arguments, 1);\n\t        handler.apply(this, args);\n\t    }\n\t  } else if (isObject(handler)) {\n\t    args = Array.prototype.slice.call(arguments, 1);\n\t    listeners = handler.slice();\n\t    len = listeners.length;\n\t    for (i = 0; i < len; i++)\n\t      listeners[i].apply(this, args);\n\t  }\n\t\n\t  return true;\n\t};\n\t\n\tEventEmitter.prototype.addListener = function(type, listener) {\n\t  var m;\n\t\n\t  if (!isFunction(listener))\n\t    throw TypeError('listener must be a function');\n\t\n\t  if (!this._events)\n\t    this._events = {};\n\t\n\t  // To avoid recursion in the case that type === \"newListener\"! Before\n\t  // adding it to the listeners, first emit \"newListener\".\n\t  if (this._events.newListener)\n\t    this.emit('newListener', type,\n\t              isFunction(listener.listener) ?\n\t              listener.listener : listener);\n\t\n\t  if (!this._events[type])\n\t    // Optimize the case of one listener. Don't need the extra array object.\n\t    this._events[type] = listener;\n\t  else if (isObject(this._events[type]))\n\t    // If we've already got an array, just append.\n\t    this._events[type].push(listener);\n\t  else\n\t    // Adding the second element, need to change to array.\n\t    this._events[type] = [this._events[type], listener];\n\t\n\t  // Check for listener leak\n\t  if (isObject(this._events[type]) && !this._events[type].warned) {\n\t    if (!isUndefined(this._maxListeners)) {\n\t      m = this._maxListeners;\n\t    } else {\n\t      m = EventEmitter.defaultMaxListeners;\n\t    }\n\t\n\t    if (m && m > 0 && this._events[type].length > m) {\n\t      this._events[type].warned = true;\n\t      console.error('(node) warning: possible EventEmitter memory ' +\n\t                    'leak detected. %d listeners added. ' +\n\t                    'Use emitter.setMaxListeners() to increase limit.',\n\t                    this._events[type].length);\n\t      if (typeof console.trace === 'function') {\n\t        // not supported in IE 10\n\t        console.trace();\n\t      }\n\t    }\n\t  }\n\t\n\t  return this;\n\t};\n\t\n\tEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\t\n\tEventEmitter.prototype.once = function(type, listener) {\n\t  if (!isFunction(listener))\n\t    throw TypeError('listener must be a function');\n\t\n\t  var fired = false;\n\t\n\t  function g() {\n\t    this.removeListener(type, g);\n\t\n\t    if (!fired) {\n\t      fired = true;\n\t      listener.apply(this, arguments);\n\t    }\n\t  }\n\t\n\t  g.listener = listener;\n\t  this.on(type, g);\n\t\n\t  return this;\n\t};\n\t\n\t// emits a 'removeListener' event iff the listener was removed\n\tEventEmitter.prototype.removeListener = function(type, listener) {\n\t  var list, position, length, i;\n\t\n\t  if (!isFunction(listener))\n\t    throw TypeError('listener must be a function');\n\t\n\t  if (!this._events || !this._events[type])\n\t    return this;\n\t\n\t  list = this._events[type];\n\t  length = list.length;\n\t  position = -1;\n\t\n\t  if (list === listener ||\n\t      (isFunction(list.listener) && list.listener === listener)) {\n\t    delete this._events[type];\n\t    if (this._events.removeListener)\n\t      this.emit('removeListener', type, listener);\n\t\n\t  } else if (isObject(list)) {\n\t    for (i = length; i-- > 0;) {\n\t      if (list[i] === listener ||\n\t          (list[i].listener && list[i].listener === listener)) {\n\t        position = i;\n\t        break;\n\t      }\n\t    }\n\t\n\t    if (position < 0)\n\t      return this;\n\t\n\t    if (list.length === 1) {\n\t      list.length = 0;\n\t      delete this._events[type];\n\t    } else {\n\t      list.splice(position, 1);\n\t    }\n\t\n\t    if (this._events.removeListener)\n\t      this.emit('removeListener', type, listener);\n\t  }\n\t\n\t  return this;\n\t};\n\t\n\tEventEmitter.prototype.removeAllListeners = function(type) {\n\t  var key, listeners;\n\t\n\t  if (!this._events)\n\t    return this;\n\t\n\t  // not listening for removeListener, no need to emit\n\t  if (!this._events.removeListener) {\n\t    if (arguments.length === 0)\n\t      this._events = {};\n\t    else if (this._events[type])\n\t      delete this._events[type];\n\t    return this;\n\t  }\n\t\n\t  // emit removeListener for all listeners on all events\n\t  if (arguments.length === 0) {\n\t    for (key in this._events) {\n\t      if (key === 'removeListener') continue;\n\t      this.removeAllListeners(key);\n\t    }\n\t    this.removeAllListeners('removeListener');\n\t    this._events = {};\n\t    return this;\n\t  }\n\t\n\t  listeners = this._events[type];\n\t\n\t  if (isFunction(listeners)) {\n\t    this.removeListener(type, listeners);\n\t  } else if (listeners) {\n\t    // LIFO order\n\t    while (listeners.length)\n\t      this.removeListener(type, listeners[listeners.length - 1]);\n\t  }\n\t  delete this._events[type];\n\t\n\t  return this;\n\t};\n\t\n\tEventEmitter.prototype.listeners = function(type) {\n\t  var ret;\n\t  if (!this._events || !this._events[type])\n\t    ret = [];\n\t  else if (isFunction(this._events[type]))\n\t    ret = [this._events[type]];\n\t  else\n\t    ret = this._events[type].slice();\n\t  return ret;\n\t};\n\t\n\tEventEmitter.prototype.listenerCount = function(type) {\n\t  if (this._events) {\n\t    var evlistener = this._events[type];\n\t\n\t    if (isFunction(evlistener))\n\t      return 1;\n\t    else if (evlistener)\n\t      return evlistener.length;\n\t  }\n\t  return 0;\n\t};\n\t\n\tEventEmitter.listenerCount = function(emitter, type) {\n\t  return emitter.listenerCount(type);\n\t};\n\t\n\tfunction isFunction(arg) {\n\t  return typeof arg === 'function';\n\t}\n\t\n\tfunction isNumber(arg) {\n\t  return typeof arg === 'number';\n\t}\n\t\n\tfunction isObject(arg) {\n\t  return typeof arg === 'object' && arg !== null;\n\t}\n\t\n\tfunction isUndefined(arg) {\n\t  return arg === void 0;\n\t}\n\n\n/***/ },\n/* 15 */\n/***/ function(module, exports) {\n\n\t// removed by extract-text-webpack-plugin\n\n/***/ },\n/* 16 */\n/***/ function(module, exports) {\n\n\t// removed by extract-text-webpack-plugin\n\n/***/ },\n/* 17 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(global, process) {'use strict';\n\tvar Mutation = global.MutationObserver || global.WebKitMutationObserver;\n\t\n\tvar scheduleDrain;\n\t\n\tif (process.browser) {\n\t  if (Mutation) {\n\t    var called = 0;\n\t    var observer = new Mutation(nextTick);\n\t    var element = global.document.createTextNode('');\n\t    observer.observe(element, {\n\t      characterData: true\n\t    });\n\t    scheduleDrain = function () {\n\t      element.data = (called = ++called % 2);\n\t    };\n\t  } else if (!global.setImmediate && typeof global.MessageChannel !== 'undefined') {\n\t    var channel = new global.MessageChannel();\n\t    channel.port1.onmessage = nextTick;\n\t    scheduleDrain = function () {\n\t      channel.port2.postMessage(0);\n\t    };\n\t  } else if ('document' in global && 'onreadystatechange' in global.document.createElement('script')) {\n\t    scheduleDrain = function () {\n\t\n\t      // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n\t      // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.\n\t      var scriptEl = global.document.createElement('script');\n\t      scriptEl.onreadystatechange = function () {\n\t        nextTick();\n\t\n\t        scriptEl.onreadystatechange = null;\n\t        scriptEl.parentNode.removeChild(scriptEl);\n\t        scriptEl = null;\n\t      };\n\t      global.document.documentElement.appendChild(scriptEl);\n\t    };\n\t  } else {\n\t    scheduleDrain = function () {\n\t      setTimeout(nextTick, 0);\n\t    };\n\t  }\n\t} else {\n\t  scheduleDrain = function () {\n\t    process.nextTick(nextTick);\n\t  };\n\t}\n\t\n\tvar draining;\n\tvar queue = [];\n\t//named nextTick for less confusing stack traces\n\tfunction nextTick() {\n\t  draining = true;\n\t  var i, oldQueue;\n\t  var len = queue.length;\n\t  while (len) {\n\t    oldQueue = queue;\n\t    queue = [];\n\t    i = -1;\n\t    while (++i < len) {\n\t      oldQueue[i]();\n\t    }\n\t    len = queue.length;\n\t  }\n\t  draining = false;\n\t}\n\t\n\tmodule.exports = immediate;\n\tfunction immediate(task) {\n\t  if (queue.push(task) === 1 && !draining) {\n\t    scheduleDrain();\n\t  }\n\t}\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(2)))\n\n/***/ },\n/* 18 */\n/***/ function(module, exports) {\n\n\tif (typeof Object.create === 'function') {\n\t  // implementation from standard node.js 'util' module\n\t  module.exports = function inherits(ctor, superCtor) {\n\t    ctor.super_ = superCtor\n\t    ctor.prototype = Object.create(superCtor.prototype, {\n\t      constructor: {\n\t        value: ctor,\n\t        enumerable: false,\n\t        writable: true,\n\t        configurable: true\n\t      }\n\t    });\n\t  };\n\t} else {\n\t  // old school shim for old browsers\n\t  module.exports = function inherits(ctor, superCtor) {\n\t    ctor.super_ = superCtor\n\t    var TempCtor = function () {}\n\t    TempCtor.prototype = superCtor.prototype\n\t    ctor.prototype = new TempCtor()\n\t    ctor.prototype.constructor = ctor\n\t  }\n\t}\n\n\n/***/ },\n/* 19 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t(function(factory) {\n\t  if(true) {\n\t    factory(exports);\n\t  } else {\n\t    factory(this);\n\t  }\n\t}).call(this, function(root) { \n\t\n\t  var slice   = Array.prototype.slice,\n\t      each    = Array.prototype.forEach;\n\t\n\t  var extend = function(obj) {\n\t    if(typeof obj !== 'object') throw obj + ' is not an object' ;\n\t\n\t    var sources = slice.call(arguments, 1); \n\t\n\t    each.call(sources, function(source) {\n\t      if(source) {\n\t        for(var prop in source) {\n\t          if(typeof source[prop] === 'object' && obj[prop]) {\n\t            extend.call(obj, obj[prop], source[prop]);\n\t          } else {\n\t            obj[prop] = source[prop];\n\t          }\n\t        } \n\t      }\n\t    });\n\t\n\t    return obj;\n\t  }\n\t\n\t  root.extend = extend;\n\t});\n\n\n/***/ },\n/* 20 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(process) {'use strict';\n\tvar immediate = __webpack_require__(17);\n\t\n\t/* istanbul ignore next */\n\tfunction INTERNAL() {}\n\t\n\tvar handlers = {};\n\t\n\tvar REJECTED = ['REJECTED'];\n\tvar FULFILLED = ['FULFILLED'];\n\tvar PENDING = ['PENDING'];\n\t/* istanbul ignore else */\n\tif (!process.browser) {\n\t  // in which we actually take advantage of JS scoping\n\t  var UNHANDLED = ['UNHANDLED'];\n\t}\n\t\n\tmodule.exports = exports = Promise;\n\t\n\tfunction Promise(resolver) {\n\t  if (typeof resolver !== 'function') {\n\t    throw new TypeError('resolver must be a function');\n\t  }\n\t  this.state = PENDING;\n\t  this.queue = [];\n\t  this.outcome = void 0;\n\t  /* istanbul ignore else */\n\t  if (!process.browser) {\n\t    this.handled = UNHANDLED;\n\t  }\n\t  if (resolver !== INTERNAL) {\n\t    safelyResolveThenable(this, resolver);\n\t  }\n\t}\n\t\n\tPromise.prototype.catch = function (onRejected) {\n\t  return this.then(null, onRejected);\n\t};\n\tPromise.prototype.then = function (onFulfilled, onRejected) {\n\t  if (typeof onFulfilled !== 'function' && this.state === FULFILLED ||\n\t    typeof onRejected !== 'function' && this.state === REJECTED) {\n\t    return this;\n\t  }\n\t  var promise = new this.constructor(INTERNAL);\n\t  /* istanbul ignore else */\n\t  if (!process.browser) {\n\t    if (this.handled === UNHANDLED) {\n\t      this.handled = null;\n\t    }\n\t  }\n\t  if (this.state !== PENDING) {\n\t    var resolver = this.state === FULFILLED ? onFulfilled : onRejected;\n\t    unwrap(promise, resolver, this.outcome);\n\t  } else {\n\t    this.queue.push(new QueueItem(promise, onFulfilled, onRejected));\n\t  }\n\t\n\t  return promise;\n\t};\n\tfunction QueueItem(promise, onFulfilled, onRejected) {\n\t  this.promise = promise;\n\t  if (typeof onFulfilled === 'function') {\n\t    this.onFulfilled = onFulfilled;\n\t    this.callFulfilled = this.otherCallFulfilled;\n\t  }\n\t  if (typeof onRejected === 'function') {\n\t    this.onRejected = onRejected;\n\t    this.callRejected = this.otherCallRejected;\n\t  }\n\t}\n\tQueueItem.prototype.callFulfilled = function (value) {\n\t  handlers.resolve(this.promise, value);\n\t};\n\tQueueItem.prototype.otherCallFulfilled = function (value) {\n\t  unwrap(this.promise, this.onFulfilled, value);\n\t};\n\tQueueItem.prototype.callRejected = function (value) {\n\t  handlers.reject(this.promise, value);\n\t};\n\tQueueItem.prototype.otherCallRejected = function (value) {\n\t  unwrap(this.promise, this.onRejected, value);\n\t};\n\t\n\tfunction unwrap(promise, func, value) {\n\t  immediate(function () {\n\t    var returnValue;\n\t    try {\n\t      returnValue = func(value);\n\t    } catch (e) {\n\t      return handlers.reject(promise, e);\n\t    }\n\t    if (returnValue === promise) {\n\t      handlers.reject(promise, new TypeError('Cannot resolve promise with itself'));\n\t    } else {\n\t      handlers.resolve(promise, returnValue);\n\t    }\n\t  });\n\t}\n\t\n\thandlers.resolve = function (self, value) {\n\t  var result = tryCatch(getThen, value);\n\t  if (result.status === 'error') {\n\t    return handlers.reject(self, result.value);\n\t  }\n\t  var thenable = result.value;\n\t\n\t  if (thenable) {\n\t    safelyResolveThenable(self, thenable);\n\t  } else {\n\t    self.state = FULFILLED;\n\t    self.outcome = value;\n\t    var i = -1;\n\t    var len = self.queue.length;\n\t    while (++i < len) {\n\t      self.queue[i].callFulfilled(value);\n\t    }\n\t  }\n\t  return self;\n\t};\n\thandlers.reject = function (self, error) {\n\t  self.state = REJECTED;\n\t  self.outcome = error;\n\t  /* istanbul ignore else */\n\t  if (!process.browser) {\n\t    if (self.handled === UNHANDLED) {\n\t      immediate(function () {\n\t        if (self.handled === UNHANDLED) {\n\t          process.emit('unhandledRejection', error, self);\n\t        }\n\t      });\n\t    }\n\t  }\n\t  var i = -1;\n\t  var len = self.queue.length;\n\t  while (++i < len) {\n\t    self.queue[i].callRejected(error);\n\t  }\n\t  return self;\n\t};\n\t\n\tfunction getThen(obj) {\n\t  // Make sure we only access the accessor once as required by the spec\n\t  var then = obj && obj.then;\n\t  if (obj && typeof obj === 'object' && typeof then === 'function') {\n\t    return function appyThen() {\n\t      then.apply(obj, arguments);\n\t    };\n\t  }\n\t}\n\t\n\tfunction safelyResolveThenable(self, thenable) {\n\t  // Either fulfill, reject or reject with error\n\t  var called = false;\n\t  function onError(value) {\n\t    if (called) {\n\t      return;\n\t    }\n\t    called = true;\n\t    handlers.reject(self, value);\n\t  }\n\t\n\t  function onSuccess(value) {\n\t    if (called) {\n\t      return;\n\t    }\n\t    called = true;\n\t    handlers.resolve(self, value);\n\t  }\n\t\n\t  function tryToUnwrap() {\n\t    thenable(onSuccess, onError);\n\t  }\n\t\n\t  var result = tryCatch(tryToUnwrap);\n\t  if (result.status === 'error') {\n\t    onError(result.value);\n\t  }\n\t}\n\t\n\tfunction tryCatch(func, value) {\n\t  var out = {};\n\t  try {\n\t    out.value = func(value);\n\t    out.status = 'success';\n\t  } catch (e) {\n\t    out.status = 'error';\n\t    out.value = e;\n\t  }\n\t  return out;\n\t}\n\t\n\texports.resolve = resolve;\n\tfunction resolve(value) {\n\t  if (value instanceof this) {\n\t    return value;\n\t  }\n\t  return handlers.resolve(new this(INTERNAL), value);\n\t}\n\t\n\texports.reject = reject;\n\tfunction reject(reason) {\n\t  var promise = new this(INTERNAL);\n\t  return handlers.reject(promise, reason);\n\t}\n\t\n\texports.all = all;\n\tfunction all(iterable) {\n\t  var self = this;\n\t  if (Object.prototype.toString.call(iterable) !== '[object Array]') {\n\t    return this.reject(new TypeError('must be an array'));\n\t  }\n\t\n\t  var len = iterable.length;\n\t  var called = false;\n\t  if (!len) {\n\t    return this.resolve([]);\n\t  }\n\t\n\t  var values = new Array(len);\n\t  var resolved = 0;\n\t  var i = -1;\n\t  var promise = new this(INTERNAL);\n\t\n\t  while (++i < len) {\n\t    allResolver(iterable[i], i);\n\t  }\n\t  return promise;\n\t  function allResolver(value, i) {\n\t    self.resolve(value).then(resolveFromAll, function (error) {\n\t      if (!called) {\n\t        called = true;\n\t        handlers.reject(promise, error);\n\t      }\n\t    });\n\t    function resolveFromAll(outValue) {\n\t      values[i] = outValue;\n\t      if (++resolved === len && !called) {\n\t        called = true;\n\t        handlers.resolve(promise, values);\n\t      }\n\t    }\n\t  }\n\t}\n\t\n\texports.race = race;\n\tfunction race(iterable) {\n\t  var self = this;\n\t  if (Object.prototype.toString.call(iterable) !== '[object Array]') {\n\t    return this.reject(new TypeError('must be an array'));\n\t  }\n\t\n\t  var len = iterable.length;\n\t  var called = false;\n\t  if (!len) {\n\t    return this.resolve([]);\n\t  }\n\t\n\t  var i = -1;\n\t  var promise = new this(INTERNAL);\n\t\n\t  while (++i < len) {\n\t    resolver(iterable[i]);\n\t  }\n\t  return promise;\n\t  function resolver(value) {\n\t    self.resolve(value).then(function (response) {\n\t      if (!called) {\n\t        called = true;\n\t        handlers.resolve(promise, response);\n\t      }\n\t    }, function (error) {\n\t      if (!called) {\n\t        called = true;\n\t        handlers.reject(promise, error);\n\t      }\n\t    });\n\t  }\n\t}\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2)))\n\n/***/ },\n/* 21 */\n/***/ function(module, exports) {\n\n\t/**\n\t * Helpers.\n\t */\n\t\n\tvar s = 1000;\n\tvar m = s * 60;\n\tvar h = m * 60;\n\tvar d = h * 24;\n\tvar y = d * 365.25;\n\t\n\t/**\n\t * Parse or format the given `val`.\n\t *\n\t * Options:\n\t *\n\t *  - `long` verbose formatting [false]\n\t *\n\t * @param {String|Number} val\n\t * @param {Object} options\n\t * @return {String|Number}\n\t * @api public\n\t */\n\t\n\tmodule.exports = function(val, options){\n\t  options = options || {};\n\t  if ('string' == typeof val) return parse(val);\n\t  return options.long\n\t    ? long(val)\n\t    : short(val);\n\t};\n\t\n\t/**\n\t * Parse the given `str` and return milliseconds.\n\t *\n\t * @param {String} str\n\t * @return {Number}\n\t * @api private\n\t */\n\t\n\tfunction parse(str) {\n\t  str = '' + str;\n\t  if (str.length > 10000) return;\n\t  var match = /^((?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);\n\t  if (!match) return;\n\t  var n = parseFloat(match[1]);\n\t  var type = (match[2] || 'ms').toLowerCase();\n\t  switch (type) {\n\t    case 'years':\n\t    case 'year':\n\t    case 'yrs':\n\t    case 'yr':\n\t    case 'y':\n\t      return n * y;\n\t    case 'days':\n\t    case 'day':\n\t    case 'd':\n\t      return n * d;\n\t    case 'hours':\n\t    case 'hour':\n\t    case 'hrs':\n\t    case 'hr':\n\t    case 'h':\n\t      return n * h;\n\t    case 'minutes':\n\t    case 'minute':\n\t    case 'mins':\n\t    case 'min':\n\t    case 'm':\n\t      return n * m;\n\t    case 'seconds':\n\t    case 'second':\n\t    case 'secs':\n\t    case 'sec':\n\t    case 's':\n\t      return n * s;\n\t    case 'milliseconds':\n\t    case 'millisecond':\n\t    case 'msecs':\n\t    case 'msec':\n\t    case 'ms':\n\t      return n;\n\t  }\n\t}\n\t\n\t/**\n\t * Short format for `ms`.\n\t *\n\t * @param {Number} ms\n\t * @return {String}\n\t * @api private\n\t */\n\t\n\tfunction short(ms) {\n\t  if (ms >= d) return Math.round(ms / d) + 'd';\n\t  if (ms >= h) return Math.round(ms / h) + 'h';\n\t  if (ms >= m) return Math.round(ms / m) + 'm';\n\t  if (ms >= s) return Math.round(ms / s) + 's';\n\t  return ms + 'ms';\n\t}\n\t\n\t/**\n\t * Long format for `ms`.\n\t *\n\t * @param {Number} ms\n\t * @return {String}\n\t * @api private\n\t */\n\t\n\tfunction long(ms) {\n\t  return plural(ms, d, 'day')\n\t    || plural(ms, h, 'hour')\n\t    || plural(ms, m, 'minute')\n\t    || plural(ms, s, 'second')\n\t    || ms + ' ms';\n\t}\n\t\n\t/**\n\t * Pluralization helper.\n\t */\n\t\n\tfunction plural(ms, n, name) {\n\t  if (ms < n) return;\n\t  if (ms < n * 1.5) return Math.floor(ms / n) + ' ' + name;\n\t  return Math.ceil(ms / n) + ' ' + name + 's';\n\t}\n\n\n/***/ },\n/* 22 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar MIN_MAGNITUDE = -324; // verified by -Number.MIN_VALUE\n\tvar MAGNITUDE_DIGITS = 3; // ditto\n\tvar SEP = ''; // set to '_' for easier debugging \n\t\n\tvar utils = __webpack_require__(23);\n\t\n\texports.collate = function (a, b) {\n\t\n\t  if (a === b) {\n\t    return 0;\n\t  }\n\t\n\t  a = exports.normalizeKey(a);\n\t  b = exports.normalizeKey(b);\n\t\n\t  var ai = collationIndex(a);\n\t  var bi = collationIndex(b);\n\t  if ((ai - bi) !== 0) {\n\t    return ai - bi;\n\t  }\n\t  if (a === null) {\n\t    return 0;\n\t  }\n\t  switch (typeof a) {\n\t    case 'number':\n\t      return a - b;\n\t    case 'boolean':\n\t      return a === b ? 0 : (a < b ? -1 : 1);\n\t    case 'string':\n\t      return stringCollate(a, b);\n\t  }\n\t  return Array.isArray(a) ? arrayCollate(a, b) : objectCollate(a, b);\n\t};\n\t\n\t// couch considers null/NaN/Infinity/-Infinity === undefined,\n\t// for the purposes of mapreduce indexes. also, dates get stringified.\n\texports.normalizeKey = function (key) {\n\t  switch (typeof key) {\n\t    case 'undefined':\n\t      return null;\n\t    case 'number':\n\t      if (key === Infinity || key === -Infinity || isNaN(key)) {\n\t        return null;\n\t      }\n\t      return key;\n\t    case 'object':\n\t      var origKey = key;\n\t      if (Array.isArray(key)) {\n\t        var len = key.length;\n\t        key = new Array(len);\n\t        for (var i = 0; i < len; i++) {\n\t          key[i] = exports.normalizeKey(origKey[i]);\n\t        }\n\t      } else if (key instanceof Date) {\n\t        return key.toJSON();\n\t      } else if (key !== null) { // generic object\n\t        key = {};\n\t        for (var k in origKey) {\n\t          if (origKey.hasOwnProperty(k)) {\n\t            var val = origKey[k];\n\t            if (typeof val !== 'undefined') {\n\t              key[k] = exports.normalizeKey(val);\n\t            }\n\t          }\n\t        }\n\t      }\n\t  }\n\t  return key;\n\t};\n\t\n\tfunction indexify(key) {\n\t  if (key !== null) {\n\t    switch (typeof key) {\n\t      case 'boolean':\n\t        return key ? 1 : 0;\n\t      case 'number':\n\t        return numToIndexableString(key);\n\t      case 'string':\n\t        // We've to be sure that key does not contain \\u0000\n\t        // Do order-preserving replacements:\n\t        // 0 -> 1, 1\n\t        // 1 -> 1, 2\n\t        // 2 -> 2, 2\n\t        return key\n\t          .replace(/\\u0002/g, '\\u0002\\u0002')\n\t          .replace(/\\u0001/g, '\\u0001\\u0002')\n\t          .replace(/\\u0000/g, '\\u0001\\u0001');\n\t      case 'object':\n\t        var isArray = Array.isArray(key);\n\t        var arr = isArray ? key : Object.keys(key);\n\t        var i = -1;\n\t        var len = arr.length;\n\t        var result = '';\n\t        if (isArray) {\n\t          while (++i < len) {\n\t            result += exports.toIndexableString(arr[i]);\n\t          }\n\t        } else {\n\t          while (++i < len) {\n\t            var objKey = arr[i];\n\t            result += exports.toIndexableString(objKey) +\n\t                exports.toIndexableString(key[objKey]);\n\t          }\n\t        }\n\t        return result;\n\t    }\n\t  }\n\t  return '';\n\t}\n\t\n\t// convert the given key to a string that would be appropriate\n\t// for lexical sorting, e.g. within a database, where the\n\t// sorting is the same given by the collate() function.\n\texports.toIndexableString = function (key) {\n\t  var zero = '\\u0000';\n\t  key = exports.normalizeKey(key);\n\t  return collationIndex(key) + SEP + indexify(key) + zero;\n\t};\n\t\n\tfunction parseNumber(str, i) {\n\t  var originalIdx = i;\n\t  var num;\n\t  var zero = str[i] === '1';\n\t  if (zero) {\n\t    num = 0;\n\t    i++;\n\t  } else {\n\t    var neg = str[i] === '0';\n\t    i++;\n\t    var numAsString = '';\n\t    var magAsString = str.substring(i, i + MAGNITUDE_DIGITS);\n\t    var magnitude = parseInt(magAsString, 10) + MIN_MAGNITUDE;\n\t    if (neg) {\n\t      magnitude = -magnitude;\n\t    }\n\t    i += MAGNITUDE_DIGITS;\n\t    while (true) {\n\t      var ch = str[i];\n\t      if (ch === '\\u0000') {\n\t        break;\n\t      } else {\n\t        numAsString += ch;\n\t      }\n\t      i++;\n\t    }\n\t    numAsString = numAsString.split('.');\n\t    if (numAsString.length === 1) {\n\t      num = parseInt(numAsString, 10);\n\t    } else {\n\t      num = parseFloat(numAsString[0] + '.' + numAsString[1]);\n\t    }\n\t    if (neg) {\n\t      num = num - 10;\n\t    }\n\t    if (magnitude !== 0) {\n\t      // parseFloat is more reliable than pow due to rounding errors\n\t      // e.g. Number.MAX_VALUE would return Infinity if we did\n\t      // num * Math.pow(10, magnitude);\n\t      num = parseFloat(num + 'e' + magnitude);\n\t    }\n\t  }\n\t  return {num: num, length : i - originalIdx};\n\t}\n\t\n\t// move up the stack while parsing\n\t// this function moved outside of parseIndexableString for performance\n\tfunction pop(stack, metaStack) {\n\t  var obj = stack.pop();\n\t\n\t  if (metaStack.length) {\n\t    var lastMetaElement = metaStack[metaStack.length - 1];\n\t    if (obj === lastMetaElement.element) {\n\t      // popping a meta-element, e.g. an object whose value is another object\n\t      metaStack.pop();\n\t      lastMetaElement = metaStack[metaStack.length - 1];\n\t    }\n\t    var element = lastMetaElement.element;\n\t    var lastElementIndex = lastMetaElement.index;\n\t    if (Array.isArray(element)) {\n\t      element.push(obj);\n\t    } else if (lastElementIndex === stack.length - 2) { // obj with key+value\n\t      var key = stack.pop();\n\t      element[key] = obj;\n\t    } else {\n\t      stack.push(obj); // obj with key only\n\t    }\n\t  }\n\t}\n\t\n\texports.parseIndexableString = function (str) {\n\t  var stack = [];\n\t  var metaStack = []; // stack for arrays and objects\n\t  var i = 0;\n\t\n\t  while (true) {\n\t    var collationIndex = str[i++];\n\t    if (collationIndex === '\\u0000') {\n\t      if (stack.length === 1) {\n\t        return stack.pop();\n\t      } else {\n\t        pop(stack, metaStack);\n\t        continue;\n\t      }\n\t    }\n\t    switch (collationIndex) {\n\t      case '1':\n\t        stack.push(null);\n\t        break;\n\t      case '2':\n\t        stack.push(str[i] === '1');\n\t        i++;\n\t        break;\n\t      case '3':\n\t        var parsedNum = parseNumber(str, i);\n\t        stack.push(parsedNum.num);\n\t        i += parsedNum.length;\n\t        break;\n\t      case '4':\n\t        var parsedStr = '';\n\t        while (true) {\n\t          var ch = str[i];\n\t          if (ch === '\\u0000') {\n\t            break;\n\t          }\n\t          parsedStr += ch;\n\t          i++;\n\t        }\n\t        // perform the reverse of the order-preserving replacement\n\t        // algorithm (see above)\n\t        parsedStr = parsedStr.replace(/\\u0001\\u0001/g, '\\u0000')\n\t          .replace(/\\u0001\\u0002/g, '\\u0001')\n\t          .replace(/\\u0002\\u0002/g, '\\u0002');\n\t        stack.push(parsedStr);\n\t        break;\n\t      case '5':\n\t        var arrayElement = { element: [], index: stack.length };\n\t        stack.push(arrayElement.element);\n\t        metaStack.push(arrayElement);\n\t        break;\n\t      case '6':\n\t        var objElement = { element: {}, index: stack.length };\n\t        stack.push(objElement.element);\n\t        metaStack.push(objElement);\n\t        break;\n\t      default:\n\t        throw new Error(\n\t          'bad collationIndex or unexpectedly reached end of input: ' + collationIndex);\n\t    }\n\t  }\n\t};\n\t\n\tfunction arrayCollate(a, b) {\n\t  var len = Math.min(a.length, b.length);\n\t  for (var i = 0; i < len; i++) {\n\t    var sort = exports.collate(a[i], b[i]);\n\t    if (sort !== 0) {\n\t      return sort;\n\t    }\n\t  }\n\t  return (a.length === b.length) ? 0 :\n\t    (a.length > b.length) ? 1 : -1;\n\t}\n\tfunction stringCollate(a, b) {\n\t  // See: https://github.com/daleharvey/pouchdb/issues/40\n\t  // This is incompatible with the CouchDB implementation, but its the\n\t  // best we can do for now\n\t  return (a === b) ? 0 : ((a > b) ? 1 : -1);\n\t}\n\tfunction objectCollate(a, b) {\n\t  var ak = Object.keys(a), bk = Object.keys(b);\n\t  var len = Math.min(ak.length, bk.length);\n\t  for (var i = 0; i < len; i++) {\n\t    // First sort the keys\n\t    var sort = exports.collate(ak[i], bk[i]);\n\t    if (sort !== 0) {\n\t      return sort;\n\t    }\n\t    // if the keys are equal sort the values\n\t    sort = exports.collate(a[ak[i]], b[bk[i]]);\n\t    if (sort !== 0) {\n\t      return sort;\n\t    }\n\t\n\t  }\n\t  return (ak.length === bk.length) ? 0 :\n\t    (ak.length > bk.length) ? 1 : -1;\n\t}\n\t// The collation is defined by erlangs ordered terms\n\t// the atoms null, true, false come first, then numbers, strings,\n\t// arrays, then objects\n\t// null/undefined/NaN/Infinity/-Infinity are all considered null\n\tfunction collationIndex(x) {\n\t  var id = ['boolean', 'number', 'string', 'object'];\n\t  var idx = id.indexOf(typeof x);\n\t  //false if -1 otherwise true, but fast!!!!1\n\t  if (~idx) {\n\t    if (x === null) {\n\t      return 1;\n\t    }\n\t    if (Array.isArray(x)) {\n\t      return 5;\n\t    }\n\t    return idx < 3 ? (idx + 2) : (idx + 3);\n\t  }\n\t  if (Array.isArray(x)) {\n\t    return 5;\n\t  }\n\t}\n\t\n\t// conversion:\n\t// x yyy zz...zz\n\t// x = 0 for negative, 1 for 0, 2 for positive\n\t// y = exponent (for negative numbers negated) moved so that it's >= 0\n\t// z = mantisse\n\tfunction numToIndexableString(num) {\n\t\n\t  if (num === 0) {\n\t    return '1';\n\t  }\n\t\n\t  // convert number to exponential format for easier and\n\t  // more succinct string sorting\n\t  var expFormat = num.toExponential().split(/e\\+?/);\n\t  var magnitude = parseInt(expFormat[1], 10);\n\t\n\t  var neg = num < 0;\n\t\n\t  var result = neg ? '0' : '2';\n\t\n\t  // first sort by magnitude\n\t  // it's easier if all magnitudes are positive\n\t  var magForComparison = ((neg ? -magnitude : magnitude) - MIN_MAGNITUDE);\n\t  var magString = utils.padLeft((magForComparison).toString(), '0', MAGNITUDE_DIGITS);\n\t\n\t  result += SEP + magString;\n\t\n\t  // then sort by the factor\n\t  var factor = Math.abs(parseFloat(expFormat[0])); // [1..10)\n\t  if (neg) { // for negative reverse ordering\n\t    factor = 10 - factor;\n\t  }\n\t\n\t  var factorStr = factor.toFixed(20);\n\t\n\t  // strip zeros from the end\n\t  factorStr = factorStr.replace(/\\.?0+$/, '');\n\t\n\t  result += SEP + factorStr;\n\t\n\t  return result;\n\t}\n\n\n/***/ },\n/* 23 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tfunction pad(str, padWith, upToLength) {\n\t  var padding = '';\n\t  var targetLength = upToLength - str.length;\n\t  while (padding.length < targetLength) {\n\t    padding += padWith;\n\t  }\n\t  return padding;\n\t}\n\t\n\texports.padLeft = function (str, padWith, upToLength) {\n\t  var padding = pad(str, padWith, upToLength);\n\t  return padding + str;\n\t};\n\t\n\texports.padRight = function (str, padWith, upToLength) {\n\t  var padding = pad(str, padWith, upToLength);\n\t  return str + padding;\n\t};\n\t\n\texports.stringLexCompare = function (a, b) {\n\t\n\t  var aLen = a.length;\n\t  var bLen = b.length;\n\t\n\t  var i;\n\t  for (i = 0; i < aLen; i++) {\n\t    if (i === bLen) {\n\t      // b is shorter substring of a\n\t      return 1;\n\t    }\n\t    var aChar = a.charAt(i);\n\t    var bChar = b.charAt(i);\n\t    if (aChar !== bChar) {\n\t      return aChar < bChar ? -1 : 1;\n\t    }\n\t  }\n\t\n\t  if (aLen < bLen) {\n\t    // a is shorter substring of b\n\t    return -1;\n\t  }\n\t\n\t  return 0;\n\t};\n\t\n\t/*\n\t * returns the decimal form for the given integer, i.e. writes\n\t * out all the digits (in base-10) instead of using scientific notation\n\t */\n\texports.intToDecimalForm = function (int) {\n\t\n\t  var isNeg = int < 0;\n\t  var result = '';\n\t\n\t  do {\n\t    var remainder = isNeg ? -Math.ceil(int % 10) : Math.floor(int % 10);\n\t\n\t    result = remainder + result;\n\t    int = isNeg ? Math.ceil(int / 10) : Math.floor(int / 10);\n\t  } while (int);\n\t\n\t\n\t  if (isNeg && result !== '0') {\n\t    result = '-' + result;\n\t  }\n\t\n\t  return result;\n\t};\n\n/***/ },\n/* 24 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\texports.Map = LazyMap; // TODO: use ES6 map\n\texports.Set = LazySet; // TODO: use ES6 set\n\t// based on https://github.com/montagejs/collections\n\tfunction LazyMap() {\n\t  this.store = {};\n\t}\n\tLazyMap.prototype.mangle = function (key) {\n\t  if (typeof key !== \"string\") {\n\t    throw new TypeError(\"key must be a string but Got \" + key);\n\t  }\n\t  return '$' + key;\n\t};\n\tLazyMap.prototype.unmangle = function (key) {\n\t  return key.substring(1);\n\t};\n\tLazyMap.prototype.get = function (key) {\n\t  var mangled = this.mangle(key);\n\t  if (mangled in this.store) {\n\t    return this.store[mangled];\n\t  }\n\t  return void 0;\n\t};\n\tLazyMap.prototype.set = function (key, value) {\n\t  var mangled = this.mangle(key);\n\t  this.store[mangled] = value;\n\t  return true;\n\t};\n\tLazyMap.prototype.has = function (key) {\n\t  var mangled = this.mangle(key);\n\t  return mangled in this.store;\n\t};\n\tLazyMap.prototype.delete = function (key) {\n\t  var mangled = this.mangle(key);\n\t  if (mangled in this.store) {\n\t    delete this.store[mangled];\n\t    return true;\n\t  }\n\t  return false;\n\t};\n\tLazyMap.prototype.forEach = function (cb) {\n\t  var keys = Object.keys(this.store);\n\t  for (var i = 0, len = keys.length; i < len; i++) {\n\t    var key = keys[i];\n\t    var value = this.store[key];\n\t    key = this.unmangle(key);\n\t    cb(value, key);\n\t  }\n\t};\n\t\n\tfunction LazySet(array) {\n\t  this.store = new LazyMap();\n\t\n\t  // init with an array\n\t  if (array && Array.isArray(array)) {\n\t    for (var i = 0, len = array.length; i < len; i++) {\n\t      this.add(array[i]);\n\t    }\n\t  }\n\t}\n\tLazySet.prototype.add = function (key) {\n\t  return this.store.set(key, true);\n\t};\n\tLazySet.prototype.has = function (key) {\n\t  return this.store.has(key);\n\t};\n\tLazySet.prototype.delete = function (key) {\n\t  return this.store.delete(key);\n\t};\n\n\n/***/ },\n/* 25 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(process, global) {'use strict';\n\t\n\tfunction _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }\n\t\n\tvar jsExtend = __webpack_require__(19);\n\tvar jsExtend__default = _interopDefault(jsExtend);\n\tvar debug = _interopDefault(__webpack_require__(12));\n\tvar inherits = _interopDefault(__webpack_require__(18));\n\tvar lie = _interopDefault(__webpack_require__(20));\n\tvar pouchdbCollections = __webpack_require__(24);\n\tvar getArguments = _interopDefault(__webpack_require__(7));\n\tvar events = __webpack_require__(14);\n\tvar scopedEval = _interopDefault(__webpack_require__(26));\n\tvar pouchCollate = __webpack_require__(22);\n\tvar pouchCollate__default = _interopDefault(pouchCollate);\n\tvar Md5 = _interopDefault(__webpack_require__(27));\n\tvar vuvuzela = _interopDefault(__webpack_require__(29));\n\t\n\t/* istanbul ignore next */\n\tvar PouchPromise = typeof Promise === 'function' ? Promise : lie;\n\t\n\t// like underscore/lodash _.pick()\n\tfunction pick(obj, arr) {\n\t  var res = {};\n\t  for (var i = 0, len = arr.length; i < len; i++) {\n\t    var prop = arr[i];\n\t    if (prop in obj) {\n\t      res[prop] = obj[prop];\n\t    }\n\t  }\n\t  return res;\n\t}\n\t\n\tfunction isBinaryObject(object) {\n\t  return object instanceof ArrayBuffer ||\n\t    (typeof Blob !== 'undefined' && object instanceof Blob);\n\t}\n\t\n\tfunction cloneArrayBuffer(buff) {\n\t  if (typeof buff.slice === 'function') {\n\t    return buff.slice(0);\n\t  }\n\t  // IE10-11 slice() polyfill\n\t  var target = new ArrayBuffer(buff.byteLength);\n\t  var targetArray = new Uint8Array(target);\n\t  var sourceArray = new Uint8Array(buff);\n\t  targetArray.set(sourceArray);\n\t  return target;\n\t}\n\t\n\tfunction cloneBinaryObject(object) {\n\t  if (object instanceof ArrayBuffer) {\n\t    return cloneArrayBuffer(object);\n\t  }\n\t  var size = object.size;\n\t  var type = object.type;\n\t  // Blob\n\t  if (typeof object.slice === 'function') {\n\t    return object.slice(0, size, type);\n\t  }\n\t  // PhantomJS slice() replacement\n\t  return object.webkitSlice(0, size, type);\n\t}\n\t\n\tfunction clone(object) {\n\t  var newObject;\n\t  var i;\n\t  var len;\n\t\n\t  if (!object || typeof object !== 'object') {\n\t    return object;\n\t  }\n\t\n\t  if (Array.isArray(object)) {\n\t    newObject = [];\n\t    for (i = 0, len = object.length; i < len; i++) {\n\t      newObject[i] = clone(object[i]);\n\t    }\n\t    return newObject;\n\t  }\n\t\n\t  // special case: to avoid inconsistencies between IndexedDB\n\t  // and other backends, we automatically stringify Dates\n\t  if (object instanceof Date) {\n\t    return object.toISOString();\n\t  }\n\t\n\t  if (isBinaryObject(object)) {\n\t    return cloneBinaryObject(object);\n\t  }\n\t\n\t  newObject = {};\n\t  for (i in object) {\n\t    if (Object.prototype.hasOwnProperty.call(object, i)) {\n\t      var value = clone(object[i]);\n\t      if (typeof value !== 'undefined') {\n\t        newObject[i] = value;\n\t      }\n\t    }\n\t  }\n\t  return newObject;\n\t}\n\t\n\tfunction once(fun) {\n\t  var called = false;\n\t  return getArguments(function (args) {\n\t    /* istanbul ignore if */\n\t    if (called) {\n\t      // this is a smoke test and should never actually happen\n\t      throw new Error('once called more than once');\n\t    } else {\n\t      called = true;\n\t      fun.apply(this, args);\n\t    }\n\t  });\n\t}\n\t\n\tfunction toPromise(func) {\n\t  //create the function we will be returning\n\t  return getArguments(function (args) {\n\t    // Clone arguments\n\t    args = clone(args);\n\t    var self = this;\n\t    var tempCB =\n\t      (typeof args[args.length - 1] === 'function') ? args.pop() : false;\n\t    // if the last argument is a function, assume its a callback\n\t    var usedCB;\n\t    if (tempCB) {\n\t      // if it was a callback, create a new callback which calls it,\n\t      // but do so async so we don't trap any errors\n\t      usedCB = function (err, resp) {\n\t        process.nextTick(function () {\n\t          tempCB(err, resp);\n\t        });\n\t      };\n\t    }\n\t    var promise = new PouchPromise(function (fulfill, reject) {\n\t      var resp;\n\t      try {\n\t        var callback = once(function (err, mesg) {\n\t          if (err) {\n\t            reject(err);\n\t          } else {\n\t            fulfill(mesg);\n\t          }\n\t        });\n\t        // create a callback for this invocation\n\t        // apply the function in the orig context\n\t        args.push(callback);\n\t        resp = func.apply(self, args);\n\t        if (resp && typeof resp.then === 'function') {\n\t          fulfill(resp);\n\t        }\n\t      } catch (e) {\n\t        reject(e);\n\t      }\n\t    });\n\t    // if there is a callback, call it back\n\t    if (usedCB) {\n\t      promise.then(function (result) {\n\t        usedCB(null, result);\n\t      }, usedCB);\n\t    }\n\t    return promise;\n\t  });\n\t}\n\t\n\tvar log = debug('pouchdb:api');\n\t\n\tfunction adapterFun(name, callback) {\n\t  function logApiCall(self, name, args) {\n\t    /* istanbul ignore if */\n\t    if (log.enabled) {\n\t      var logArgs = [self._db_name, name];\n\t      for (var i = 0; i < args.length - 1; i++) {\n\t        logArgs.push(args[i]);\n\t      }\n\t      log.apply(null, logArgs);\n\t\n\t      // override the callback itself to log the response\n\t      var origCallback = args[args.length - 1];\n\t      args[args.length - 1] = function (err, res) {\n\t        var responseArgs = [self._db_name, name];\n\t        responseArgs = responseArgs.concat(\n\t          err ? ['error', err] : ['success', res]\n\t        );\n\t        log.apply(null, responseArgs);\n\t        origCallback(err, res);\n\t      };\n\t    }\n\t  }\n\t\n\t  return toPromise(getArguments(function (args) {\n\t    if (this._closed) {\n\t      return PouchPromise.reject(new Error('database is closed'));\n\t    }\n\t    if (this._destroyed) {\n\t      return PouchPromise.reject(new Error('database is destroyed'));\n\t    }\n\t    var self = this;\n\t    logApiCall(self, name, args);\n\t    if (!this.taskqueue.isReady) {\n\t      return new PouchPromise(function (fulfill, reject) {\n\t        self.taskqueue.addTask(function (failed) {\n\t          if (failed) {\n\t            reject(failed);\n\t          } else {\n\t            fulfill(self[name].apply(self, args));\n\t          }\n\t        });\n\t      });\n\t    }\n\t    return callback.apply(this, args);\n\t  }));\n\t}\n\t\n\t// this is essentially the \"update sugar\" function from daleharvey/pouchdb#1388\n\t// the diffFun tells us what delta to apply to the doc.  it either returns\n\t// the doc, or false if it doesn't need to do an update after all\n\tfunction upsert(db, docId, diffFun) {\n\t  return new PouchPromise(function (fulfill, reject) {\n\t    db.get(docId, function (err, doc) {\n\t      if (err) {\n\t        /* istanbul ignore next */\n\t        if (err.status !== 404) {\n\t          return reject(err);\n\t        }\n\t        doc = {};\n\t      }\n\t\n\t      // the user might change the _rev, so save it for posterity\n\t      var docRev = doc._rev;\n\t      var newDoc = diffFun(doc);\n\t\n\t      if (!newDoc) {\n\t        // if the diffFun returns falsy, we short-circuit as\n\t        // an optimization\n\t        return fulfill({updated: false, rev: docRev});\n\t      }\n\t\n\t      // users aren't allowed to modify these values,\n\t      // so reset them here\n\t      newDoc._id = docId;\n\t      newDoc._rev = docRev;\n\t      fulfill(tryAndPut(db, newDoc, diffFun));\n\t    });\n\t  });\n\t}\n\t\n\tfunction tryAndPut(db, doc, diffFun) {\n\t  return db.put(doc).then(function (res) {\n\t    return {\n\t      updated: true,\n\t      rev: res.rev\n\t    };\n\t  }, function (err) {\n\t    /* istanbul ignore next */\n\t    if (err.status !== 409) {\n\t      throw err;\n\t    }\n\t    return upsert(db, doc._id, diffFun);\n\t  });\n\t}\n\t\n\t// We fetch all leafs of the revision tree, and sort them based on tree length\n\t// and whether they were deleted, undeleted documents with the longest revision\n\t// tree (most edits) win\n\t// The final sort algorithm is slightly documented in a sidebar here:\n\t// http://guide.couchdb.org/draft/conflicts.html\n\tfunction winningRev(metadata) {\n\t  var winningId;\n\t  var winningPos;\n\t  var winningDeleted;\n\t  var toVisit = metadata.rev_tree.slice();\n\t  var node;\n\t  while ((node = toVisit.pop())) {\n\t    var tree = node.ids;\n\t    var branches = tree[2];\n\t    var pos = node.pos;\n\t    if (branches.length) { // non-leaf\n\t      for (var i = 0, len = branches.length; i < len; i++) {\n\t        toVisit.push({pos: pos + 1, ids: branches[i]});\n\t      }\n\t      continue;\n\t    }\n\t    var deleted = !!tree[1].deleted;\n\t    var id = tree[0];\n\t    // sort by deleted, then pos, then id\n\t    if (!winningId || (winningDeleted !== deleted ? winningDeleted :\n\t        winningPos !== pos ? winningPos < pos : winningId < id)) {\n\t      winningId = id;\n\t      winningPos = pos;\n\t      winningDeleted = deleted;\n\t    }\n\t  }\n\t\n\t  return winningPos + '-' + winningId;\n\t}\n\t\n\tfunction getTrees(node) {\n\t  return node.ids;\n\t}\n\t\n\t// check if a specific revision of a doc has been deleted\n\t//  - metadata: the metadata object from the doc store\n\t//  - rev: (optional) the revision to check. defaults to winning revision\n\tfunction isDeleted(metadata, rev) {\n\t  if (!rev) {\n\t    rev = winningRev(metadata);\n\t  }\n\t  var id = rev.substring(rev.indexOf('-') + 1);\n\t  var toVisit = metadata.rev_tree.map(getTrees);\n\t\n\t  var tree;\n\t  while ((tree = toVisit.pop())) {\n\t    if (tree[0] === id) {\n\t      return !!tree[1].deleted;\n\t    }\n\t    toVisit = toVisit.concat(tree[2]);\n\t  }\n\t}\n\t\n\tfunction evalFilter(input) {\n\t  return scopedEval('return ' + input + ';', {});\n\t}\n\t\n\tfunction evalView(input) {\n\t  /* jshint evil:true */\n\t  return new Function('doc', [\n\t    'var emitted = false;',\n\t    'var emit = function (a, b) {',\n\t    '  emitted = true;',\n\t    '};',\n\t    'var view = ' + input + ';',\n\t    'view(doc);',\n\t    'if (emitted) {',\n\t    '  return true;',\n\t    '}'\n\t  ].join('\\n'));\n\t}\n\t\n\tfunction parseDesignDocFunctionName(s) {\n\t  if (!s) {\n\t    return null;\n\t  }\n\t  var parts = s.split('/');\n\t  if (parts.length === 2) {\n\t    return parts;\n\t  }\n\t  if (parts.length === 1) {\n\t    return [s, s];\n\t  }\n\t  return null;\n\t}\n\t\n\tfunction normalizeDesignDocFunctionName(s) {\n\t  var normalized = parseDesignDocFunctionName(s);\n\t  return normalized ? normalized.join('/') : null;\n\t}\n\t\n\t// Pretty much all below can be combined into a higher order function to\n\t// traverse revisions\n\t// The return value from the callback will be passed as context to all\n\t// children of that node\n\tfunction traverseRevTree(revs, callback) {\n\t  var toVisit = revs.slice();\n\t\n\t  var node;\n\t  while ((node = toVisit.pop())) {\n\t    var pos = node.pos;\n\t    var tree = node.ids;\n\t    var branches = tree[2];\n\t    var newCtx =\n\t      callback(branches.length === 0, pos, tree[0], node.ctx, tree[1]);\n\t    for (var i = 0, len = branches.length; i < len; i++) {\n\t      toVisit.push({pos: pos + 1, ids: branches[i], ctx: newCtx});\n\t    }\n\t  }\n\t}\n\t\n\tfunction sortByPos(a, b) {\n\t  return a.pos - b.pos;\n\t}\n\t\n\tfunction collectLeaves(revs) {\n\t  var leaves = [];\n\t  traverseRevTree(revs, function (isLeaf, pos, id, acc, opts) {\n\t    if (isLeaf) {\n\t      leaves.push({rev: pos + \"-\" + id, pos: pos, opts: opts});\n\t    }\n\t  });\n\t  leaves.sort(sortByPos).reverse();\n\t  for (var i = 0, len = leaves.length; i < len; i++) {\n\t    delete leaves[i].pos;\n\t  }\n\t  return leaves;\n\t}\n\t\n\t// returns revs of all conflicts that is leaves such that\n\t// 1. are not deleted and\n\t// 2. are different than winning revision\n\tfunction collectConflicts(metadata) {\n\t  var win = winningRev(metadata);\n\t  var leaves = collectLeaves(metadata.rev_tree);\n\t  var conflicts = [];\n\t  for (var i = 0, len = leaves.length; i < len; i++) {\n\t    var leaf = leaves[i];\n\t    if (leaf.rev !== win && !leaf.opts.deleted) {\n\t      conflicts.push(leaf.rev);\n\t    }\n\t  }\n\t  return conflicts;\n\t}\n\t\n\tinherits(PouchError, Error);\n\t\n\tfunction PouchError(opts) {\n\t  Error.call(this, opts.reason);\n\t  this.status = opts.status;\n\t  this.name = opts.error;\n\t  this.message = opts.reason;\n\t  this.error = true;\n\t}\n\t\n\tPouchError.prototype.toString = function () {\n\t  return JSON.stringify({\n\t    status: this.status,\n\t    name: this.name,\n\t    message: this.message,\n\t    reason: this.reason\n\t  });\n\t};\n\t\n\tvar UNAUTHORIZED = new PouchError({\n\t  status: 401,\n\t  error: 'unauthorized',\n\t  reason: \"Name or password is incorrect.\"\n\t});\n\t\n\tvar MISSING_BULK_DOCS = new PouchError({\n\t  status: 400,\n\t  error: 'bad_request',\n\t  reason: \"Missing JSON list of 'docs'\"\n\t});\n\t\n\tvar MISSING_DOC = new PouchError({\n\t  status: 404,\n\t  error: 'not_found',\n\t  reason: 'missing'\n\t});\n\t\n\tvar REV_CONFLICT = new PouchError({\n\t  status: 409,\n\t  error: 'conflict',\n\t  reason: 'Document update conflict'\n\t});\n\t\n\tvar INVALID_ID = new PouchError({\n\t  status: 400,\n\t  error: 'invalid_id',\n\t  reason: '_id field must contain a string'\n\t});\n\t\n\tvar MISSING_ID = new PouchError({\n\t  status: 412,\n\t  error: 'missing_id',\n\t  reason: '_id is required for puts'\n\t});\n\t\n\tvar RESERVED_ID = new PouchError({\n\t  status: 400,\n\t  error: 'bad_request',\n\t  reason: 'Only reserved document ids may start with underscore.'\n\t});\n\t\n\tvar NOT_OPEN = new PouchError({\n\t  status: 412,\n\t  error: 'precondition_failed',\n\t  reason: 'Database not open'\n\t});\n\t\n\tvar UNKNOWN_ERROR = new PouchError({\n\t  status: 500,\n\t  error: 'unknown_error',\n\t  reason: 'Database encountered an unknown error'\n\t});\n\t\n\tvar BAD_ARG = new PouchError({\n\t  status: 500,\n\t  error: 'badarg',\n\t  reason: 'Some query argument is invalid'\n\t});\n\t\n\tvar INVALID_REQUEST = new PouchError({\n\t  status: 400,\n\t  error: 'invalid_request',\n\t  reason: 'Request was invalid'\n\t});\n\t\n\tvar QUERY_PARSE_ERROR = new PouchError({\n\t  status: 400,\n\t  error: 'query_parse_error',\n\t  reason: 'Some query parameter is invalid'\n\t});\n\t\n\tvar DOC_VALIDATION = new PouchError({\n\t  status: 500,\n\t  error: 'doc_validation',\n\t  reason: 'Bad special document member'\n\t});\n\t\n\tvar BAD_REQUEST = new PouchError({\n\t  status: 400,\n\t  error: 'bad_request',\n\t  reason: 'Something wrong with the request'\n\t});\n\t\n\tvar NOT_AN_OBJECT = new PouchError({\n\t  status: 400,\n\t  error: 'bad_request',\n\t  reason: 'Document must be a JSON object'\n\t});\n\t\n\tvar DB_MISSING = new PouchError({\n\t  status: 404,\n\t  error: 'not_found',\n\t  reason: 'Database not found'\n\t});\n\t\n\tvar IDB_ERROR = new PouchError({\n\t  status: 500,\n\t  error: 'indexed_db_went_bad',\n\t  reason: 'unknown'\n\t});\n\t\n\tvar WSQ_ERROR = new PouchError({\n\t  status: 500,\n\t  error: 'web_sql_went_bad',\n\t  reason: 'unknown'\n\t});\n\t\n\tvar LDB_ERROR = new PouchError({\n\t  status: 500,\n\t  error: 'levelDB_went_went_bad',\n\t  reason: 'unknown'\n\t});\n\t\n\tvar FORBIDDEN = new PouchError({\n\t  status: 403,\n\t  error: 'forbidden',\n\t  reason: 'Forbidden by design doc validate_doc_update function'\n\t});\n\t\n\tvar INVALID_REV = new PouchError({\n\t  status: 400,\n\t  error: 'bad_request',\n\t  reason: 'Invalid rev format'\n\t});\n\t\n\tvar FILE_EXISTS = new PouchError({\n\t  status: 412,\n\t  error: 'file_exists',\n\t  reason: 'The database could not be created, the file already exists.'\n\t});\n\t\n\tvar MISSING_STUB = new PouchError({\n\t  status: 412,\n\t  error: 'missing_stub'\n\t});\n\t\n\tvar INVALID_URL = new PouchError({\n\t  status: 413,\n\t  error: 'invalid_url',\n\t  reason: 'Provided URL is invalid'\n\t});\n\t\n\tvar allErrors = {\n\t  UNAUTHORIZED: UNAUTHORIZED,\n\t  MISSING_BULK_DOCS: MISSING_BULK_DOCS,\n\t  MISSING_DOC: MISSING_DOC,\n\t  REV_CONFLICT: REV_CONFLICT,\n\t  INVALID_ID: INVALID_ID,\n\t  MISSING_ID: MISSING_ID,\n\t  RESERVED_ID: RESERVED_ID,\n\t  NOT_OPEN: NOT_OPEN,\n\t  UNKNOWN_ERROR: UNKNOWN_ERROR,\n\t  BAD_ARG: BAD_ARG,\n\t  INVALID_REQUEST: INVALID_REQUEST,\n\t  QUERY_PARSE_ERROR: QUERY_PARSE_ERROR,\n\t  DOC_VALIDATION: DOC_VALIDATION,\n\t  BAD_REQUEST: BAD_REQUEST,\n\t  NOT_AN_OBJECT: NOT_AN_OBJECT,\n\t  DB_MISSING: DB_MISSING,\n\t  WSQ_ERROR: WSQ_ERROR,\n\t  LDB_ERROR: LDB_ERROR,\n\t  FORBIDDEN: FORBIDDEN,\n\t  INVALID_REV: INVALID_REV,\n\t  FILE_EXISTS: FILE_EXISTS,\n\t  MISSING_STUB: MISSING_STUB,\n\t  IDB_ERROR: IDB_ERROR,\n\t  INVALID_URL: INVALID_URL\n\t};\n\t\n\tfunction createError(error, reason, name) {\n\t  function CustomPouchError(reason) {\n\t    // inherit error properties from our parent error manually\n\t    // so as to allow proper JSON parsing.\n\t    /* jshint ignore:start */\n\t    for (var p in error) {\n\t      if (typeof error[p] !== 'function') {\n\t        this[p] = error[p];\n\t      }\n\t    }\n\t    /* jshint ignore:end */\n\t    if (name !== undefined) {\n\t      this.name = name;\n\t    }\n\t    if (reason !== undefined) {\n\t      this.reason = reason;\n\t    }\n\t  }\n\t  CustomPouchError.prototype = PouchError.prototype;\n\t  return new CustomPouchError(reason);\n\t}\n\t\n\t// Find one of the errors defined above based on the value\n\t// of the specified property.\n\t// If reason is provided prefer the error matching that reason.\n\t// This is for differentiating between errors with the same name and status,\n\t// eg, bad_request.\n\tvar getErrorTypeByProp = function (prop, value, reason) {\n\t  var keys = Object.keys(allErrors).filter(function (key) {\n\t    var error = allErrors[key];\n\t    return typeof error !== 'function' && error[prop] === value;\n\t  });\n\t  var key = reason && keys.filter(function (key) {\n\t        var error = allErrors[key];\n\t        return error.message === reason;\n\t      })[0] || keys[0];\n\t  return (key) ? allErrors[key] : null;\n\t};\n\t\n\tfunction generateErrorFromResponse(res) {\n\t  var error, errName, errType, errMsg, errReason;\n\t\n\t  errName = (res.error === true && typeof res.name === 'string') ?\n\t              res.name :\n\t              res.error;\n\t  errReason = res.reason;\n\t  errType = getErrorTypeByProp('name', errName, errReason);\n\t\n\t  if (res.missing ||\n\t      errReason === 'missing' ||\n\t      errReason === 'deleted' ||\n\t      errName === 'not_found') {\n\t    errType = MISSING_DOC;\n\t  } else if (errName === 'doc_validation') {\n\t    // doc validation needs special treatment since\n\t    // res.reason depends on the validation error.\n\t    // see utils.js\n\t    errType = DOC_VALIDATION;\n\t    errMsg = errReason;\n\t  } else if (errName === 'bad_request' && errType.message !== errReason) {\n\t    // if bad_request error already found based on reason don't override.\n\t    errType = BAD_REQUEST;\n\t  }\n\t\n\t  // fallback to error by status or unknown error.\n\t  if (!errType) {\n\t    errType = getErrorTypeByProp('status', res.status, errReason) ||\n\t                UNKNOWN_ERROR;\n\t  }\n\t\n\t  error = createError(errType, errReason, errName);\n\t\n\t  // Keep custom message.\n\t  if (errMsg) {\n\t    error.message = errMsg;\n\t  }\n\t\n\t  // Keep helpful response data in our error messages.\n\t  if (res.id) {\n\t    error.id = res.id;\n\t  }\n\t  if (res.status) {\n\t    error.status = res.status;\n\t  }\n\t  if (res.missing) {\n\t    error.missing = res.missing;\n\t  }\n\t\n\t  return error;\n\t}\n\t\n\tinherits(Changes, events.EventEmitter);\n\t\n\tfunction Changes(db, opts, callback) {\n\t  events.EventEmitter.call(this);\n\t  var self = this;\n\t  this.db = db;\n\t  opts = opts ? clone(opts) : {};\n\t  var complete = opts.complete = once(function (err, resp) {\n\t    if (err) {\n\t      self.emit('error', err);\n\t    } else {\n\t      self.emit('complete', resp);\n\t    }\n\t    self.removeAllListeners();\n\t    db.removeListener('destroyed', onDestroy);\n\t  });\n\t  if (callback) {\n\t    self.on('complete', function (resp) {\n\t      callback(null, resp);\n\t    });\n\t    self.on('error', callback);\n\t  }\n\t  function onDestroy() {\n\t    self.cancel();\n\t  }\n\t  db.once('destroyed', onDestroy);\n\t\n\t  opts.onChange = function (change) {\n\t    /* istanbul ignore if */\n\t    if (opts.isCancelled) {\n\t      return;\n\t    }\n\t    self.emit('change', change);\n\t    if (self.startSeq && self.startSeq <= change.seq) {\n\t      self.startSeq = false;\n\t    }\n\t  };\n\t\n\t  var promise = new PouchPromise(function (fulfill, reject) {\n\t    opts.complete = function (err, res) {\n\t      if (err) {\n\t        reject(err);\n\t      } else {\n\t        fulfill(res);\n\t      }\n\t    };\n\t  });\n\t  self.once('cancel', function () {\n\t    db.removeListener('destroyed', onDestroy);\n\t    opts.complete(null, {status: 'cancelled'});\n\t  });\n\t  this.then = promise.then.bind(promise);\n\t  this['catch'] = promise['catch'].bind(promise);\n\t  this.then(function (result) {\n\t    complete(null, result);\n\t  }, complete);\n\t\n\t\n\t\n\t  if (!db.taskqueue.isReady) {\n\t    db.taskqueue.addTask(function () {\n\t      if (self.isCancelled) {\n\t        self.emit('cancel');\n\t      } else {\n\t        self.doChanges(opts);\n\t      }\n\t    });\n\t  } else {\n\t    self.doChanges(opts);\n\t  }\n\t}\n\tChanges.prototype.cancel = function () {\n\t  this.isCancelled = true;\n\t  if (this.db.taskqueue.isReady) {\n\t    this.emit('cancel');\n\t  }\n\t};\n\tfunction processChange(doc, metadata, opts) {\n\t  var changeList = [{rev: doc._rev}];\n\t  if (opts.style === 'all_docs') {\n\t    changeList = collectLeaves(metadata.rev_tree)\n\t    .map(function (x) { return {rev: x.rev}; });\n\t  }\n\t  var change = {\n\t    id: metadata.id,\n\t    changes: changeList,\n\t    doc: doc\n\t  };\n\t\n\t  if (isDeleted(metadata, doc._rev)) {\n\t    change.deleted = true;\n\t  }\n\t  if (opts.conflicts) {\n\t    change.doc._conflicts = collectConflicts(metadata);\n\t    if (!change.doc._conflicts.length) {\n\t      delete change.doc._conflicts;\n\t    }\n\t  }\n\t  return change;\n\t}\n\t\n\tChanges.prototype.doChanges = function (opts) {\n\t  var self = this;\n\t  var callback = opts.complete;\n\t\n\t  opts = clone(opts);\n\t  if ('live' in opts && !('continuous' in opts)) {\n\t    opts.continuous = opts.live;\n\t  }\n\t  opts.processChange = processChange;\n\t\n\t  if (opts.since === 'latest') {\n\t    opts.since = 'now';\n\t  }\n\t  if (!opts.since) {\n\t    opts.since = 0;\n\t  }\n\t  if (opts.since === 'now') {\n\t    this.db.info().then(function (info) {\n\t      /* istanbul ignore if */\n\t      if (self.isCancelled) {\n\t        callback(null, {status: 'cancelled'});\n\t        return;\n\t      }\n\t      opts.since = info.update_seq;\n\t      self.doChanges(opts);\n\t    }, callback);\n\t    return;\n\t  }\n\t\n\t  if (opts.continuous && opts.since !== 'now') {\n\t    this.db.info().then(function (info) {\n\t      self.startSeq = info.update_seq;\n\t    /* istanbul ignore next */\n\t    }, function (err) {\n\t      if (err.id === 'idbNull') {\n\t        // db closed before this returned thats ok\n\t        return;\n\t      }\n\t      throw err;\n\t    });\n\t  }\n\t\n\t  if (opts.filter && typeof opts.filter === 'string') {\n\t    if (opts.filter === '_view') {\n\t      opts.view = normalizeDesignDocFunctionName(opts.view);\n\t    } else {\n\t      opts.filter = normalizeDesignDocFunctionName(opts.filter);\n\t    }\n\t\n\t    if (this.db.type() !== 'http' && !opts.doc_ids) {\n\t      return this.filterChanges(opts);\n\t    }\n\t  }\n\t\n\t  if (!('descending' in opts)) {\n\t    opts.descending = false;\n\t  }\n\t\n\t  // 0 and 1 should return 1 document\n\t  opts.limit = opts.limit === 0 ? 1 : opts.limit;\n\t  opts.complete = callback;\n\t  var newPromise = this.db._changes(opts);\n\t  if (newPromise && typeof newPromise.cancel === 'function') {\n\t    var cancel = self.cancel;\n\t    self.cancel = getArguments(function (args) {\n\t      newPromise.cancel();\n\t      cancel.apply(this, args);\n\t    });\n\t  }\n\t};\n\t\n\tChanges.prototype.filterChanges = function (opts) {\n\t  var self = this;\n\t  var callback = opts.complete;\n\t  if (opts.filter === '_view') {\n\t    if (!opts.view || typeof opts.view !== 'string') {\n\t      var err = createError(BAD_REQUEST,\n\t        '`view` filter parameter not found or invalid.');\n\t      return callback(err);\n\t    }\n\t    // fetch a view from a design doc, make it behave like a filter\n\t    var viewName = parseDesignDocFunctionName(opts.view);\n\t    this.db.getView(viewName[0], viewName[1], function (err, view) {\n\t      /* istanbul ignore if */\n\t      if (self.isCancelled) {\n\t        return callback(null, {status: 'cancelled'});\n\t      }\n\t      /* istanbul ignore next */\n\t      if (err) {\n\t        return callback(generateErrorFromResponse(err));\n\t      }\n\t      if (!view.map) {\n\t        return callback(createError(MISSING_DOC));\n\t      }\n\t      opts.filter = evalView(view.map);\n\t      self.doChanges(opts);\n\t    });\n\t  } else {\n\t    // fetch a filter from a design doc\n\t    var filterName = parseDesignDocFunctionName(opts.filter);\n\t    if (!filterName) {\n\t      return self.doChanges(opts);\n\t    }\n\t    this.db.getFilter(filterName[0], filterName[1], function (err, filterFun) {\n\t      /* istanbul ignore if */\n\t      if (self.isCancelled) {\n\t        return callback(null, {status: 'cancelled'});\n\t      }\n\t      /* istanbul ignore next */\n\t      if (err) {\n\t        return callback(generateErrorFromResponse(err));\n\t      }\n\t      opts.filter = evalFilter(filterFun);\n\t      self.doChanges(opts);\n\t    });\n\t  }\n\t};\n\t\n\t// shim for P/CouchDB adapters that don't directly implement _bulk_get\n\tfunction bulkGet(db, opts, callback) {\n\t  var requests = Array.isArray(opts) ? opts : opts.docs;\n\t\n\t  // consolidate into one request per doc if possible\n\t  var requestsById = {};\n\t  requests.forEach(function (request) {\n\t    if (request.id in requestsById) {\n\t      requestsById[request.id].push(request);\n\t    } else {\n\t      requestsById[request.id] = [request];\n\t    }\n\t  });\n\t\n\t  var numDocs = Object.keys(requestsById).length;\n\t  var numDone = 0;\n\t  var perDocResults = new Array(numDocs);\n\t\n\t  function collapseResults() {\n\t    var results = [];\n\t    perDocResults.forEach(function (res) {\n\t      res.docs.forEach(function (info) {\n\t        results.push({\n\t          id: res.id,\n\t          docs: [info]\n\t        });\n\t      });\n\t    });\n\t    callback(null, {results: results});\n\t  }\n\t\n\t  function checkDone() {\n\t    if (++numDone === numDocs) {\n\t      collapseResults();\n\t    }\n\t  }\n\t\n\t  function gotResult(i, id, docs) {\n\t    perDocResults[i] = {id: id, docs: docs};\n\t    checkDone();\n\t  }\n\t\n\t  Object.keys(requestsById).forEach(function (docId, i) {\n\t\n\t    var docRequests = requestsById[docId];\n\t\n\t    // just use the first request as the \"template\"\n\t    // TODO: The _bulk_get API allows for more subtle use cases than this,\n\t    // but for now it is unlikely that there will be a mix of different\n\t    // \"atts_since\" or \"attachments\" in the same request, since it's just\n\t    // replicate.js that is using this for the moment.\n\t    // Also, atts_since is aspirational, since we don't support it yet.\n\t    var docOpts = pick(docRequests[0], ['atts_since', 'attachments']);\n\t    docOpts.open_revs = docRequests.map(function (request) {\n\t      // rev is optional, open_revs disallowed\n\t      return request.rev;\n\t    });\n\t\n\t    // remove falsey / undefined revisions\n\t    docOpts.open_revs = docOpts.open_revs.filter(function (e) { return e; });\n\t\n\t    var formatResult = function (result) { return result; };\n\t\n\t    if (docOpts.open_revs.length === 0) {\n\t      delete docOpts.open_revs;\n\t\n\t      // when fetching only the \"winning\" leaf,\n\t      // transform the result so it looks like an open_revs\n\t      // request\n\t      formatResult = function (result) {\n\t        return [{\n\t          ok: result\n\t        }];\n\t      };\n\t    }\n\t\n\t    // globally-supplied options\n\t    ['revs', 'attachments', 'binary'].forEach(function (param) {\n\t      if (param in opts) {\n\t        docOpts[param] = opts[param];\n\t      }\n\t    });\n\t    db.get(docId, docOpts, function (err, res) {\n\t      gotResult(i, docId, err ? [{error: err}] : formatResult(res));\n\t    });\n\t  });\n\t}\n\t\n\tfunction isLocalId(id) {\n\t  return (/^_local/).test(id);\n\t}\n\t\n\t// build up a list of all the paths to the leafs in this revision tree\n\tfunction rootToLeaf(revs) {\n\t  var paths = [];\n\t  var toVisit = revs.slice();\n\t  var node;\n\t  while ((node = toVisit.pop())) {\n\t    var pos = node.pos;\n\t    var tree = node.ids;\n\t    var id = tree[0];\n\t    var opts = tree[1];\n\t    var branches = tree[2];\n\t    var isLeaf = branches.length === 0;\n\t\n\t    var history = node.history ? node.history.slice() : [];\n\t    history.push({id: id, opts: opts});\n\t    if (isLeaf) {\n\t      paths.push({pos: (pos + 1 - history.length), ids: history});\n\t    }\n\t    for (var i = 0, len = branches.length; i < len; i++) {\n\t      toVisit.push({pos: pos + 1, ids: branches[i], history: history});\n\t    }\n\t  }\n\t  return paths.reverse();\n\t}\n\t\n\t// BEGIN Math.uuid.js\n\t\n\t/*!\n\tMath.uuid.js (v1.4)\n\thttp://www.broofa.com\n\tmailto:robert@broofa.com\n\t\n\tCopyright (c) 2010 Robert Kieffer\n\tDual licensed under the MIT and GPL licenses.\n\t*/\n\t\n\t/*\n\t * Generate a random uuid.\n\t *\n\t * USAGE: Math.uuid(length, radix)\n\t *   length - the desired number of characters\n\t *   radix  - the number of allowable values for each character.\n\t *\n\t * EXAMPLES:\n\t *   // No arguments  - returns RFC4122, version 4 ID\n\t *   >>> Math.uuid()\n\t *   \"92329D39-6F5C-4520-ABFC-AAB64544E172\"\n\t *\n\t *   // One argument - returns ID of the specified length\n\t *   >>> Math.uuid(15)     // 15 character ID (default base=62)\n\t *   \"VcydxgltxrVZSTV\"\n\t *\n\t *   // Two arguments - returns ID of the specified length, and radix. \n\t *   // (Radix must be <= 62)\n\t *   >>> Math.uuid(8, 2)  // 8 character ID (base=2)\n\t *   \"01001010\"\n\t *   >>> Math.uuid(8, 10) // 8 character ID (base=10)\n\t *   \"47473046\"\n\t *   >>> Math.uuid(8, 16) // 8 character ID (base=16)\n\t *   \"098F4D35\"\n\t */\n\tvar chars = (\n\t  '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ' +\n\t  'abcdefghijklmnopqrstuvwxyz'\n\t).split('');\n\tfunction getValue(radix) {\n\t  return 0 | Math.random() * radix;\n\t}\n\tfunction uuid(len, radix) {\n\t  radix = radix || chars.length;\n\t  var out = '';\n\t  var i = -1;\n\t\n\t  if (len) {\n\t    // Compact form\n\t    while (++i < len) {\n\t      out += chars[getValue(radix)];\n\t    }\n\t    return out;\n\t  }\n\t    // rfc4122, version 4 form\n\t    // Fill in random data.  At i==19 set the high bits of clock sequence as\n\t    // per rfc4122, sec. 4.1.5\n\t  while (++i < 36) {\n\t    switch (i) {\n\t      case 8:\n\t      case 13:\n\t      case 18:\n\t      case 23:\n\t        out += '-';\n\t        break;\n\t      case 19:\n\t        out += chars[(getValue(16) & 0x3) | 0x8];\n\t        break;\n\t      default:\n\t        out += chars[getValue(16)];\n\t    }\n\t  }\n\t\n\t  return out;\n\t}\n\t\n\tfunction toObject(array) {\n\t  return array.reduce(function (obj, item) {\n\t    obj[item] = true;\n\t    return obj;\n\t  }, {});\n\t}\n\t// List of top level reserved words for doc\n\tvar reservedWords = toObject([\n\t  '_id',\n\t  '_rev',\n\t  '_attachments',\n\t  '_deleted',\n\t  '_revisions',\n\t  '_revs_info',\n\t  '_conflicts',\n\t  '_deleted_conflicts',\n\t  '_local_seq',\n\t  '_rev_tree',\n\t  //replication documents\n\t  '_replication_id',\n\t  '_replication_state',\n\t  '_replication_state_time',\n\t  '_replication_state_reason',\n\t  '_replication_stats',\n\t  // Specific to Couchbase Sync Gateway\n\t  '_removed'\n\t]);\n\t\n\t// List of reserved words that should end up the document\n\tvar dataWords = toObject([\n\t  '_attachments',\n\t  //replication documents\n\t  '_replication_id',\n\t  '_replication_state',\n\t  '_replication_state_time',\n\t  '_replication_state_reason',\n\t  '_replication_stats'\n\t]);\n\t\n\t// Determine id an ID is valid\n\t//   - invalid IDs begin with an underescore that does not begin '_design' or\n\t//     '_local'\n\t//   - any other string value is a valid id\n\t// Returns the specific error object for each case\n\tfunction invalidIdError(id) {\n\t  var err;\n\t  if (!id) {\n\t    err = createError(MISSING_ID);\n\t  } else if (typeof id !== 'string') {\n\t    err = createError(INVALID_ID);\n\t  } else if (/^_/.test(id) && !(/^_(design|local)/).test(id)) {\n\t    err = createError(RESERVED_ID);\n\t  }\n\t  if (err) {\n\t    throw err;\n\t  }\n\t}\n\t\n\tfunction parseRevisionInfo(rev) {\n\t  if (!/^\\d+\\-./.test(rev)) {\n\t    return createError(INVALID_REV);\n\t  }\n\t  var idx = rev.indexOf('-');\n\t  var left = rev.substring(0, idx);\n\t  var right = rev.substring(idx + 1);\n\t  return {\n\t    prefix: parseInt(left, 10),\n\t    id: right\n\t  };\n\t}\n\t\n\tfunction makeRevTreeFromRevisions(revisions, opts) {\n\t  var pos = revisions.start - revisions.ids.length + 1;\n\t\n\t  var revisionIds = revisions.ids;\n\t  var ids = [revisionIds[0], opts, []];\n\t\n\t  for (var i = 1, len = revisionIds.length; i < len; i++) {\n\t    ids = [revisionIds[i], {status: 'missing'}, [ids]];\n\t  }\n\t\n\t  return [{\n\t    pos: pos,\n\t    ids: ids\n\t  }];\n\t}\n\t\n\t// Preprocess documents, parse their revisions, assign an id and a\n\t// revision for new writes that are missing them, etc\n\tfunction parseDoc(doc, newEdits) {\n\t\n\t  var nRevNum;\n\t  var newRevId;\n\t  var revInfo;\n\t  var opts = {status: 'available'};\n\t  if (doc._deleted) {\n\t    opts.deleted = true;\n\t  }\n\t\n\t  if (newEdits) {\n\t    if (!doc._id) {\n\t      doc._id = uuid();\n\t    }\n\t    newRevId = uuid(32, 16).toLowerCase();\n\t    if (doc._rev) {\n\t      revInfo = parseRevisionInfo(doc._rev);\n\t      if (revInfo.error) {\n\t        return revInfo;\n\t      }\n\t      doc._rev_tree = [{\n\t        pos: revInfo.prefix,\n\t        ids: [revInfo.id, {status: 'missing'}, [[newRevId, opts, []]]]\n\t      }];\n\t      nRevNum = revInfo.prefix + 1;\n\t    } else {\n\t      doc._rev_tree = [{\n\t        pos: 1,\n\t        ids : [newRevId, opts, []]\n\t      }];\n\t      nRevNum = 1;\n\t    }\n\t  } else {\n\t    if (doc._revisions) {\n\t      doc._rev_tree = makeRevTreeFromRevisions(doc._revisions, opts);\n\t      nRevNum = doc._revisions.start;\n\t      newRevId = doc._revisions.ids[0];\n\t    }\n\t    if (!doc._rev_tree) {\n\t      revInfo = parseRevisionInfo(doc._rev);\n\t      if (revInfo.error) {\n\t        return revInfo;\n\t      }\n\t      nRevNum = revInfo.prefix;\n\t      newRevId = revInfo.id;\n\t      doc._rev_tree = [{\n\t        pos: nRevNum,\n\t        ids: [newRevId, opts, []]\n\t      }];\n\t    }\n\t  }\n\t\n\t  invalidIdError(doc._id);\n\t\n\t  doc._rev = nRevNum + '-' + newRevId;\n\t\n\t  var result = {metadata : {}, data : {}};\n\t  for (var key in doc) {\n\t    /* istanbul ignore else */\n\t    if (Object.prototype.hasOwnProperty.call(doc, key)) {\n\t      var specialKey = key[0] === '_';\n\t      if (specialKey && !reservedWords[key]) {\n\t        var error = createError(DOC_VALIDATION, key);\n\t        error.message = DOC_VALIDATION.message + ': ' + key;\n\t        throw error;\n\t      } else if (specialKey && !dataWords[key]) {\n\t        result.metadata[key.slice(1)] = doc[key];\n\t      } else {\n\t        result.data[key] = doc[key];\n\t      }\n\t    }\n\t  }\n\t  return result;\n\t}\n\t\n\t/*\n\t * A generic pouch adapter\n\t */\n\t\n\tfunction compare(left, right) {\n\t  return left < right ? -1 : left > right ? 1 : 0;\n\t}\n\t\n\t// returns first element of arr satisfying callback predicate\n\tfunction arrayFirst(arr, callback) {\n\t  for (var i = 0; i < arr.length; i++) {\n\t    if (callback(arr[i], i) === true) {\n\t      return arr[i];\n\t    }\n\t  }\n\t}\n\t\n\t// Wrapper for functions that call the bulkdocs api with a single doc,\n\t// if the first result is an error, return an error\n\tfunction yankError(callback) {\n\t  return function (err, results) {\n\t    if (err || (results[0] && results[0].error)) {\n\t      callback(err || results[0]);\n\t    } else {\n\t      callback(null, results.length ? results[0]  : results);\n\t    }\n\t  };\n\t}\n\t\n\t// clean docs given to us by the user\n\tfunction cleanDocs(docs) {\n\t  for (var i = 0; i < docs.length; i++) {\n\t    var doc = docs[i];\n\t    if (doc._deleted) {\n\t      delete doc._attachments; // ignore atts for deleted docs\n\t    } else if (doc._attachments) {\n\t      // filter out extraneous keys from _attachments\n\t      var atts = Object.keys(doc._attachments);\n\t      for (var j = 0; j < atts.length; j++) {\n\t        var att = atts[j];\n\t        doc._attachments[att] = pick(doc._attachments[att],\n\t          ['data', 'digest', 'content_type', 'length', 'revpos', 'stub']);\n\t      }\n\t    }\n\t  }\n\t}\n\t\n\t// compare two docs, first by _id then by _rev\n\tfunction compareByIdThenRev(a, b) {\n\t  var idCompare = compare(a._id, b._id);\n\t  if (idCompare !== 0) {\n\t    return idCompare;\n\t  }\n\t  var aStart = a._revisions ? a._revisions.start : 0;\n\t  var bStart = b._revisions ? b._revisions.start : 0;\n\t  return compare(aStart, bStart);\n\t}\n\t\n\t// for every node in a revision tree computes its distance from the closest\n\t// leaf\n\tfunction computeHeight(revs) {\n\t  var height = {};\n\t  var edges = [];\n\t  traverseRevTree(revs, function (isLeaf, pos, id, prnt) {\n\t    var rev = pos + \"-\" + id;\n\t    if (isLeaf) {\n\t      height[rev] = 0;\n\t    }\n\t    if (prnt !== undefined) {\n\t      edges.push({from: prnt, to: rev});\n\t    }\n\t    return rev;\n\t  });\n\t\n\t  edges.reverse();\n\t  edges.forEach(function (edge) {\n\t    if (height[edge.from] === undefined) {\n\t      height[edge.from] = 1 + height[edge.to];\n\t    } else {\n\t      height[edge.from] = Math.min(height[edge.from], 1 + height[edge.to]);\n\t    }\n\t  });\n\t  return height;\n\t}\n\t\n\tfunction allDocsKeysQuery(api, opts, callback) {\n\t  var keys =  ('limit' in opts) ?\n\t      opts.keys.slice(opts.skip, opts.limit + opts.skip) :\n\t      (opts.skip > 0) ? opts.keys.slice(opts.skip) : opts.keys;\n\t  if (opts.descending) {\n\t    keys.reverse();\n\t  }\n\t  if (!keys.length) {\n\t    return api._allDocs({limit: 0}, callback);\n\t  }\n\t  var finalResults = {\n\t    offset: opts.skip\n\t  };\n\t  return PouchPromise.all(keys.map(function (key) {\n\t    var subOpts = jsExtend.extend({key: key, deleted: 'ok'}, opts);\n\t    ['limit', 'skip', 'keys'].forEach(function (optKey) {\n\t      delete subOpts[optKey];\n\t    });\n\t    return new PouchPromise(function (resolve, reject) {\n\t      api._allDocs(subOpts, function (err, res) {\n\t        /* istanbul ignore if */\n\t        if (err) {\n\t          return reject(err);\n\t        }\n\t        finalResults.total_rows = res.total_rows;\n\t        resolve(res.rows[0] || {key: key, error: 'not_found'});\n\t      });\n\t    });\n\t  })).then(function (results) {\n\t    finalResults.rows = results;\n\t    return finalResults;\n\t  });\n\t}\n\t\n\t// all compaction is done in a queue, to avoid attaching\n\t// too many listeners at once\n\tfunction doNextCompaction(self) {\n\t  var task = self._compactionQueue[0];\n\t  var opts = task.opts;\n\t  var callback = task.callback;\n\t  self.get('_local/compaction').catch(function () {\n\t    return false;\n\t  }).then(function (doc) {\n\t    if (doc && doc.last_seq) {\n\t      opts.last_seq = doc.last_seq;\n\t    }\n\t    self._compact(opts, function (err, res) {\n\t      /* istanbul ignore if */\n\t      if (err) {\n\t        callback(err);\n\t      } else {\n\t        callback(null, res);\n\t      }\n\t      process.nextTick(function () {\n\t        self._compactionQueue.shift();\n\t        if (self._compactionQueue.length) {\n\t          doNextCompaction(self);\n\t        }\n\t      });\n\t    });\n\t  });\n\t}\n\t\n\tfunction attachmentNameError(name) {\n\t  if (name.charAt(0) === '_') {\n\t    return name + 'is not a valid attachment name, attachment ' +\n\t      'names cannot start with \\'_\\'';\n\t  }\n\t  return false;\n\t}\n\t\n\tfunction cacheUpdateRequired(api, cache, designDocName, callback) {\n\t  cache.seq = cache.seq || 0;\n\t  var changesOpts = {\n\t    doc_ids: [ '_design/' + designDocName ],\n\t    limit: 1,\n\t    since: cache.seq\n\t  };\n\t  api.changes(changesOpts).then(function(res) {\n\t    var latestSeq = res.results && res.results.length && res.results[0].seq;\n\t    if (latestSeq && latestSeq > cache.seq) {\n\t      // invalidate the cache\n\t      cache.seq = latestSeq;\n\t      delete cache.promise;\n\t    }\n\t    callback();\n\t  }).catch(callback);\n\t}\n\t\n\tfunction getDesignDocCache(api, designDocName, callback) {\n\t  api._ddocCache = api._ddocCache || {};\n\t  api._ddocCache[designDocName] = api._ddocCache[designDocName] || {};\n\t  var cache = api._ddocCache[designDocName];\n\t  cacheUpdateRequired(api, cache, designDocName, function(err) {\n\t    if (err) {\n\t      return callback(err);\n\t    }\n\t    if (!cache.promise) {\n\t      cache.promise = new PouchPromise(function (resolve, reject) {\n\t        api._get('_design/' + designDocName, {}, function (err, res) {\n\t          if (err) {\n\t            return reject(err);\n\t          }\n\t          var cache = {};\n\t          ['views', 'filters'].forEach(function(propertyName) {\n\t            cache[propertyName] = res.doc[propertyName];\n\t          });\n\t          resolve(cache);\n\t        });\n\t      });\n\t    }\n\t    cache.promise.then(function(cache) {\n\t      callback(null, cache);\n\t    }).catch(callback);\n\t  });\n\t}\n\t\n\tfunction getDesignDocProperty(api, designDocName, propertyName,\n\t                              propertyElement, callback) {\n\t  getDesignDocCache(api, designDocName, function(err, designDoc) {\n\t    if (err) {\n\t      return callback(err);\n\t    }\n\t    var element = designDoc[propertyName] &&\n\t                  designDoc[propertyName][propertyElement];\n\t    if (!element) {\n\t      return callback(createError(MISSING_DOC));\n\t    }\n\t    callback(null, element);\n\t  });\n\t}\n\t\n\tinherits(AbstractPouchDB, events.EventEmitter);\n\t\n\tfunction AbstractPouchDB() {\n\t  events.EventEmitter.call(this);\n\t}\n\t\n\tAbstractPouchDB.prototype.post =\n\t  adapterFun('post', function (doc, opts, callback) {\n\t  if (typeof opts === 'function') {\n\t    callback = opts;\n\t    opts = {};\n\t  }\n\t  if (typeof doc !== 'object' || Array.isArray(doc)) {\n\t    return callback(createError(NOT_AN_OBJECT));\n\t  }\n\t  this.bulkDocs({docs: [doc]}, opts, yankError(callback));\n\t});\n\t\n\tAbstractPouchDB.prototype.put =\n\t  adapterFun('put', getArguments(function (args) {\n\t  var temp, temptype, opts, callback;\n\t  var doc = args.shift();\n\t  var id = '_id' in doc;\n\t  if (typeof doc !== 'object' || Array.isArray(doc)) {\n\t    callback = args.pop();\n\t    return callback(createError(NOT_AN_OBJECT));\n\t  }\n\t\n\t  /* eslint no-constant-condition: 0 */\n\t  while (true) {\n\t    temp = args.shift();\n\t    temptype = typeof temp;\n\t    if (temptype === \"string\" && !id) {\n\t      doc._id = temp;\n\t      id = true;\n\t    } else if (temptype === \"string\" && id && !('_rev' in doc)) {\n\t      doc._rev = temp;\n\t    } else if (temptype === \"object\") {\n\t      opts = temp;\n\t    } else if (temptype === \"function\") {\n\t      callback = temp;\n\t    }\n\t    if (!args.length) {\n\t      break;\n\t    }\n\t  }\n\t  opts = opts || {};\n\t  invalidIdError(doc._id);\n\t  if (isLocalId(doc._id) && typeof this._putLocal === 'function') {\n\t    if (doc._deleted) {\n\t      return this._removeLocal(doc, callback);\n\t    } else {\n\t      return this._putLocal(doc, callback);\n\t    }\n\t  }\n\t  this.bulkDocs({docs: [doc]}, opts, yankError(callback));\n\t}));\n\t\n\tAbstractPouchDB.prototype.putAttachment =\n\t  adapterFun('putAttachment', function (docId, attachmentId, rev,\n\t                                              blob, type) {\n\t  var api = this;\n\t  if (typeof type === 'function') {\n\t    type = blob;\n\t    blob = rev;\n\t    rev = null;\n\t  }\n\t  // Lets fix in https://github.com/pouchdb/pouchdb/issues/3267\n\t  /* istanbul ignore if */\n\t  if (typeof type === 'undefined') {\n\t    type = blob;\n\t    blob = rev;\n\t    rev = null;\n\t  }\n\t\n\t  function createAttachment(doc) {\n\t    doc._attachments = doc._attachments || {};\n\t    doc._attachments[attachmentId] = {\n\t      content_type: type,\n\t      data: blob\n\t    };\n\t    return api.put(doc);\n\t  }\n\t\n\t  return api.get(docId).then(function (doc) {\n\t    if (doc._rev !== rev) {\n\t      throw createError(REV_CONFLICT);\n\t    }\n\t\n\t    return createAttachment(doc);\n\t  }, function (err) {\n\t     // create new doc\n\t    /* istanbul ignore else */\n\t    if (err.reason === MISSING_DOC.message) {\n\t      return createAttachment({_id: docId});\n\t    } else {\n\t      throw err;\n\t    }\n\t  });\n\t});\n\t\n\tAbstractPouchDB.prototype.removeAttachment =\n\t  adapterFun('removeAttachment', function (docId, attachmentId, rev,\n\t                                                 callback) {\n\t  var self = this;\n\t  self.get(docId, function (err, obj) {\n\t    /* istanbul ignore if */\n\t    if (err) {\n\t      callback(err);\n\t      return;\n\t    }\n\t    if (obj._rev !== rev) {\n\t      callback(createError(REV_CONFLICT));\n\t      return;\n\t    }\n\t    /* istanbul ignore if */\n\t    if (!obj._attachments) {\n\t      return callback();\n\t    }\n\t    delete obj._attachments[attachmentId];\n\t    if (Object.keys(obj._attachments).length === 0) {\n\t      delete obj._attachments;\n\t    }\n\t    self.put(obj, callback);\n\t  });\n\t});\n\t\n\tAbstractPouchDB.prototype.remove =\n\t  adapterFun('remove', function (docOrId, optsOrRev, opts, callback) {\n\t  var doc;\n\t  if (typeof optsOrRev === 'string') {\n\t    // id, rev, opts, callback style\n\t    doc = {\n\t      _id: docOrId,\n\t      _rev: optsOrRev\n\t    };\n\t    if (typeof opts === 'function') {\n\t      callback = opts;\n\t      opts = {};\n\t    }\n\t  } else {\n\t    // doc, opts, callback style\n\t    doc = docOrId;\n\t    if (typeof optsOrRev === 'function') {\n\t      callback = optsOrRev;\n\t      opts = {};\n\t    } else {\n\t      callback = opts;\n\t      opts = optsOrRev;\n\t    }\n\t  }\n\t  opts = opts || {};\n\t  opts.was_delete = true;\n\t  var newDoc = {_id: doc._id, _rev: (doc._rev || opts.rev)};\n\t  newDoc._deleted = true;\n\t  if (isLocalId(newDoc._id) && typeof this._removeLocal === 'function') {\n\t    return this._removeLocal(doc, callback);\n\t  }\n\t  this.bulkDocs({docs: [newDoc]}, opts, yankError(callback));\n\t});\n\t\n\tAbstractPouchDB.prototype.revsDiff =\n\t  adapterFun('revsDiff', function (req, opts, callback) {\n\t  if (typeof opts === 'function') {\n\t    callback = opts;\n\t    opts = {};\n\t  }\n\t  var ids = Object.keys(req);\n\t\n\t  if (!ids.length) {\n\t    return callback(null, {});\n\t  }\n\t\n\t  var count = 0;\n\t  var missing = new pouchdbCollections.Map();\n\t\n\t  function addToMissing(id, revId) {\n\t    if (!missing.has(id)) {\n\t      missing.set(id, {missing: []});\n\t    }\n\t    missing.get(id).missing.push(revId);\n\t  }\n\t\n\t  function processDoc(id, rev_tree) {\n\t    // Is this fast enough? Maybe we should switch to a set simulated by a map\n\t    var missingForId = req[id].slice(0);\n\t    traverseRevTree(rev_tree, function (isLeaf, pos, revHash, ctx,\n\t      opts) {\n\t        var rev = pos + '-' + revHash;\n\t        var idx = missingForId.indexOf(rev);\n\t        if (idx === -1) {\n\t          return;\n\t        }\n\t\n\t        missingForId.splice(idx, 1);\n\t        /* istanbul ignore if */\n\t        if (opts.status !== 'available') {\n\t          addToMissing(id, rev);\n\t        }\n\t      });\n\t\n\t    // Traversing the tree is synchronous, so now `missingForId` contains\n\t    // revisions that were not found in the tree\n\t    missingForId.forEach(function (rev) {\n\t      addToMissing(id, rev);\n\t    });\n\t  }\n\t\n\t  ids.map(function (id) {\n\t    this._getRevisionTree(id, function (err, rev_tree) {\n\t      if (err && err.status === 404 && err.message === 'missing') {\n\t        missing.set(id, {missing: req[id]});\n\t      } else if (err) {\n\t        /* istanbul ignore next */\n\t        return callback(err);\n\t      } else {\n\t        processDoc(id, rev_tree);\n\t      }\n\t\n\t      if (++count === ids.length) {\n\t        // convert LazyMap to object\n\t        var missingObj = {};\n\t        missing.forEach(function (value, key) {\n\t          missingObj[key] = value;\n\t        });\n\t        return callback(null, missingObj);\n\t      }\n\t    });\n\t  }, this);\n\t});\n\t\n\t// _bulk_get API for faster replication, as described in\n\t// https://github.com/apache/couchdb-chttpd/pull/33\n\t// At the \"abstract\" level, it will just run multiple get()s in\n\t// parallel, because this isn't much of a performance cost\n\t// for local databases (except the cost of multiple transactions, which is\n\t// small). The http adapter overrides this in order\n\t// to do a more efficient single HTTP request.\n\tAbstractPouchDB.prototype.bulkGet =\n\t  adapterFun('bulkGet', function (opts, callback) {\n\t  bulkGet(this, opts, callback);\n\t});\n\t\n\t// compact one document and fire callback\n\t// by compacting we mean removing all revisions which\n\t// are further from the leaf in revision tree than max_height\n\tAbstractPouchDB.prototype.compactDocument =\n\t  adapterFun('compactDocument', function (docId, maxHeight, callback) {\n\t  var self = this;\n\t  this._getRevisionTree(docId, function (err, revTree) {\n\t    /* istanbul ignore if */\n\t    if (err) {\n\t      return callback(err);\n\t    }\n\t    var height = computeHeight(revTree);\n\t    var candidates = [];\n\t    var revs = [];\n\t    Object.keys(height).forEach(function (rev) {\n\t      if (height[rev] > maxHeight) {\n\t        candidates.push(rev);\n\t      }\n\t    });\n\t\n\t    traverseRevTree(revTree, function (isLeaf, pos, revHash, ctx, opts) {\n\t      var rev = pos + '-' + revHash;\n\t      if (opts.status === 'available' && candidates.indexOf(rev) !== -1) {\n\t        revs.push(rev);\n\t      }\n\t    });\n\t    self._doCompaction(docId, revs, callback);\n\t  });\n\t});\n\t\n\t// compact the whole database using single document\n\t// compaction\n\tAbstractPouchDB.prototype.compact =\n\t  adapterFun('compact', function (opts, callback) {\n\t  if (typeof opts === 'function') {\n\t    callback = opts;\n\t    opts = {};\n\t  }\n\t\n\t  var self = this;\n\t  opts = opts || {};\n\t\n\t  self._compactionQueue = self._compactionQueue || [];\n\t  self._compactionQueue.push({opts: opts, callback: callback});\n\t  if (self._compactionQueue.length === 1) {\n\t    doNextCompaction(self);\n\t  }\n\t});\n\tAbstractPouchDB.prototype._compact = function (opts, callback) {\n\t  var self = this;\n\t  var changesOpts = {\n\t    return_docs: false,\n\t    last_seq: opts.last_seq || 0\n\t  };\n\t  var promises = [];\n\t\n\t  function onChange(row) {\n\t    promises.push(self.compactDocument(row.id, 0));\n\t  }\n\t  function onComplete(resp) {\n\t    var lastSeq = resp.last_seq;\n\t    PouchPromise.all(promises).then(function () {\n\t      return upsert(self, '_local/compaction', function deltaFunc(doc) {\n\t        if (!doc.last_seq || doc.last_seq < lastSeq) {\n\t          doc.last_seq = lastSeq;\n\t          return doc;\n\t        }\n\t        return false; // somebody else got here first, don't update\n\t      });\n\t    }).then(function () {\n\t      callback(null, {ok: true});\n\t    }).catch(callback);\n\t  }\n\t  self.changes(changesOpts)\n\t    .on('change', onChange)\n\t    .on('complete', onComplete)\n\t    .on('error', callback);\n\t};\n\t/* Begin api wrappers. Specific functionality to storage belongs in the\n\t   _[method] */\n\tAbstractPouchDB.prototype.get =\n\t  adapterFun('get', function (id, opts, callback) {\n\t  if (typeof opts === 'function') {\n\t    callback = opts;\n\t    opts = {};\n\t  }\n\t  if (typeof id !== 'string') {\n\t    return callback(createError(INVALID_ID));\n\t  }\n\t  if (isLocalId(id) && typeof this._getLocal === 'function') {\n\t    return this._getLocal(id, callback);\n\t  }\n\t  var leaves = [], self = this;\n\t\n\t  function finishOpenRevs() {\n\t    var result = [];\n\t    var count = leaves.length;\n\t    /* istanbul ignore if */\n\t    if (!count) {\n\t      return callback(null, result);\n\t    }\n\t    // order with open_revs is unspecified\n\t    leaves.forEach(function (leaf) {\n\t      self.get(id, {\n\t        rev: leaf,\n\t        revs: opts.revs,\n\t        attachments: opts.attachments\n\t      }, function (err, doc) {\n\t        if (!err) {\n\t          result.push({ok: doc});\n\t        } else {\n\t          result.push({missing: leaf});\n\t        }\n\t        count--;\n\t        if (!count) {\n\t          callback(null, result);\n\t        }\n\t      });\n\t    });\n\t  }\n\t\n\t  if (opts.open_revs) {\n\t    if (opts.open_revs === \"all\") {\n\t      this._getRevisionTree(id, function (err, rev_tree) {\n\t        if (err) {\n\t          return callback(err);\n\t        }\n\t        leaves = collectLeaves(rev_tree).map(function (leaf) {\n\t          return leaf.rev;\n\t        });\n\t        finishOpenRevs();\n\t      });\n\t    } else {\n\t      if (Array.isArray(opts.open_revs)) {\n\t        leaves = opts.open_revs;\n\t        for (var i = 0; i < leaves.length; i++) {\n\t          var l = leaves[i];\n\t          // looks like it's the only thing couchdb checks\n\t          if (!(typeof(l) === \"string\" && /^\\d+-/.test(l))) {\n\t            return callback(createError(INVALID_REV));\n\t          }\n\t        }\n\t        finishOpenRevs();\n\t      } else {\n\t        return callback(createError(UNKNOWN_ERROR,\n\t          'function_clause'));\n\t      }\n\t    }\n\t    return; // open_revs does not like other options\n\t  }\n\t\n\t  return this._get(id, opts, function (err, result) {\n\t    if (err) {\n\t      return callback(err);\n\t    }\n\t\n\t    var doc = result.doc;\n\t    var metadata = result.metadata;\n\t    var ctx = result.ctx;\n\t\n\t    if (opts.conflicts) {\n\t      var conflicts = collectConflicts(metadata);\n\t      if (conflicts.length) {\n\t        doc._conflicts = conflicts;\n\t      }\n\t    }\n\t\n\t    if (isDeleted(metadata, doc._rev)) {\n\t      doc._deleted = true;\n\t    }\n\t\n\t    if (opts.revs || opts.revs_info) {\n\t      var paths = rootToLeaf(metadata.rev_tree);\n\t      var path = arrayFirst(paths, function (arr) {\n\t        return arr.ids.map(function (x) { return x.id; })\n\t          .indexOf(doc._rev.split('-')[1]) !== -1;\n\t      });\n\t\n\t      var indexOfRev = path.ids.map(function (x) {return x.id; })\n\t        .indexOf(doc._rev.split('-')[1]) + 1;\n\t      var howMany = path.ids.length - indexOfRev;\n\t      path.ids.splice(indexOfRev, howMany);\n\t      path.ids.reverse();\n\t\n\t      if (opts.revs) {\n\t        doc._revisions = {\n\t          start: (path.pos + path.ids.length) - 1,\n\t          ids: path.ids.map(function (rev) {\n\t            return rev.id;\n\t          })\n\t        };\n\t      }\n\t      if (opts.revs_info) {\n\t        var pos =  path.pos + path.ids.length;\n\t        doc._revs_info = path.ids.map(function (rev) {\n\t          pos--;\n\t          return {\n\t            rev: pos + '-' + rev.id,\n\t            status: rev.opts.status\n\t          };\n\t        });\n\t      }\n\t    }\n\t\n\t    if (opts.attachments && doc._attachments) {\n\t      var attachments = doc._attachments;\n\t      var count = Object.keys(attachments).length;\n\t      if (count === 0) {\n\t        return callback(null, doc);\n\t      }\n\t      Object.keys(attachments).forEach(function (key) {\n\t        this._getAttachment(attachments[key], {\n\t          binary: opts.binary,\n\t          ctx: ctx\n\t        }, function (err, data) {\n\t          var att = doc._attachments[key];\n\t          att.data = data;\n\t          delete att.stub;\n\t          delete att.length;\n\t          if (!--count) {\n\t            callback(null, doc);\n\t          }\n\t        });\n\t      }, self);\n\t    } else {\n\t      if (doc._attachments) {\n\t        for (var key in doc._attachments) {\n\t          /* istanbul ignore else */\n\t          if (doc._attachments.hasOwnProperty(key)) {\n\t            doc._attachments[key].stub = true;\n\t          }\n\t        }\n\t      }\n\t      callback(null, doc);\n\t    }\n\t  });\n\t});\n\t\n\tAbstractPouchDB.prototype.getView =\n\t  adapterFun('getView', function (designDocName, viewName, callback) {\n\t  getDesignDocProperty(this, designDocName, 'views', viewName, callback);\n\t});\n\t\n\tAbstractPouchDB.prototype.getFilter =\n\t  adapterFun('getFilter', function (designDocName, filterName, callback) {\n\t  getDesignDocProperty(this, designDocName, 'filters', filterName, callback);\n\t});\n\t\n\tAbstractPouchDB.prototype.getAttachment =\n\t  adapterFun('getAttachment', function (docId, attachmentId, opts,\n\t                                              callback) {\n\t  var self = this;\n\t  if (opts instanceof Function) {\n\t    callback = opts;\n\t    opts = {};\n\t  }\n\t  this._get(docId, opts, function (err, res) {\n\t    if (err) {\n\t      return callback(err);\n\t    }\n\t    if (res.doc._attachments && res.doc._attachments[attachmentId]) {\n\t      opts.ctx = res.ctx;\n\t      opts.binary = true;\n\t      self._getAttachment(res.doc._attachments[attachmentId], opts, callback);\n\t    } else {\n\t      return callback(createError(MISSING_DOC));\n\t    }\n\t  });\n\t});\n\t\n\tAbstractPouchDB.prototype.allDocs =\n\t  adapterFun('allDocs', function (opts, callback) {\n\t  if (typeof opts === 'function') {\n\t    callback = opts;\n\t    opts = {};\n\t  }\n\t  opts.skip = typeof opts.skip !== 'undefined' ? opts.skip : 0;\n\t  if (opts.start_key) {\n\t    opts.startkey = opts.start_key;\n\t  }\n\t  if (opts.end_key) {\n\t    opts.endkey = opts.end_key;\n\t  }\n\t  if ('keys' in opts) {\n\t    if (!Array.isArray(opts.keys)) {\n\t      return callback(new TypeError('options.keys must be an array'));\n\t    }\n\t    var incompatibleOpt =\n\t      ['startkey', 'endkey', 'key'].filter(function (incompatibleOpt) {\n\t      return incompatibleOpt in opts;\n\t    })[0];\n\t    if (incompatibleOpt) {\n\t      callback(createError(QUERY_PARSE_ERROR,\n\t        'Query parameter `' + incompatibleOpt +\n\t        '` is not compatible with multi-get'\n\t      ));\n\t      return;\n\t    }\n\t    if (this.type() !== 'http') {\n\t      return allDocsKeysQuery(this, opts, callback);\n\t    }\n\t  }\n\t\n\t  return this._allDocs(opts, callback);\n\t});\n\t\n\tAbstractPouchDB.prototype.changes = function (opts, callback) {\n\t  if (typeof opts === 'function') {\n\t    callback = opts;\n\t    opts = {};\n\t  }\n\t  return new Changes(this, opts, callback);\n\t};\n\t\n\tAbstractPouchDB.prototype.close =\n\t  adapterFun('close', function (callback) {\n\t  this._closed = true;\n\t  return this._close(callback);\n\t});\n\t\n\tAbstractPouchDB.prototype.info = adapterFun('info', function (callback) {\n\t  var self = this;\n\t  this._info(function (err, info) {\n\t    if (err) {\n\t      return callback(err);\n\t    }\n\t    // assume we know better than the adapter, unless it informs us\n\t    info.db_name = info.db_name || self._db_name;\n\t    info.auto_compaction = !!(self.auto_compaction && self.type() !== 'http');\n\t    info.adapter = self.type();\n\t    callback(null, info);\n\t  });\n\t});\n\t\n\tAbstractPouchDB.prototype.id = adapterFun('id', function (callback) {\n\t  return this._id(callback);\n\t});\n\t\n\tAbstractPouchDB.prototype.type = function () {\n\t  /* istanbul ignore next */\n\t  return (typeof this._type === 'function') ? this._type() : this.adapter;\n\t};\n\t\n\tAbstractPouchDB.prototype.bulkDocs =\n\t  adapterFun('bulkDocs', function (req, opts, callback) {\n\t  if (typeof opts === 'function') {\n\t    callback = opts;\n\t    opts = {};\n\t  }\n\t\n\t  opts = opts || {};\n\t\n\t  if (Array.isArray(req)) {\n\t    req = {\n\t      docs: req\n\t    };\n\t  }\n\t\n\t  if (!req || !req.docs || !Array.isArray(req.docs)) {\n\t    return callback(createError(MISSING_BULK_DOCS));\n\t  }\n\t\n\t  for (var i = 0; i < req.docs.length; ++i) {\n\t    if (typeof req.docs[i] !== 'object' || Array.isArray(req.docs[i])) {\n\t      return callback(createError(NOT_AN_OBJECT));\n\t    }\n\t  }\n\t\n\t  var attachmentError;\n\t  req.docs.forEach(function(doc) {\n\t    if (doc._attachments) {\n\t      Object.keys(doc._attachments).forEach(function (name) {\n\t        attachmentError = attachmentError || attachmentNameError(name);\n\t      });\n\t    }\n\t  });\n\t\n\t  if (attachmentError) {\n\t    return callback(createError(BAD_REQUEST, attachmentError));\n\t  }\n\t\n\t  if (!('new_edits' in opts)) {\n\t    if ('new_edits' in req) {\n\t      opts.new_edits = req.new_edits;\n\t    } else {\n\t      opts.new_edits = true;\n\t    }\n\t  }\n\t\n\t  if (!opts.new_edits && this.type() !== 'http') {\n\t    // ensure revisions of the same doc are sorted, so that\n\t    // the local adapter processes them correctly (#2935)\n\t    req.docs.sort(compareByIdThenRev);\n\t  }\n\t\n\t  cleanDocs(req.docs);\n\t\n\t  return this._bulkDocs(req, opts, function (err, res) {\n\t    if (err) {\n\t      return callback(err);\n\t    }\n\t    if (!opts.new_edits) {\n\t      // this is what couch does when new_edits is false\n\t      res = res.filter(function (x) {\n\t        return x.error;\n\t      });\n\t    }\n\t    callback(null, res);\n\t  });\n\t});\n\t\n\tAbstractPouchDB.prototype.registerDependentDatabase =\n\t  adapterFun('registerDependentDatabase', function (dependentDb,\n\t                                                          callback) {\n\t  var depDB = new this.constructor(dependentDb, this.__opts);\n\t\n\t  function diffFun(doc) {\n\t    doc.dependentDbs = doc.dependentDbs || {};\n\t    if (doc.dependentDbs[dependentDb]) {\n\t      return false; // no update required\n\t    }\n\t    doc.dependentDbs[dependentDb] = true;\n\t    return doc;\n\t  }\n\t  upsert(this, '_local/_pouch_dependentDbs', diffFun)\n\t    .then(function () {\n\t      callback(null, {db: depDB});\n\t    }).catch(callback);\n\t});\n\t\n\tAbstractPouchDB.prototype.destroy =\n\t  adapterFun('destroy', function (opts, callback) {\n\t\n\t  if (typeof opts === 'function') {\n\t    callback = opts;\n\t    opts = {};\n\t  }\n\t\n\t  var self = this;\n\t  var usePrefix = 'use_prefix' in self ? self.use_prefix : true;\n\t\n\t  function destroyDb() {\n\t    // call destroy method of the particular adaptor\n\t    self._destroy(opts, function (err, resp) {\n\t      if (err) {\n\t        return callback(err);\n\t      }\n\t      self._destroyed = true;\n\t      self.emit('destroyed');\n\t      callback(null, resp || { 'ok': true });\n\t    });\n\t  }\n\t\n\t  if (self.type() === 'http') {\n\t    // no need to check for dependent DBs if it's a remote DB\n\t    return destroyDb();\n\t  }\n\t\n\t  self.get('_local/_pouch_dependentDbs', function (err, localDoc) {\n\t    if (err) {\n\t      /* istanbul ignore if */\n\t      if (err.status !== 404) {\n\t        return callback(err);\n\t      } else { // no dependencies\n\t        return destroyDb();\n\t      }\n\t    }\n\t    var dependentDbs = localDoc.dependentDbs;\n\t    var PouchDB = self.constructor;\n\t    var deletedMap = Object.keys(dependentDbs).map(function (name) {\n\t      // use_prefix is only false in the browser\n\t      /* istanbul ignore next */\n\t      var trueName = usePrefix ?\n\t        name.replace(new RegExp('^' + PouchDB.prefix), '') : name;\n\t      return new PouchDB(trueName, self.__opts).destroy();\n\t    });\n\t    PouchPromise.all(deletedMap).then(destroyDb, callback);\n\t  });\n\t});\n\t\n\tfunction TaskQueue() {\n\t  this.isReady = false;\n\t  this.failed = false;\n\t  this.queue = [];\n\t}\n\t\n\tTaskQueue.prototype.execute = function () {\n\t  var fun;\n\t  if (this.failed) {\n\t    while ((fun = this.queue.shift())) {\n\t      fun(this.failed);\n\t    }\n\t  } else {\n\t    while ((fun = this.queue.shift())) {\n\t      fun();\n\t    }\n\t  }\n\t};\n\t\n\tTaskQueue.prototype.fail = function (err) {\n\t  this.failed = err;\n\t  this.execute();\n\t};\n\t\n\tTaskQueue.prototype.ready = function (db) {\n\t  this.isReady = true;\n\t  this.db = db;\n\t  this.execute();\n\t};\n\t\n\tTaskQueue.prototype.addTask = function (fun) {\n\t  this.queue.push(fun);\n\t  if (this.failed) {\n\t    this.execute();\n\t  }\n\t};\n\t\n\tfunction defaultCallback(err) {\n\t  /* istanbul ignore next */\n\t  if (err && global.debug) {\n\t    console.error(err);\n\t  }\n\t}\n\t\n\t// OK, so here's the deal. Consider this code:\n\t//     var db1 = new PouchDB('foo');\n\t//     var db2 = new PouchDB('foo');\n\t//     db1.destroy();\n\t// ^ these two both need to emit 'destroyed' events,\n\t// as well as the PouchDB constructor itself.\n\t// So we have one db object (whichever one got destroy() called on it)\n\t// responsible for emitting the initial event, which then gets emitted\n\t// by the constructor, which then broadcasts it to any other dbs\n\t// that may have been created with the same name.\n\tfunction prepareForDestruction(self, opts) {\n\t  var name = opts.originalName;\n\t  var ctor = self.constructor;\n\t  var destructionListeners = ctor._destructionListeners;\n\t\n\t  function onDestroyed() {\n\t    ctor.emit('destroyed', name);\n\t  }\n\t\n\t  function onConstructorDestroyed() {\n\t    self.removeListener('destroyed', onDestroyed);\n\t    self.emit('destroyed', self);\n\t  }\n\t\n\t  self.once('destroyed', onDestroyed);\n\t\n\t  // in setup.js, the constructor is primed to listen for destroy events\n\t  if (!destructionListeners.has(name)) {\n\t    destructionListeners.set(name, []);\n\t  }\n\t  destructionListeners.get(name).push(onConstructorDestroyed);\n\t}\n\t\n\tinherits(PouchDB, AbstractPouchDB);\n\tfunction PouchDB(name, opts, callback) {\n\t\n\t  if (!(this instanceof PouchDB)) {\n\t    return new PouchDB(name, opts, callback);\n\t  }\n\t  var self = this;\n\t  if (typeof opts === 'function' || typeof opts === 'undefined') {\n\t    callback = opts;\n\t    opts = {};\n\t  }\n\t\n\t  if (name && typeof name === 'object') {\n\t    opts = name;\n\t    name = undefined;\n\t  }\n\t  if (typeof callback === 'undefined') {\n\t    callback = defaultCallback;\n\t  }\n\t  name = name || opts.name;\n\t  opts = clone(opts);\n\t  // if name was specified via opts, ignore for the sake of dependentDbs\n\t  delete opts.name;\n\t  this.__opts = opts;\n\t  var oldCB = callback;\n\t  self.auto_compaction = opts.auto_compaction;\n\t  self.prefix = PouchDB.prefix;\n\t  AbstractPouchDB.call(self);\n\t  self.taskqueue = new TaskQueue();\n\t  var promise = new PouchPromise(function (fulfill, reject) {\n\t    callback = function (err, resp) {\n\t      /* istanbul ignore if */\n\t      if (err) {\n\t        return reject(err);\n\t      }\n\t      delete resp.then;\n\t      fulfill(resp);\n\t    };\n\t  \n\t    opts = clone(opts);\n\t    var originalName = opts.name || name;\n\t    var backend, error;\n\t    (function () {\n\t      try {\n\t\n\t        if (typeof originalName !== 'string') {\n\t          error = new Error('Missing/invalid DB name');\n\t          error.code = 400;\n\t          throw error;\n\t        }\n\t\n\t        backend = PouchDB.parseAdapter(originalName, opts);\n\t        \n\t        opts.originalName = originalName;\n\t        opts.name = backend.name;\n\t        if (opts.prefix && backend.adapter !== 'http' &&\n\t            backend.adapter !== 'https') {\n\t          opts.name = opts.prefix + opts.name;\n\t        }\n\t        opts.adapter = opts.adapter || backend.adapter;\n\t        self._adapter = opts.adapter;\n\t        debug('pouchdb:adapter')('Picked adapter: ' + opts.adapter);\n\t\n\t        self._db_name = originalName;\n\t        if (!PouchDB.adapters[opts.adapter]) {\n\t          error = new Error('Adapter is missing');\n\t          error.code = 404;\n\t          throw error;\n\t        }\n\t\n\t        /* istanbul ignore if */\n\t        if (!PouchDB.adapters[opts.adapter].valid()) {\n\t          error = new Error('Invalid Adapter');\n\t          error.code = 404;\n\t          throw error;\n\t        }\n\t      } catch (err) {\n\t        self.taskqueue.fail(err);\n\t      }\n\t    }());\n\t    if (error) {\n\t      return reject(error); // constructor error, see above\n\t    }\n\t    self.adapter = opts.adapter;\n\t\n\t    // needs access to PouchDB;\n\t    self.replicate = {};\n\t\n\t    self.replicate.from = function (url, opts, callback) {\n\t      return self.constructor.replicate(url, self, opts, callback);\n\t    };\n\t\n\t    self.replicate.to = function (url, opts, callback) {\n\t      return self.constructor.replicate(self, url, opts, callback);\n\t    };\n\t\n\t    self.sync = function (dbName, opts, callback) {\n\t      return self.constructor.sync(self, dbName, opts, callback);\n\t    };\n\t\n\t    self.replicate.sync = self.sync;\n\t\n\t    PouchDB.adapters[opts.adapter].call(self, opts, function (err) {\n\t      /* istanbul ignore if */\n\t      if (err) {\n\t        self.taskqueue.fail(err);\n\t        callback(err);\n\t        return;\n\t      }\n\t      prepareForDestruction(self, opts);\n\t\n\t      self.emit('created', self);\n\t      PouchDB.emit('created', opts.originalName);\n\t      self.taskqueue.ready(self);\n\t      callback(null, self);\n\t    });\n\t\n\t  });\n\t  promise.then(function (resp) {\n\t    oldCB(null, resp);\n\t  }, oldCB);\n\t  self.then = promise.then.bind(promise);\n\t  self.catch = promise.catch.bind(promise);\n\t}\n\t\n\tPouchDB.debug = debug;\n\t\n\tfunction isChromeApp() {\n\t  return (typeof chrome !== \"undefined\" &&\n\t    typeof chrome.storage !== \"undefined\" &&\n\t    typeof chrome.storage.local !== \"undefined\");\n\t}\n\t\n\tvar hasLocal;\n\t\n\tif (isChromeApp()) {\n\t  hasLocal = false;\n\t} else {\n\t  try {\n\t    localStorage.setItem('_pouch_check_localstorage', 1);\n\t    hasLocal = !!localStorage.getItem('_pouch_check_localstorage');\n\t  } catch (e) {\n\t    hasLocal = false;\n\t  }\n\t}\n\t\n\tfunction hasLocalStorage() {\n\t  return hasLocal;\n\t}\n\t\n\tPouchDB.adapters = {};\n\tPouchDB.preferredAdapters = [];\n\t\n\tPouchDB.prefix = '_pouch_';\n\t\n\tvar eventEmitter = new events.EventEmitter();\n\t\n\tfunction setUpEventEmitter(Pouch) {\n\t  Object.keys(events.EventEmitter.prototype).forEach(function (key) {\n\t    if (typeof events.EventEmitter.prototype[key] === 'function') {\n\t      Pouch[key] = eventEmitter[key].bind(eventEmitter);\n\t    }\n\t  });\n\t\n\t  // these are created in constructor.js, and allow us to notify each DB with\n\t  // the same name that it was destroyed, via the constructor object\n\t  var destructListeners = Pouch._destructionListeners = new pouchdbCollections.Map();\n\t  Pouch.on('destroyed', function onConstructorDestroyed(name) {\n\t    if (!destructListeners.has(name)) {\n\t      return;\n\t    }\n\t    destructListeners.get(name).forEach(function (callback) {\n\t      callback();\n\t    });\n\t    destructListeners.delete(name);\n\t  });\n\t}\n\t\n\tsetUpEventEmitter(PouchDB);\n\t\n\tPouchDB.parseAdapter = function (name, opts) {\n\t  var match = name.match(/([a-z\\-]*):\\/\\/(.*)/);\n\t  var adapter, adapterName;\n\t  if (match) {\n\t    // the http adapter expects the fully qualified name\n\t    name = /http(s?)/.test(match[1]) ? match[1] + '://' + match[2] : match[2];\n\t    adapter = match[1];\n\t    /* istanbul ignore if */\n\t    if (!PouchDB.adapters[adapter].valid()) {\n\t      throw 'Invalid adapter';\n\t    }\n\t    return {name: name, adapter: match[1]};\n\t  }\n\t\n\t  // check for browsers that have been upgraded from websql-only to websql+idb\n\t  var skipIdb = 'idb' in PouchDB.adapters && 'websql' in PouchDB.adapters &&\n\t    hasLocalStorage() &&\n\t    localStorage['_pouch__websqldb_' + PouchDB.prefix + name];\n\t\n\t\n\t  if (opts.adapter) {\n\t    adapterName = opts.adapter;\n\t  } else if (typeof opts !== 'undefined' && opts.db) {\n\t    adapterName = 'leveldb';\n\t  } else { // automatically determine adapter\n\t    for (var i = 0; i < PouchDB.preferredAdapters.length; ++i) {\n\t      adapterName = PouchDB.preferredAdapters[i];\n\t      if (adapterName in PouchDB.adapters) {\n\t        /* istanbul ignore if */\n\t        if (skipIdb && adapterName === 'idb') {\n\t          // log it, because this can be confusing during development\n\t          console.log('PouchDB is downgrading \"' + name + '\" to WebSQL to' +\n\t            ' avoid data loss, because it was already opened with WebSQL.');\n\t          continue; // keep using websql to avoid user data loss\n\t        }\n\t        break;\n\t      }\n\t    }\n\t  }\n\t\n\t  adapter = PouchDB.adapters[adapterName];\n\t\n\t  // if adapter is invalid, then an error will be thrown later\n\t  var usePrefix = (adapter && 'use_prefix' in adapter) ?\n\t      adapter.use_prefix : true;\n\t\n\t  return {\n\t    name: usePrefix ? (PouchDB.prefix + name) : name,\n\t    adapter: adapterName\n\t  };\n\t};\n\t\n\tPouchDB.adapter = function (id, obj, addToPreferredAdapters) {\n\t  if (obj.valid()) {\n\t    PouchDB.adapters[id] = obj;\n\t    if (addToPreferredAdapters) {\n\t      PouchDB.preferredAdapters.push(id);\n\t    }\n\t  }\n\t};\n\t\n\tPouchDB.plugin = function (obj) {\n\t  Object.keys(obj).forEach(function (id) {\n\t    PouchDB.prototype[id] = obj[id];\n\t  });\n\t\n\t  return PouchDB;\n\t};\n\t\n\tPouchDB.defaults = function (defaultOpts) {\n\t  function PouchAlt(name, opts, callback) {\n\t    if (!(this instanceof PouchAlt)) {\n\t      return new PouchAlt(name, opts, callback);\n\t    }\n\t\n\t    if (typeof opts === 'function' || typeof opts === 'undefined') {\n\t      callback = opts;\n\t      opts = {};\n\t    }\n\t    if (name && typeof name === 'object') {\n\t      opts = name;\n\t      name = undefined;\n\t    }\n\t\n\t    opts = jsExtend.extend({}, defaultOpts, opts);\n\t    PouchDB.call(this, name, opts, callback);\n\t  }\n\t\n\t  inherits(PouchAlt, PouchDB);\n\t\n\t  setUpEventEmitter(PouchAlt);\n\t\n\t  PouchAlt.preferredAdapters = PouchDB.preferredAdapters.slice();\n\t  Object.keys(PouchDB).forEach(function (key) {\n\t    if (!(key in PouchAlt)) {\n\t      PouchAlt[key] = PouchDB[key];\n\t    }\n\t  });\n\t\n\t  return PouchAlt;\n\t};\n\t\n\t// Abstracts constructing a Blob object, so it also works in older\n\t// browsers that don't support the native Blob constructor (e.g.\n\t// old QtWebKit versions, Android < 4.4).\n\tfunction createBlob(parts, properties) {\n\t  /* global BlobBuilder,MSBlobBuilder,MozBlobBuilder,WebKitBlobBuilder */\n\t  parts = parts || [];\n\t  properties = properties || {};\n\t  try {\n\t    return new Blob(parts, properties);\n\t  } catch (e) {\n\t    if (e.name !== \"TypeError\") {\n\t      throw e;\n\t    }\n\t    var Builder = typeof BlobBuilder !== 'undefined' ? BlobBuilder :\n\t                  typeof MSBlobBuilder !== 'undefined' ? MSBlobBuilder :\n\t                  typeof MozBlobBuilder !== 'undefined' ? MozBlobBuilder :\n\t                  WebKitBlobBuilder;\n\t    var builder = new Builder();\n\t    for (var i = 0; i < parts.length; i += 1) {\n\t      builder.append(parts[i]);\n\t    }\n\t    return builder.getBlob(properties.type);\n\t  }\n\t}\n\t\n\t// simplified API. universal browser support is assumed\n\tfunction readAsArrayBuffer(blob, callback) {\n\t  if (typeof FileReader === 'undefined') {\n\t    // fix for Firefox in a web worker:\n\t    // https://bugzilla.mozilla.org/show_bug.cgi?id=901097\n\t    return callback(new FileReaderSync().readAsArrayBuffer(blob));\n\t  }\n\t\n\t  var reader = new FileReader();\n\t  reader.onloadend = function (e) {\n\t    var result = e.target.result || new ArrayBuffer(0);\n\t    callback(result);\n\t  };\n\t  reader.readAsArrayBuffer(blob);\n\t}\n\t\n\tfunction wrappedFetch() {\n\t  var wrappedPromise = {};\n\t\n\t  var promise = new PouchPromise(function(resolve, reject) {\n\t    wrappedPromise.resolve = resolve;\n\t    wrappedPromise.reject = reject;\n\t  });\n\t\n\t  var args = new Array(arguments.length);\n\t\n\t  for (var i = 0; i < args.length; i++) {\n\t    args[i] = arguments[i];\n\t  }\n\t\n\t  wrappedPromise.promise = promise;\n\t\n\t  PouchPromise.resolve().then(function () {\n\t    return fetch.apply(null, args);\n\t  }).then(function(response) {\n\t    wrappedPromise.resolve(response);\n\t  }).catch(function(error) {\n\t    wrappedPromise.reject(error);\n\t  });\n\t\n\t  return wrappedPromise;\n\t}\n\t\n\tfunction fetchRequest(options, callback) {\n\t  var wrappedPromise, timer, response;\n\t\n\t  var headers = new Headers();\n\t\n\t  var fetchOptions = {\n\t    method: options.method,\n\t    credentials: 'include',\n\t    headers: headers\n\t  };\n\t\n\t  if (options.json) {\n\t    headers.set('Accept', 'application/json');\n\t    headers.set('Content-Type', options.headers['Content-Type'] ||\n\t      'application/json');\n\t  }\n\t\n\t  if (options.body && (options.body instanceof Blob)) {\n\t    readAsArrayBuffer(options.body, function (arrayBuffer) {\n\t      fetchOptions.body = arrayBuffer;\n\t    });\n\t  } else if (options.body &&\n\t             options.processData &&\n\t             typeof options.body !== 'string') {\n\t    fetchOptions.body = JSON.stringify(options.body);\n\t  } else if ('body' in options) {\n\t    fetchOptions.body = options.body;\n\t  } else {\n\t    fetchOptions.body = null;\n\t  }\n\t\n\t  Object.keys(options.headers).forEach(function(key) {\n\t    if (options.headers.hasOwnProperty(key)) {\n\t      headers.set(key, options.headers[key]);\n\t    }\n\t  });\n\t\n\t  wrappedPromise = wrappedFetch(options.url, fetchOptions);\n\t\n\t  if (options.timeout > 0) {\n\t    timer = setTimeout(function() {\n\t      wrappedPromise.reject(new Error('Load timeout for resource: ' +\n\t        options.url));\n\t    }, options.timeout);\n\t  }\n\t\n\t  wrappedPromise.promise.then(function(fetchResponse) {\n\t    response = {\n\t      statusCode: fetchResponse.status\n\t    };\n\t\n\t    if (options.timeout > 0) {\n\t      clearTimeout(timer);\n\t    }\n\t\n\t    if (response.statusCode >= 200 && response.statusCode < 300) {\n\t      return options.binary ? fetchResponse.blob() : fetchResponse.text();\n\t    }\n\t\n\t    return fetchResponse.json();\n\t  }).then(function(result) {\n\t    if (response.statusCode >= 200 && response.statusCode < 300) {\n\t      callback(null, response, result);\n\t    } else {\n\t      callback(result, response);\n\t    }\n\t  }).catch(function(error) {\n\t    callback(error, response);\n\t  });\n\t\n\t  return {abort: wrappedPromise.reject};\n\t}\n\t\n\tfunction xhRequest(options, callback) {\n\t\n\t  var xhr, timer;\n\t\n\t  var abortReq = function () {\n\t    xhr.abort();\n\t  };\n\t\n\t  if (options.xhr) {\n\t    xhr = new options.xhr();\n\t  } else {\n\t    xhr = new XMLHttpRequest();\n\t  }\n\t\n\t  try {\n\t    xhr.open(options.method, options.url);\n\t  } catch (exception) {\n\t   /* error code hardcoded to throw INVALID_URL */\n\t    callback(exception, {statusCode: 413});\n\t  }\n\t\n\t  xhr.withCredentials = ('withCredentials' in options) ?\n\t    options.withCredentials : true;\n\t\n\t  if (options.method === 'GET') {\n\t    delete options.headers['Content-Type'];\n\t  } else if (options.json) {\n\t    options.headers.Accept = 'application/json';\n\t    options.headers['Content-Type'] = options.headers['Content-Type'] ||\n\t      'application/json';\n\t    if (options.body &&\n\t        options.processData &&\n\t        typeof options.body !== \"string\") {\n\t      options.body = JSON.stringify(options.body);\n\t    }\n\t  }\n\t\n\t  if (options.binary) {\n\t    xhr.responseType = 'arraybuffer';\n\t  }\n\t\n\t  if (!('body' in options)) {\n\t    options.body = null;\n\t  }\n\t\n\t  for (var key in options.headers) {\n\t    if (options.headers.hasOwnProperty(key)) {\n\t      xhr.setRequestHeader(key, options.headers[key]);\n\t    }\n\t  }\n\t\n\t  if (options.timeout > 0) {\n\t    timer = setTimeout(abortReq, options.timeout);\n\t    xhr.onprogress = function () {\n\t      clearTimeout(timer);\n\t      timer = setTimeout(abortReq, options.timeout);\n\t    };\n\t    if (typeof xhr.upload !== 'undefined') { // does not exist in ie9\n\t      xhr.upload.onprogress = xhr.onprogress;\n\t    }\n\t  }\n\t\n\t  xhr.onreadystatechange = function () {\n\t    if (xhr.readyState !== 4) {\n\t      return;\n\t    }\n\t\n\t    var response = {\n\t      statusCode: xhr.status\n\t    };\n\t\n\t    if (xhr.status >= 200 && xhr.status < 300) {\n\t      var data;\n\t      if (options.binary) {\n\t        data = createBlob([xhr.response || ''], {\n\t          type: xhr.getResponseHeader('Content-Type')\n\t        });\n\t      } else {\n\t        data = xhr.responseText;\n\t      }\n\t      callback(null, response, data);\n\t    } else {\n\t      var err = {};\n\t      try {\n\t        err = JSON.parse(xhr.response);\n\t      } catch(e) {}\n\t      callback(err, response);\n\t    }\n\t  };\n\t\n\t  if (options.body && (options.body instanceof Blob)) {\n\t    readAsArrayBuffer(options.body, function (arrayBuffer) {\n\t      xhr.send(arrayBuffer);\n\t    });\n\t  } else {\n\t    xhr.send(options.body);\n\t  }\n\t\n\t  return {abort: abortReq};\n\t}\n\t\n\tfunction testXhr() {\n\t  try {\n\t    new XMLHttpRequest();\n\t    return true;\n\t  } catch (err) {\n\t    return false;\n\t  }\n\t}\n\t\n\tvar hasXhr = testXhr();\n\t\n\tfunction ajax$1(options, callback) {\n\t  if (hasXhr || options.xhr) {\n\t    return xhRequest(options, callback);\n\t  } else {\n\t    return fetchRequest(options, callback);\n\t  }\n\t}\n\t\n\t// the blob already has a type; do nothing\n\tvar res = function () {};\n\t\n\tfunction defaultBody() {\n\t  return '';\n\t}\n\t\n\tfunction ajaxCore(options, callback) {\n\t\n\t  options = clone(options);\n\t\n\t  var defaultOptions = {\n\t    method : \"GET\",\n\t    headers: {},\n\t    json: true,\n\t    processData: true,\n\t    timeout: 10000,\n\t    cache: false\n\t  };\n\t\n\t  options = jsExtend.extend(defaultOptions, options);\n\t\n\t  function onSuccess(obj, resp, cb) {\n\t    if (!options.binary && options.json && typeof obj === 'string') {\n\t      try {\n\t        obj = JSON.parse(obj);\n\t      } catch (e) {\n\t        // Probably a malformed JSON from server\n\t        return cb(e);\n\t      }\n\t    }\n\t    if (Array.isArray(obj)) {\n\t      obj = obj.map(function (v) {\n\t        if (v.error || v.missing) {\n\t          return generateErrorFromResponse(v);\n\t        } else {\n\t          return v;\n\t        }\n\t      });\n\t    }\n\t    if (options.binary) {\n\t      res(obj, resp);\n\t    }\n\t    cb(null, obj, resp);\n\t  }\n\t\n\t  function onError(err, cb) {\n\t    var errParsed, errObj;\n\t    if (err.code && err.status) {\n\t      var err2 = new Error(err.message || err.code);\n\t      err2.status = err.status;\n\t      return cb(err2);\n\t    }\n\t    // We always get code && status in node\n\t    /* istanbul ignore next */\n\t    try {\n\t      errParsed = JSON.parse(err.responseText);\n\t      //would prefer not to have a try/catch clause\n\t      errObj = generateErrorFromResponse(errParsed);\n\t    } catch (e) {\n\t      errObj = generateErrorFromResponse(err);\n\t    }\n\t    /* istanbul ignore next */\n\t    cb(errObj);\n\t  }\n\t\n\t\n\t  if (options.json) {\n\t    if (!options.binary) {\n\t      options.headers.Accept = 'application/json';\n\t    }\n\t    options.headers['Content-Type'] = options.headers['Content-Type'] ||\n\t      'application/json';\n\t  }\n\t\n\t  if (options.binary) {\n\t    options.encoding = null;\n\t    options.json = false;\n\t  }\n\t\n\t  if (!options.processData) {\n\t    options.json = false;\n\t  }\n\t\n\t  return ajax$1(options, function (err, response, body) {\n\t    if (err) {\n\t      err.status = response ? response.statusCode : 400;\n\t      return onError(err, callback);\n\t    }\n\t\n\t    var error;\n\t    var content_type = response.headers && response.headers['content-type'];\n\t    var data = body || defaultBody();\n\t\n\t    // CouchDB doesn't always return the right content-type for JSON data, so\n\t    // we check for ^{ and }$ (ignoring leading/trailing whitespace)\n\t    if (!options.binary && (options.json || !options.processData) &&\n\t        typeof data !== 'object' &&\n\t        (/json/.test(content_type) ||\n\t         (/^[\\s]*\\{/.test(data) && /\\}[\\s]*$/.test(data)))) {\n\t      try {\n\t        data = JSON.parse(data.toString());\n\t      } catch (e) {}\n\t    }\n\t\n\t    if (response.statusCode >= 200 && response.statusCode < 300) {\n\t      onSuccess(data, response, callback);\n\t    } else {\n\t      error = generateErrorFromResponse(data);\n\t      error.status = response.statusCode;\n\t      callback(error);\n\t    }\n\t  });\n\t}\n\t\n\tfunction ajax(opts, callback) {\n\t\n\t  // cache-buster, specifically designed to work around IE's aggressive caching\n\t  // see http://www.dashbay.com/2011/05/internet-explorer-caches-ajax/\n\t  // Also Safari caches POSTs, so we need to cache-bust those too.\n\t  var ua = (navigator && navigator.userAgent) ?\n\t    navigator.userAgent.toLowerCase() : '';\n\t\n\t  var isSafari = ua.indexOf('safari') !== -1 && ua.indexOf('chrome') === -1;\n\t  var isIE = ua.indexOf('msie') !== -1;\n\t  var isEdge = ua.indexOf('edge') !== -1;\n\t\n\t  var shouldCacheBust = (isSafari && opts.method === 'POST') ||\n\t    ((isIE || isEdge) && opts.method === 'GET');\n\t\n\t  var cache = 'cache' in opts ? opts.cache : true;\n\t\n\t  if (shouldCacheBust || !cache) {\n\t    var hasArgs = opts.url.indexOf('?') !== -1;\n\t    opts.url += (hasArgs ? '&' : '?') + '_nonce=' + Date.now();\n\t  }\n\t\n\t  return ajaxCore(opts, callback);\n\t}\n\t\n\t// originally parseUri 1.2.2, now patched by us\n\t// (c) Steven Levithan <stevenlevithan.com>\n\t// MIT License\n\tvar keys = [\"source\", \"protocol\", \"authority\", \"userInfo\", \"user\", \"password\",\n\t    \"host\", \"port\", \"relative\", \"path\", \"directory\", \"file\", \"query\", \"anchor\"];\n\tvar qName =\"queryKey\";\n\tvar qParser = /(?:^|&)([^&=]*)=?([^&]*)/g;\n\t\n\t// use the \"loose\" parser\n\t/* jshint maxlen: false */\n\tvar parser = /^(?:(?![^:@]+:[^:@\\/]*@)([^:\\/?#.]+):)?(?:\\/\\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\\/?#]*)(?::(\\d*))?)(((\\/(?:[^?#](?![^?#\\/]*\\.[^?#\\/.]+(?:[?#]|$)))*\\/?)?([^?#\\/]*))(?:\\?([^#]*))?(?:#(.*))?)/;\n\t\n\tfunction parseUri(str) {\n\t  var m = parser.exec(str);\n\t  var uri = {};\n\t  var i = 14;\n\t\n\t  while (i--) {\n\t    var key = keys[i];\n\t    var value = m[i] || \"\";\n\t    var encoded = ['user', 'password'].indexOf(key) !== -1;\n\t    uri[key] = encoded ? decodeURIComponent(value) : value;\n\t  }\n\t\n\t  uri[qName] = {};\n\t  uri[keys[12]].replace(qParser, function ($0, $1, $2) {\n\t    if ($1) {\n\t      uri[qName][$1] = $2;\n\t    }\n\t  });\n\t\n\t  return uri;\n\t}\n\t\n\tvar atob$1 = function (str) {\n\t  return atob(str);\n\t};\n\t\n\tvar btoa$1 = function (str) {\n\t  return btoa(str);\n\t};\n\t\n\t// From http://stackoverflow.com/questions/14967647/ (continues on next line)\n\t// encode-decode-image-with-base64-breaks-image (2013-04-21)\n\tfunction binaryStringToArrayBuffer(bin) {\n\t  var length = bin.length;\n\t  var buf = new ArrayBuffer(length);\n\t  var arr = new Uint8Array(buf);\n\t  for (var i = 0; i < length; i++) {\n\t    arr[i] = bin.charCodeAt(i);\n\t  }\n\t  return buf;\n\t}\n\t\n\tfunction binStringToBluffer(binString, type) {\n\t  return createBlob([binaryStringToArrayBuffer(binString)], {type: type});\n\t}\n\t\n\tvar extend$1 = jsExtend__default.extend;\n\t\n\tvar utils = {\n\t  ajax: ajax,\n\t  parseUri: parseUri,\n\t  uuid: uuid,\n\t  Promise: PouchPromise,\n\t  atob: atob$1,\n\t  btoa: btoa$1,\n\t  binaryStringToBlobOrBuffer: binStringToBluffer,\n\t  clone: clone,\n\t  extend: extend$1,\n\t  createError: createError\n\t};\n\t\n\tfunction tryFilter(filter, doc, req) {\n\t  try {\n\t    return !filter(doc, req);\n\t  } catch (err) {\n\t    var msg = 'Filter function threw: ' + err.toString();\n\t    return createError(BAD_REQUEST, msg);\n\t  }\n\t}\n\t\n\tfunction filterChange(opts) {\n\t  var req = {};\n\t  var hasFilter = opts.filter && typeof opts.filter === 'function';\n\t  req.query = opts.query_params;\n\t\n\t  return function filter(change) {\n\t    if (!change.doc) {\n\t      // CSG sends events on the changes feed that don't have documents,\n\t      // this hack makes a whole lot of existing code robust.\n\t      change.doc = {};\n\t    }\n\t\n\t    var filterReturn = hasFilter && tryFilter(opts.filter, change.doc, req);\n\t\n\t    if (typeof filterReturn === 'object') {\n\t      return filterReturn;\n\t    }\n\t\n\t    if (filterReturn) {\n\t      return false;\n\t    }\n\t\n\t    if (!opts.include_docs) {\n\t      delete change.doc;\n\t    } else if (!opts.attachments) {\n\t      for (var att in change.doc._attachments) {\n\t        /* istanbul ignore else */\n\t        if (change.doc._attachments.hasOwnProperty(att)) {\n\t          change.doc._attachments[att].stub = true;\n\t        }\n\t      }\n\t    }\n\t    return true;\n\t  };\n\t}\n\t\n\t// designed to give info to browser users, who are disturbed\n\t// when they see http errors in the console\n\tfunction explainError(status, str) {\n\t  if ('console' in global && 'info' in console) {\n\t    console.info('The above ' + status + ' is totally normal. ' + str);\n\t  }\n\t}\n\t\n\tvar collate$1 = pouchCollate__default.collate;\n\t\n\tvar CHECKPOINT_VERSION = 1;\n\tvar REPLICATOR = \"pouchdb\";\n\t// This is an arbitrary number to limit the\n\t// amount of replication history we save in the checkpoint.\n\t// If we save too much, the checkpoing docs will become very big,\n\t// if we save fewer, we'll run a greater risk of having to\n\t// read all the changes from 0 when checkpoint PUTs fail\n\t// CouchDB 2.0 has a more involved history pruning,\n\t// but let's go for the simple version for now.\n\tvar CHECKPOINT_HISTORY_SIZE = 5;\n\tvar LOWEST_SEQ = 0;\n\t\n\tfunction updateCheckpoint(db, id, checkpoint, session, returnValue) {\n\t  return db.get(id).catch(function (err) {\n\t    if (err.status === 404) {\n\t      if (db.type() === 'http') {\n\t        explainError(\n\t          404, 'PouchDB is just checking if a remote checkpoint exists.'\n\t        );\n\t      }\n\t      return {\n\t        session_id: session,\n\t        _id: id,\n\t        history: [],\n\t        replicator: REPLICATOR,\n\t        version: CHECKPOINT_VERSION\n\t      };\n\t    }\n\t    throw err;\n\t  }).then(function (doc) {\n\t    if (returnValue.cancelled) {\n\t      return;\n\t    }\n\t    // Filter out current entry for this replication\n\t    doc.history = (doc.history || []).filter(function (item) {\n\t      return item.session_id !== session;\n\t    });\n\t\n\t    // Add the latest checkpoint to history\n\t    doc.history.unshift({\n\t      last_seq: checkpoint,\n\t      session_id: session\n\t    });\n\t\n\t    // Just take the last pieces in history, to\n\t    // avoid really big checkpoint docs.\n\t    // see comment on history size above\n\t    doc.history = doc.history.slice(0, CHECKPOINT_HISTORY_SIZE);\n\t\n\t    doc.version = CHECKPOINT_VERSION;\n\t    doc.replicator = REPLICATOR;\n\t\n\t    doc.session_id = session;\n\t    doc.last_seq = checkpoint;\n\t\n\t    return db.put(doc).catch(function (err) {\n\t      if (err.status === 409) {\n\t        // retry; someone is trying to write a checkpoint simultaneously\n\t        return updateCheckpoint(db, id, checkpoint, session, returnValue);\n\t      }\n\t      throw err;\n\t    });\n\t  });\n\t}\n\t\n\tfunction Checkpointer(src, target, id, returnValue) {\n\t  this.src = src;\n\t  this.target = target;\n\t  this.id = id;\n\t  this.returnValue = returnValue;\n\t}\n\t\n\tCheckpointer.prototype.writeCheckpoint = function (checkpoint, session) {\n\t  var self = this;\n\t  return this.updateTarget(checkpoint, session).then(function () {\n\t    return self.updateSource(checkpoint, session);\n\t  });\n\t};\n\t\n\tCheckpointer.prototype.updateTarget = function (checkpoint, session) {\n\t  return updateCheckpoint(this.target, this.id, checkpoint,\n\t      session, this.returnValue);\n\t};\n\t\n\tCheckpointer.prototype.updateSource = function (checkpoint, session) {\n\t  var self = this;\n\t  if (this.readOnlySource) {\n\t    return PouchPromise.resolve(true);\n\t  }\n\t  return updateCheckpoint(this.src, this.id, checkpoint,\n\t      session, this.returnValue)\n\t    .catch(function (err) {\n\t      if (isForbiddenError(err)) {\n\t        self.readOnlySource = true;\n\t        return true;\n\t      }\n\t      throw err;\n\t    });\n\t};\n\t\n\tvar comparisons = {\n\t  \"undefined\": function(targetDoc, sourceDoc) {\n\t    // This is the previous comparison function\n\t    if (collate$1(targetDoc.last_seq, sourceDoc.last_seq) === 0) {\n\t      return sourceDoc.last_seq;\n\t    }\n\t    /* istanbul ignore next */\n\t    return 0;\n\t  },\n\t  \"1\": function(targetDoc, sourceDoc) {\n\t    // This is the comparison function ported from CouchDB\n\t    return compareReplicationLogs(sourceDoc, targetDoc).last_seq;\n\t  }\n\t};\n\t\n\tCheckpointer.prototype.getCheckpoint = function () {\n\t  var self = this;\n\t  return self.target.get(self.id).then(function (targetDoc) {\n\t    if (self.readOnlySource) {\n\t      return PouchPromise.resolve(targetDoc.last_seq);\n\t    }\n\t\n\t    return self.src.get(self.id).then(function (sourceDoc) {\n\t      // Since we can't migrate an old version doc to a new one\n\t      // (no session id), we just go with the lowest seq in this case\n\t      /* istanbul ignore if */\n\t      if (targetDoc.version !== sourceDoc.version) {\n\t        return LOWEST_SEQ;\n\t      }\n\t\n\t      var version;\n\t      if (targetDoc.version) {\n\t        version = targetDoc.version.toString();\n\t      } else {\n\t        version = \"undefined\";\n\t      }\n\t\n\t      if (version in comparisons) {\n\t        return comparisons[version](targetDoc, sourceDoc);\n\t      }\n\t      /* istanbul ignore next */\n\t      return LOWEST_SEQ;\n\t    }, function (err) {\n\t      if (err.status === 404 && targetDoc.last_seq) {\n\t        return self.src.put({\n\t          _id: self.id,\n\t          last_seq: LOWEST_SEQ\n\t        }).then(function () {\n\t          return LOWEST_SEQ;\n\t        }, function (err) {\n\t          if (isForbiddenError(err)) {\n\t            self.readOnlySource = true;\n\t            return targetDoc.last_seq;\n\t          }\n\t          /* istanbul ignore next */\n\t          return LOWEST_SEQ;\n\t        });\n\t      }\n\t      throw err;\n\t    });\n\t  }).catch(function (err) {\n\t    if (err.status !== 404) {\n\t      throw err;\n\t    }\n\t    return LOWEST_SEQ;\n\t  });\n\t};\n\t// This checkpoint comparison is ported from CouchDBs source\n\t// they come from here:\n\t// https://github.com/apache/couchdb-couch-replicator/blob/master/src/couch_replicator.erl#L863-L906\n\t\n\tfunction compareReplicationLogs (srcDoc, tgtDoc) {\n\t  if (srcDoc.session_id === tgtDoc.session_id) {\n\t    return {\n\t      last_seq: srcDoc.last_seq,\n\t      history: srcDoc.history || []\n\t    };\n\t  }\n\t\n\t  var sourceHistory = srcDoc.history || [];\n\t  var targetHistory = tgtDoc.history || [];\n\t  return compareReplicationHistory(sourceHistory, targetHistory);\n\t}\n\t\n\tfunction compareReplicationHistory (sourceHistory, targetHistory) {\n\t  // the erlang loop via function arguments is not so easy to repeat in JS\n\t  // therefore, doing this as recursion\n\t  var S = sourceHistory[0];\n\t  var sourceRest = sourceHistory.slice(1);\n\t  var T = targetHistory[0];\n\t  var targetRest = targetHistory.slice(1);\n\t\n\t  if (!S || targetHistory.length === 0) {\n\t    return {\n\t      last_seq: LOWEST_SEQ,\n\t      history: []\n\t    };\n\t  }\n\t\n\t  var sourceId = S.session_id;\n\t  /* istanbul ignore if */\n\t  if (hasSessionId(sourceId, targetHistory)) {\n\t    return {\n\t      last_seq: S.last_seq,\n\t      history: sourceHistory\n\t    };\n\t  }\n\t\n\t  var targetId = T.session_id;\n\t  if (hasSessionId(targetId, sourceRest)) {\n\t    return {\n\t      last_seq: T.last_seq,\n\t      history: targetRest\n\t    };\n\t  }\n\t\n\t  return compareReplicationHistory(sourceRest, targetRest);\n\t}\n\t\n\tfunction hasSessionId (sessionId, history) {\n\t  var props = history[0];\n\t  var rest = history.slice(1);\n\t\n\t  if (!sessionId || history.length === 0) {\n\t    return false;\n\t  }\n\t\n\t  if (sessionId === props.session_id) {\n\t    return true;\n\t  }\n\t\n\t  return hasSessionId(sessionId, rest);\n\t}\n\t\n\tfunction isForbiddenError (err) {\n\t  return typeof err.status === 'number' && Math.floor(err.status / 100) === 4;\n\t}\n\t\n\tvar STARTING_BACK_OFF = 0;\n\t\n\tfunction randomNumber(min, max) {\n\t  min = parseInt(min, 10) || 0;\n\t  max = parseInt(max, 10);\n\t  if (max !== max || max <= min) {\n\t    max = (min || 1) << 1; //doubling\n\t  } else {\n\t    max = max + 1;\n\t  }\n\t  var ratio = Math.random();\n\t  var range = max - min;\n\t\n\t  return ~~(range * ratio + min); // ~~ coerces to an int, but fast.\n\t}\n\t\n\tfunction defaultBackOff(min) {\n\t  var max = 0;\n\t  if (!min) {\n\t    max = 2000;\n\t  }\n\t  return randomNumber(min, max);\n\t}\n\t\n\tfunction backOff(opts, returnValue, error, callback) {\n\t  if (opts.retry === false) {\n\t    returnValue.emit('error', error);\n\t    returnValue.removeAllListeners();\n\t    return;\n\t  }\n\t  if (typeof opts.back_off_function !== 'function') {\n\t    opts.back_off_function = defaultBackOff;\n\t  }\n\t  returnValue.emit('requestError', error);\n\t  if (returnValue.state === 'active' || returnValue.state === 'pending') {\n\t    returnValue.emit('paused', error);\n\t    returnValue.state = 'stopped';\n\t    returnValue.once('active', function () {\n\t      opts.current_back_off = STARTING_BACK_OFF;\n\t    });\n\t  }\n\t\n\t  opts.current_back_off = opts.current_back_off || STARTING_BACK_OFF;\n\t  opts.current_back_off = opts.back_off_function(opts.current_back_off);\n\t  setTimeout(callback, opts.current_back_off);\n\t}\n\t\n\tvar setImmediateShim = global.setImmediate || global.setTimeout;\n\tvar MD5_CHUNK_SIZE = 32768;\n\t\n\tfunction rawToBase64(raw) {\n\t  return btoa$1(raw);\n\t}\n\t\n\tfunction appendBuffer(buffer, data, start, end) {\n\t  if (start > 0 || end < data.byteLength) {\n\t    // only create a subarray if we really need to\n\t    data = new Uint8Array(data, start,\n\t      Math.min(end, data.byteLength) - start);\n\t  }\n\t  buffer.append(data);\n\t}\n\t\n\tfunction appendString(buffer, data, start, end) {\n\t  if (start > 0 || end < data.length) {\n\t    // only create a substring if we really need to\n\t    data = data.substring(start, end);\n\t  }\n\t  buffer.appendBinary(data);\n\t}\n\t\n\tvar md5 = toPromise(function (data, callback) {\n\t  var inputIsString = typeof data === 'string';\n\t  var len = inputIsString ? data.length : data.byteLength;\n\t  var chunkSize = Math.min(MD5_CHUNK_SIZE, len);\n\t  var chunks = Math.ceil(len / chunkSize);\n\t  var currentChunk = 0;\n\t  var buffer = inputIsString ? new Md5() : new Md5.ArrayBuffer();\n\t\n\t  var append = inputIsString ? appendString : appendBuffer;\n\t\n\t  function loadNextChunk() {\n\t    var start = currentChunk * chunkSize;\n\t    var end = start + chunkSize;\n\t    currentChunk++;\n\t    if (currentChunk < chunks) {\n\t      append(buffer, data, start, end);\n\t      setImmediateShim(loadNextChunk);\n\t    } else {\n\t      append(buffer, data, start, end);\n\t      var raw = buffer.end(true);\n\t      var base64 = rawToBase64(raw);\n\t      callback(null, base64);\n\t      buffer.destroy();\n\t    }\n\t  }\n\t  loadNextChunk();\n\t});\n\t\n\tfunction sortObjectPropertiesByKey(queryParams) {\n\t  return Object.keys(queryParams).sort(pouchCollate.collate).reduce(function (result, key) {\n\t    result[key] = queryParams[key];\n\t    return result;\n\t  }, {});\n\t}\n\t\n\t// Generate a unique id particular to this replication.\n\t// Not guaranteed to align perfectly with CouchDB's rep ids.\n\tfunction generateReplicationId(src, target, opts) {\n\t  var docIds = opts.doc_ids ? opts.doc_ids.sort(pouchCollate.collate) : '';\n\t  var filterFun = opts.filter ? opts.filter.toString() : '';\n\t  var queryParams = '';\n\t  var filterViewName =  '';\n\t\n\t  if (opts.filter && opts.query_params) {\n\t    queryParams = JSON.stringify(sortObjectPropertiesByKey(opts.query_params));\n\t  }\n\t\n\t  if (opts.filter && opts.filter === '_view') {\n\t    filterViewName = opts.view.toString();\n\t  }\n\t\n\t  return PouchPromise.all([src.id(), target.id()]).then(function (res) {\n\t    var queryData = res[0] + res[1] + filterFun + filterViewName +\n\t      queryParams + docIds;\n\t    return md5(queryData);\n\t  }).then(function (md5sum) {\n\t    // can't use straight-up md5 alphabet, because\n\t    // the char '/' is interpreted as being for attachments,\n\t    // and + is also not url-safe\n\t    md5sum = md5sum.replace(/\\//g, '.').replace(/\\+/g, '_');\n\t    return '_local/' + md5sum;\n\t  });\n\t}\n\t\n\tfunction isGenOne(rev) {\n\t  return /^1-/.test(rev);\n\t}\n\t\n\tfunction createBulkGetOpts(diffs) {\n\t  var requests = [];\n\t  Object.keys(diffs).forEach(function (id) {\n\t    var missingRevs = diffs[id].missing;\n\t    missingRevs.forEach(function (missingRev) {\n\t      requests.push({\n\t        id: id,\n\t        rev: missingRev\n\t      });\n\t    });\n\t  });\n\t\n\t  return {\n\t    docs: requests,\n\t    revs: true,\n\t    attachments: true,\n\t    binary: true\n\t  };\n\t}\n\t\n\t//\n\t// Fetch all the documents from the src as described in the \"diffs\",\n\t// which is a mapping of docs IDs to revisions. If the state ever\n\t// changes to \"cancelled\", then the returned promise will be rejected.\n\t// Else it will be resolved with a list of fetched documents.\n\t//\n\tfunction getDocs(src, diffs, state) {\n\t  diffs = clone(diffs); // we do not need to modify this\n\t\n\t  var resultDocs = [];\n\t\n\t  function getAllDocs() {\n\t\n\t    var bulkGetOpts = createBulkGetOpts(diffs);\n\t\n\t    if (!bulkGetOpts.docs.length) { // optimization: skip empty requests\n\t      return;\n\t    }\n\t\n\t    return src.bulkGet(bulkGetOpts).then(function (bulkGetResponse) {\n\t      /* istanbul ignore if */\n\t      if (state.cancelled) {\n\t        throw new Error('cancelled');\n\t      }\n\t      bulkGetResponse.results.forEach(function (bulkGetInfo) {\n\t        bulkGetInfo.docs.forEach(function (doc) {\n\t          if (doc.ok) {\n\t            resultDocs.push(doc.ok);\n\t          }\n\t        });\n\t      });\n\t    });\n\t  }\n\t\n\t  function hasAttachments(doc) {\n\t    return doc._attachments && Object.keys(doc._attachments).length > 0;\n\t  }\n\t\n\t  function fetchRevisionOneDocs(ids) {\n\t    // Optimization: fetch gen-1 docs and attachments in\n\t    // a single request using _all_docs\n\t    return src.allDocs({\n\t      keys: ids,\n\t      include_docs: true\n\t    }).then(function (res) {\n\t      if (state.cancelled) {\n\t        throw new Error('cancelled');\n\t      }\n\t      res.rows.forEach(function (row) {\n\t        if (row.deleted || !row.doc || !isGenOne(row.value.rev) ||\n\t            hasAttachments(row.doc)) {\n\t          // if any of these conditions apply, we need to fetch using get()\n\t          return;\n\t        }\n\t\n\t        // the doc we got back from allDocs() is sufficient\n\t        resultDocs.push(row.doc);\n\t        delete diffs[row.id];\n\t      });\n\t    });\n\t  }\n\t\n\t  function getRevisionOneDocs() {\n\t    // filter out the generation 1 docs and get them\n\t    // leaving the non-generation one docs to be got otherwise\n\t    var ids = Object.keys(diffs).filter(function (id) {\n\t      var missing = diffs[id].missing;\n\t      return missing.length === 1 && isGenOne(missing[0]);\n\t    });\n\t    if (ids.length > 0) {\n\t      return fetchRevisionOneDocs(ids);\n\t    }\n\t  }\n\t\n\t  function returnDocs() {\n\t    return resultDocs;\n\t  }\n\t\n\t  return PouchPromise.resolve()\n\t    .then(getRevisionOneDocs)\n\t    .then(getAllDocs)\n\t    .then(returnDocs);\n\t}\n\t\n\tfunction replicate(src, target, opts, returnValue, result) {\n\t  var batches = [];               // list of batches to be processed\n\t  var currentBatch;               // the batch currently being processed\n\t  var pendingBatch = {\n\t    seq: 0,\n\t    changes: [],\n\t    docs: []\n\t  }; // next batch, not yet ready to be processed\n\t  var writingCheckpoint = false;  // true while checkpoint is being written\n\t  var changesCompleted = false;   // true when all changes received\n\t  var replicationCompleted = false; // true when replication has completed\n\t  var last_seq = 0;\n\t  var continuous = opts.continuous || opts.live || false;\n\t  var batch_size = opts.batch_size || 100;\n\t  var batches_limit = opts.batches_limit || 10;\n\t  var changesPending = false;     // true while src.changes is running\n\t  var doc_ids = opts.doc_ids;\n\t  var repId;\n\t  var checkpointer;\n\t  var allErrors = [];\n\t  var changedDocs = [];\n\t  // Like couchdb, every replication gets a unique session id\n\t  var session = uuid();\n\t\n\t  result = result || {\n\t    ok: true,\n\t    start_time: new Date(),\n\t    docs_read: 0,\n\t    docs_written: 0,\n\t    doc_write_failures: 0,\n\t    errors: []\n\t  };\n\t\n\t  var changesOpts = {};\n\t  returnValue.ready(src, target);\n\t\n\t  function initCheckpointer() {\n\t    if (checkpointer) {\n\t      return PouchPromise.resolve();\n\t    }\n\t    return generateReplicationId(src, target, opts).then(function (res) {\n\t      repId = res;\n\t      checkpointer = new Checkpointer(src, target, repId, returnValue);\n\t    });\n\t  }\n\t\n\t  function writeDocs() {\n\t    changedDocs = [];\n\t\n\t    if (currentBatch.docs.length === 0) {\n\t      return;\n\t    }\n\t    var docs = currentBatch.docs;\n\t    return target.bulkDocs({docs: docs, new_edits: false}).then(function (res) {\n\t      if (returnValue.cancelled) {\n\t        completeReplication();\n\t        throw new Error('cancelled');\n\t      }\n\t      var errors = [];\n\t      var errorsById = {};\n\t      res.forEach(function (res) {\n\t        if (res.error) {\n\t          result.doc_write_failures++;\n\t          errors.push(res);\n\t          errorsById[res.id] = res;\n\t        }\n\t      });\n\t      allErrors = allErrors.concat(errors);\n\t      result.docs_written += currentBatch.docs.length - errors.length;\n\t      var non403s = errors.filter(function (error) {\n\t        return error.name !== 'unauthorized' && error.name !== 'forbidden';\n\t      });\n\t\n\t      docs.forEach(function(doc) {\n\t        var error = errorsById[doc._id];\n\t        if (error) {\n\t          returnValue.emit('denied', clone(error));\n\t        } else {\n\t          changedDocs.push(doc);\n\t        }\n\t      });\n\t\n\t      if (non403s.length > 0) {\n\t        var error = new Error('bulkDocs error');\n\t        error.other_errors = errors;\n\t        abortReplication('target.bulkDocs failed to write docs', error);\n\t        throw new Error('bulkWrite partial failure');\n\t      }\n\t    }, function (err) {\n\t      result.doc_write_failures += docs.length;\n\t      throw err;\n\t    });\n\t  }\n\t\n\t  function finishBatch() {\n\t    result.last_seq = last_seq = currentBatch.seq;\n\t    var outResult = clone(result);\n\t    if (changedDocs.length) {\n\t      outResult.docs = changedDocs;\n\t      returnValue.emit('change', outResult);\n\t    }\n\t    writingCheckpoint = true;\n\t    return checkpointer.writeCheckpoint(currentBatch.seq,\n\t        session).then(function () {\n\t      writingCheckpoint = false;\n\t      if (returnValue.cancelled) {\n\t        completeReplication();\n\t        throw new Error('cancelled');\n\t      }\n\t      currentBatch = undefined;\n\t      getChanges();\n\t    }).catch(function (err) {\n\t      writingCheckpoint = false;\n\t      abortReplication('writeCheckpoint completed with error', err);\n\t      throw err;\n\t    });\n\t  }\n\t\n\t  function getDiffs() {\n\t    var diff = {};\n\t    currentBatch.changes.forEach(function (change) {\n\t      // Couchbase Sync Gateway emits these, but we can ignore them\n\t      /* istanbul ignore if */\n\t      if (change.id === \"_user/\") {\n\t        return;\n\t      }\n\t      diff[change.id] = change.changes.map(function (x) {\n\t        return x.rev;\n\t      });\n\t    });\n\t    return target.revsDiff(diff).then(function (diffs) {\n\t      if (returnValue.cancelled) {\n\t        completeReplication();\n\t        throw new Error('cancelled');\n\t      }\n\t      // currentBatch.diffs elements are deleted as the documents are written\n\t      currentBatch.diffs = diffs;\n\t    });\n\t  }\n\t\n\t  function getBatchDocs() {\n\t    return getDocs(src, currentBatch.diffs, returnValue).then(function (docs) {\n\t      docs.forEach(function (doc) {\n\t        delete currentBatch.diffs[doc._id];\n\t        result.docs_read++;\n\t        currentBatch.docs.push(doc);\n\t      });\n\t    });\n\t  }\n\t\n\t  function startNextBatch() {\n\t    if (returnValue.cancelled || currentBatch) {\n\t      return;\n\t    }\n\t    if (batches.length === 0) {\n\t      processPendingBatch(true);\n\t      return;\n\t    }\n\t    currentBatch = batches.shift();\n\t    getDiffs()\n\t      .then(getBatchDocs)\n\t      .then(writeDocs)\n\t      .then(finishBatch)\n\t      .then(startNextBatch)\n\t      .catch(function (err) {\n\t        abortReplication('batch processing terminated with error', err);\n\t      });\n\t  }\n\t\n\t\n\t  function processPendingBatch(immediate) {\n\t    if (pendingBatch.changes.length === 0) {\n\t      if (batches.length === 0 && !currentBatch) {\n\t        if ((continuous && changesOpts.live) || changesCompleted) {\n\t          returnValue.state = 'pending';\n\t          returnValue.emit('paused');\n\t        }\n\t        if (changesCompleted) {\n\t          completeReplication();\n\t        }\n\t      }\n\t      return;\n\t    }\n\t    if (\n\t      immediate ||\n\t      changesCompleted ||\n\t      pendingBatch.changes.length >= batch_size\n\t    ) {\n\t      batches.push(pendingBatch);\n\t      pendingBatch = {\n\t        seq: 0,\n\t        changes: [],\n\t        docs: []\n\t      };\n\t      if (returnValue.state === 'pending' || returnValue.state === 'stopped') {\n\t        returnValue.state = 'active';\n\t        returnValue.emit('active');\n\t      }\n\t      startNextBatch();\n\t    }\n\t  }\n\t\n\t\n\t  function abortReplication(reason, err) {\n\t    if (replicationCompleted) {\n\t      return;\n\t    }\n\t    if (!err.message) {\n\t      err.message = reason;\n\t    }\n\t    result.ok = false;\n\t    result.status = 'aborting';\n\t    result.errors.push(err);\n\t    allErrors = allErrors.concat(err);\n\t    batches = [];\n\t    pendingBatch = {\n\t      seq: 0,\n\t      changes: [],\n\t      docs: []\n\t    };\n\t    completeReplication();\n\t  }\n\t\n\t\n\t  function completeReplication() {\n\t    if (replicationCompleted) {\n\t      return;\n\t    }\n\t    if (returnValue.cancelled) {\n\t      result.status = 'cancelled';\n\t      if (writingCheckpoint) {\n\t        return;\n\t      }\n\t    }\n\t    result.status = result.status || 'complete';\n\t    result.end_time = new Date();\n\t    result.last_seq = last_seq;\n\t    replicationCompleted = true;\n\t    var non403s = allErrors.filter(function (error) {\n\t      return error.name !== 'unauthorized' && error.name !== 'forbidden';\n\t    });\n\t    if (non403s.length > 0) {\n\t      var error = allErrors.pop();\n\t      if (allErrors.length > 0) {\n\t        error.other_errors = allErrors;\n\t      }\n\t      error.result = result;\n\t      backOff(opts, returnValue, error, function () {\n\t        replicate(src, target, opts, returnValue);\n\t      });\n\t    } else {\n\t      result.errors = allErrors;\n\t      returnValue.emit('complete', result);\n\t      returnValue.removeAllListeners();\n\t    }\n\t  }\n\t\n\t\n\t  function onChange(change) {\n\t    if (returnValue.cancelled) {\n\t      return completeReplication();\n\t    }\n\t    var filter = filterChange(opts)(change);\n\t    if (!filter) {\n\t      return;\n\t    }\n\t    pendingBatch.seq = change.seq;\n\t    pendingBatch.changes.push(change);\n\t    processPendingBatch(changesOpts.live);\n\t  }\n\t\n\t\n\t  function onChangesComplete(changes) {\n\t    changesPending = false;\n\t    if (returnValue.cancelled) {\n\t      return completeReplication();\n\t    }\n\t\n\t    // if no results were returned then we're done,\n\t    // else fetch more\n\t    if (changes.results.length > 0) {\n\t      changesOpts.since = changes.last_seq;\n\t      getChanges();\n\t    } else {\n\t      if (continuous) {\n\t        changesOpts.live = true;\n\t        getChanges();\n\t      } else {\n\t        changesCompleted = true;\n\t      }\n\t    }\n\t    processPendingBatch(true);\n\t  }\n\t\n\t\n\t  function onChangesError(err) {\n\t    changesPending = false;\n\t    /* istanbul ignore if */\n\t    if (returnValue.cancelled) {\n\t      return completeReplication();\n\t    }\n\t    abortReplication('changes rejected', err);\n\t  }\n\t\n\t\n\t  function getChanges() {\n\t    if (!(\n\t      !changesPending &&\n\t      !changesCompleted &&\n\t      batches.length < batches_limit\n\t      )) {\n\t      return;\n\t    }\n\t    changesPending = true;\n\t    function abortChanges() {\n\t      changes.cancel();\n\t    }\n\t    function removeListener() {\n\t      returnValue.removeListener('cancel', abortChanges);\n\t    }\n\t\n\t    if (returnValue._changes) { // remove old changes() and listeners\n\t      returnValue.removeListener('cancel', returnValue._abortChanges);\n\t      returnValue._changes.cancel();\n\t    }\n\t    returnValue.once('cancel', abortChanges);\n\t\n\t    var changes = src.changes(changesOpts)\n\t      .on('change', onChange);\n\t    changes.then(removeListener, removeListener);\n\t    changes.then(onChangesComplete)\n\t      .catch(onChangesError);\n\t\n\t    if (opts.retry) {\n\t      // save for later so we can cancel if necessary\n\t      returnValue._changes = changes;\n\t      returnValue._abortChanges = abortChanges;\n\t    }\n\t  }\n\t\n\t\n\t  function startChanges() {\n\t    initCheckpointer().then(function () {\n\t      if (returnValue.cancelled) {\n\t        completeReplication();\n\t        return;\n\t      }\n\t      return checkpointer.getCheckpoint().then(function (checkpoint) {\n\t        last_seq = checkpoint;\n\t        changesOpts = {\n\t          since: last_seq,\n\t          limit: batch_size,\n\t          batch_size: batch_size,\n\t          style: 'all_docs',\n\t          doc_ids: doc_ids,\n\t          return_docs: true // required so we know when we're done\n\t        };\n\t        if (opts.filter) {\n\t          if (typeof opts.filter !== 'string') {\n\t            // required for the client-side filter in onChange\n\t            changesOpts.include_docs = true;\n\t          } else { // ddoc filter\n\t            changesOpts.filter = opts.filter;\n\t          }\n\t        }\n\t        if ('heartbeat' in opts) {\n\t          changesOpts.heartbeat = opts.heartbeat;\n\t        }\n\t        if ('timeout' in opts) {\n\t          changesOpts.timeout = opts.timeout;\n\t        }\n\t        if (opts.query_params) {\n\t          changesOpts.query_params = opts.query_params;\n\t        }\n\t        if (opts.view) {\n\t          changesOpts.view = opts.view;\n\t        }\n\t        getChanges();\n\t      });\n\t    }).catch(function (err) {\n\t      abortReplication('getCheckpoint rejected with ', err);\n\t    });\n\t  }\n\t\n\t  /* istanbul ignore next */\n\t  function onCheckpointError(err) {\n\t    writingCheckpoint = false;\n\t    abortReplication('writeCheckpoint completed with error', err);\n\t    throw err;\n\t  }\n\t\n\t  /* istanbul ignore if */\n\t  if (returnValue.cancelled) { // cancelled immediately\n\t    completeReplication();\n\t    return;\n\t  }\n\t\n\t  if (!returnValue._addedListeners) {\n\t    returnValue.once('cancel', completeReplication);\n\t\n\t    if (typeof opts.complete === 'function') {\n\t      returnValue.once('error', opts.complete);\n\t      returnValue.once('complete', function (result) {\n\t        opts.complete(null, result);\n\t      });\n\t    }\n\t    returnValue._addedListeners = true;\n\t  }\n\t\n\t  if (typeof opts.since === 'undefined') {\n\t    startChanges();\n\t  } else {\n\t    initCheckpointer().then(function () {\n\t      writingCheckpoint = true;\n\t      return checkpointer.writeCheckpoint(opts.since, session);\n\t    }).then(function () {\n\t      writingCheckpoint = false;\n\t      /* istanbul ignore if */\n\t      if (returnValue.cancelled) {\n\t        completeReplication();\n\t        return;\n\t      }\n\t      last_seq = opts.since;\n\t      startChanges();\n\t    }).catch(onCheckpointError);\n\t  }\n\t}\n\t\n\t// We create a basic promise so the caller can cancel the replication possibly\n\t// before we have actually started listening to changes etc\n\tinherits(Replication, events.EventEmitter);\n\tfunction Replication() {\n\t  events.EventEmitter.call(this);\n\t  this.cancelled = false;\n\t  this.state = 'pending';\n\t  var self = this;\n\t  var promise = new PouchPromise(function (fulfill, reject) {\n\t    self.once('complete', fulfill);\n\t    self.once('error', reject);\n\t  });\n\t  self.then = function (resolve, reject) {\n\t    return promise.then(resolve, reject);\n\t  };\n\t  self.catch = function (reject) {\n\t    return promise.catch(reject);\n\t  };\n\t  // As we allow error handling via \"error\" event as well,\n\t  // put a stub in here so that rejecting never throws UnhandledError.\n\t  self.catch(function () {});\n\t}\n\t\n\tReplication.prototype.cancel = function () {\n\t  this.cancelled = true;\n\t  this.state = 'cancelled';\n\t  this.emit('cancel');\n\t};\n\t\n\tReplication.prototype.ready = function (src, target) {\n\t  var self = this;\n\t  if (self._readyCalled) {\n\t    return;\n\t  }\n\t  self._readyCalled = true;\n\t\n\t  function onDestroy() {\n\t    self.cancel();\n\t  }\n\t  src.once('destroyed', onDestroy);\n\t  target.once('destroyed', onDestroy);\n\t  function cleanup() {\n\t    src.removeListener('destroyed', onDestroy);\n\t    target.removeListener('destroyed', onDestroy);\n\t  }\n\t  self.once('complete', cleanup);\n\t};\n\t\n\tfunction toPouch(db, opts) {\n\t  var PouchConstructor = opts.PouchConstructor;\n\t  if (typeof db === 'string') {\n\t    return new PouchConstructor(db, opts);\n\t  } else {\n\t    return db;\n\t  }\n\t}\n\t\n\tfunction replicateWrapper(src, target, opts, callback) {\n\t\n\t  if (typeof opts === 'function') {\n\t    callback = opts;\n\t    opts = {};\n\t  }\n\t  if (typeof opts === 'undefined') {\n\t    opts = {};\n\t  }\n\t\n\t  if (opts.doc_ids && !Array.isArray(opts.doc_ids)) {\n\t    throw createError(BAD_REQUEST,\n\t                       \"`doc_ids` filter parameter is not a list.\");\n\t  }\n\t\n\t  opts.complete = callback;\n\t  opts = clone(opts);\n\t  opts.continuous = opts.continuous || opts.live;\n\t  opts.retry = ('retry' in opts) ? opts.retry : false;\n\t  /*jshint validthis:true */\n\t  opts.PouchConstructor = opts.PouchConstructor || this;\n\t  var replicateRet = new Replication(opts);\n\t  var srcPouch = toPouch(src, opts);\n\t  var targetPouch = toPouch(target, opts);\n\t  replicate(srcPouch, targetPouch, opts, replicateRet);\n\t  return replicateRet;\n\t}\n\t\n\tvar replication = {\n\t  replicate: replicateWrapper,\n\t  toPouch: toPouch\n\t};\n\t\n\tvar replicate$1 = replication.replicate;\n\tinherits(Sync, events.EventEmitter);\n\tfunction sync(src, target, opts, callback) {\n\t  if (typeof opts === 'function') {\n\t    callback = opts;\n\t    opts = {};\n\t  }\n\t  if (typeof opts === 'undefined') {\n\t    opts = {};\n\t  }\n\t  opts = clone(opts);\n\t  /*jshint validthis:true */\n\t  opts.PouchConstructor = opts.PouchConstructor || this;\n\t  src = replication.toPouch(src, opts);\n\t  target = replication.toPouch(target, opts);\n\t  return new Sync(src, target, opts, callback);\n\t}\n\t\n\tfunction Sync(src, target, opts, callback) {\n\t  var self = this;\n\t  this.canceled = false;\n\t\n\t  var optsPush = opts.push ? jsExtend.extend({}, opts, opts.push) : opts;\n\t  var optsPull = opts.pull ? jsExtend.extend({}, opts, opts.pull) : opts;\n\t\n\t  this.push = replicate$1(src, target, optsPush);\n\t  this.pull = replicate$1(target, src, optsPull);\n\t\n\t  this.pushPaused = true;\n\t  this.pullPaused = true;\n\t\n\t  function pullChange(change) {\n\t    self.emit('change', {\n\t      direction: 'pull',\n\t      change: change\n\t    });\n\t  }\n\t  function pushChange(change) {\n\t    self.emit('change', {\n\t      direction: 'push',\n\t      change: change\n\t    });\n\t  }\n\t  function pushDenied(doc) {\n\t    self.emit('denied', {\n\t      direction: 'push',\n\t      doc: doc\n\t    });\n\t  }\n\t  function pullDenied(doc) {\n\t    self.emit('denied', {\n\t      direction: 'pull',\n\t      doc: doc\n\t    });\n\t  }\n\t  function pushPaused() {\n\t    self.pushPaused = true;\n\t    if (self.pullPaused) {\n\t      self.emit('paused');\n\t    }\n\t  }\n\t  function pullPaused() {\n\t    self.pullPaused = true;\n\t    if (self.pushPaused) {\n\t      self.emit('paused');\n\t    }\n\t  }\n\t  function pushActive() {\n\t    self.pushPaused = false;\n\t    if (self.pullPaused) {\n\t      self.emit('active', {\n\t        direction: 'push'\n\t      });\n\t    }\n\t  }\n\t  function pullActive() {\n\t    self.pullPaused = false;\n\t    /* istanbul ignore if */\n\t    if (self.pushPaused) {\n\t      self.emit('active', {\n\t        direction: 'pull'\n\t      });\n\t    }\n\t  }\n\t\n\t  var removed = {};\n\t\n\t  function removeAll(type) { // type is 'push' or 'pull'\n\t    return function (event, func) {\n\t      var isChange = event === 'change' &&\n\t        (func === pullChange || func === pushChange);\n\t      var isDenied = event === 'denied' &&\n\t        (func === pullDenied || func === pushDenied);\n\t      var isPaused = event === 'paused' &&\n\t        (func === pullPaused || func === pushPaused);\n\t      var isActive = event === 'active' &&\n\t        (func === pullActive || func === pushActive);\n\t\n\t      if (isChange || isDenied || isPaused || isActive) {\n\t        if (!(event in removed)) {\n\t          removed[event] = {};\n\t        }\n\t        removed[event][type] = true;\n\t        if (Object.keys(removed[event]).length === 2) {\n\t          // both push and pull have asked to be removed\n\t          self.removeAllListeners(event);\n\t        }\n\t      }\n\t    };\n\t  }\n\t\n\t  if (opts.live) {\n\t    this.push.on('complete', self.pull.cancel.bind(self.pull));\n\t    this.pull.on('complete', self.push.cancel.bind(self.push));\n\t  }\n\t\n\t  this.on('newListener', function (event) {\n\t    if (event === 'change') {\n\t      self.pull.on('change', pullChange);\n\t      self.push.on('change', pushChange);\n\t    } else if (event === 'denied') {\n\t      self.pull.on('denied', pullDenied);\n\t      self.push.on('denied', pushDenied);\n\t    } else if (event === 'active') {\n\t      self.pull.on('active', pullActive);\n\t      self.push.on('active', pushActive);\n\t    } else if (event === 'paused') {\n\t      self.pull.on('paused', pullPaused);\n\t      self.push.on('paused', pushPaused);\n\t    }\n\t  });\n\t\n\t  this.on('removeListener', function (event) {\n\t    if (event === 'change') {\n\t      self.pull.removeListener('change', pullChange);\n\t      self.push.removeListener('change', pushChange);\n\t    } else if (event === 'denied') {\n\t      self.pull.removeListener('denied', pullDenied);\n\t      self.push.removeListener('denied', pushDenied);\n\t    } else if (event === 'active') {\n\t      self.pull.removeListener('active', pullActive);\n\t      self.push.removeListener('active', pushActive);\n\t    } else if (event === 'paused') {\n\t      self.pull.removeListener('paused', pullPaused);\n\t      self.push.removeListener('paused', pushPaused);\n\t    }\n\t  });\n\t\n\t  this.pull.on('removeListener', removeAll('pull'));\n\t  this.push.on('removeListener', removeAll('push'));\n\t\n\t  var promise = PouchPromise.all([\n\t    this.push,\n\t    this.pull\n\t  ]).then(function (resp) {\n\t    var out = {\n\t      push: resp[0],\n\t      pull: resp[1]\n\t    };\n\t    self.emit('complete', out);\n\t    if (callback) {\n\t      callback(null, out);\n\t    }\n\t    self.removeAllListeners();\n\t    return out;\n\t  }, function (err) {\n\t    self.cancel();\n\t    if (callback) {\n\t      // if there's a callback, then the callback can receive\n\t      // the error event\n\t      callback(err);\n\t    } else {\n\t      // if there's no callback, then we're safe to emit an error\n\t      // event, which would otherwise throw an unhandled error\n\t      // due to 'error' being a special event in EventEmitters\n\t      self.emit('error', err);\n\t    }\n\t    self.removeAllListeners();\n\t    if (callback) {\n\t      // no sense throwing if we're already emitting an 'error' event\n\t      throw err;\n\t    }\n\t  });\n\t\n\t  this.then = function (success, err) {\n\t    return promise.then(success, err);\n\t  };\n\t\n\t  this.catch = function (err) {\n\t    return promise.catch(err);\n\t  };\n\t}\n\t\n\tSync.prototype.cancel = function () {\n\t  if (!this.canceled) {\n\t    this.canceled = true;\n\t    this.push.cancel();\n\t    this.pull.cancel();\n\t  }\n\t};\n\t\n\tfunction b64ToBluffer(b64, type) {\n\t  return binStringToBluffer(atob$1(b64), type);\n\t}\n\t\n\t//Can't find original post, but this is close\n\t//http://stackoverflow.com/questions/6965107/ (continues on next line)\n\t//converting-between-strings-and-arraybuffers\n\tfunction arrayBufferToBinaryString(buffer) {\n\t  var binary = '';\n\t  var bytes = new Uint8Array(buffer);\n\t  var length = bytes.byteLength;\n\t  for (var i = 0; i < length; i++) {\n\t    binary += String.fromCharCode(bytes[i]);\n\t  }\n\t  return binary;\n\t}\n\t\n\t// shim for browsers that don't support it\n\tfunction readAsBinaryString(blob, callback) {\n\t  if (typeof FileReader === 'undefined') {\n\t    // fix for Firefox in a web worker\n\t    // https://bugzilla.mozilla.org/show_bug.cgi?id=901097\n\t    return callback(arrayBufferToBinaryString(\n\t      new FileReaderSync().readAsArrayBuffer(blob)));\n\t  }\n\t\n\t  var reader = new FileReader();\n\t  var hasBinaryString = typeof reader.readAsBinaryString === 'function';\n\t  reader.onloadend = function (e) {\n\t    var result = e.target.result || '';\n\t    if (hasBinaryString) {\n\t      return callback(result);\n\t    }\n\t    callback(arrayBufferToBinaryString(result));\n\t  };\n\t  if (hasBinaryString) {\n\t    reader.readAsBinaryString(blob);\n\t  } else {\n\t    reader.readAsArrayBuffer(blob);\n\t  }\n\t}\n\t\n\tfunction blobToBase64(blobOrBuffer) {\n\t  return new PouchPromise(function (resolve) {\n\t    readAsBinaryString(blobOrBuffer, function (bin) {\n\t      resolve(btoa$1(bin));\n\t    });\n\t  });\n\t}\n\t\n\tfunction flatten(arrs) {\n\t  var res = [];\n\t  for (var i = 0, len = arrs.length; i < len; i++) {\n\t    res = res.concat(arrs[i]);\n\t  }\n\t  return res;\n\t}\n\t\n\tvar CHANGES_BATCH_SIZE = 25;\n\tvar MAX_SIMULTANEOUS_REVS = 50;\n\t\n\tvar supportsBulkGetMap = {};\n\t\n\t// according to http://stackoverflow.com/a/417184/680742,\n\t// the de facto URL length limit is 2000 characters.\n\t// but since most of our measurements don't take the full\n\t// URL into account, we fudge it a bit.\n\t// TODO: we could measure the full URL to enforce exactly 2000 chars\n\tvar MAX_URL_LENGTH = 1800;\n\t\n\tvar log$1 = debug('pouchdb:http');\n\tfunction readAttachmentsAsBlobOrBuffer(row) {\n\t  var atts = row.doc && row.doc._attachments;\n\t  if (!atts) {\n\t    return;\n\t  }\n\t  Object.keys(atts).forEach(function (filename) {\n\t    var att = atts[filename];\n\t    att.data = b64ToBluffer(att.data, att.content_type);\n\t  });\n\t}\n\t\n\tfunction encodeDocId(id) {\n\t  if (/^_design/.test(id)) {\n\t    return '_design/' + encodeURIComponent(id.slice(8));\n\t  }\n\t  if (/^_local/.test(id)) {\n\t    return '_local/' + encodeURIComponent(id.slice(7));\n\t  }\n\t  return encodeURIComponent(id);\n\t}\n\t\n\tfunction preprocessAttachments(doc) {\n\t  if (!doc._attachments || !Object.keys(doc._attachments)) {\n\t    return PouchPromise.resolve();\n\t  }\n\t\n\t  return PouchPromise.all(Object.keys(doc._attachments).map(function (key) {\n\t    var attachment = doc._attachments[key];\n\t    if (attachment.data && typeof attachment.data !== 'string') {\n\t      return blobToBase64(attachment.data).then(function (b64) {\n\t        attachment.data = b64;\n\t      });\n\t    }\n\t  }));\n\t}\n\t\n\t// Get all the information you possibly can about the URI given by name and\n\t// return it as a suitable object.\n\tfunction getHost(name) {\n\t  // Prase the URI into all its little bits\n\t  var uri = parseUri(name);\n\t\n\t  // Store the user and password as a separate auth object\n\t  if (uri.user || uri.password) {\n\t    uri.auth = {username: uri.user, password: uri.password};\n\t  }\n\t\n\t  // Split the path part of the URI into parts using '/' as the delimiter\n\t  // after removing any leading '/' and any trailing '/'\n\t  var parts = uri.path.replace(/(^\\/|\\/$)/g, '').split('/');\n\t\n\t  // Store the first part as the database name and remove it from the parts\n\t  // array\n\t  uri.db = parts.pop();\n\t  // Prevent double encoding of URI component\n\t  if (uri.db.indexOf('%') === -1) {\n\t    uri.db = encodeURIComponent(uri.db);\n\t  }\n\t\n\t  // Restore the path by joining all the remaining parts (all the parts\n\t  // except for the database name) with '/'s\n\t  uri.path = parts.join('/');\n\t\n\t  return uri;\n\t}\n\t\n\t// Generate a URL with the host data given by opts and the given path\n\tfunction genDBUrl(opts, path) {\n\t  return genUrl(opts, opts.db + '/' + path);\n\t}\n\t\n\t// Generate a URL with the host data given by opts and the given path\n\tfunction genUrl(opts, path) {\n\t  // If the host already has a path, then we need to have a path delimiter\n\t  // Otherwise, the path delimiter is the empty string\n\t  var pathDel = !opts.path ? '' : '/';\n\t\n\t  // If the host already has a path, then we need to have a path delimiter\n\t  // Otherwise, the path delimiter is the empty string\n\t  return opts.protocol + '://' + opts.host +\n\t         (opts.port ? (':' + opts.port) : '') +\n\t         '/' + opts.path + pathDel + path;\n\t}\n\t\n\tfunction paramsToStr(params) {\n\t  return '?' + Object.keys(params).map(function (k) {\n\t    return k + '=' + encodeURIComponent(params[k]);\n\t  }).join('&');\n\t}\n\t\n\t// Implements the PouchDB API for dealing with CouchDB instances over HTTP\n\tfunction HttpPouch(opts, callback) {\n\t  // The functions that will be publicly available for HttpPouch\n\t  var api = this;\n\t\n\t  // Parse the URI given by opts.name into an easy-to-use object\n\t  var getHostFun = getHost;\n\t\n\t  // TODO: this seems to only be used by yarong for the Thali project.\n\t  // Verify whether or not it's still needed.\n\t  /* istanbul ignore if */\n\t  if (opts.getHost) {\n\t    getHostFun = opts.getHost;\n\t  }\n\t\n\t  var host = getHostFun(opts.name, opts);\n\t  var dbUrl = genDBUrl(host, '');\n\t\n\t  opts = clone(opts);\n\t  var ajaxOpts = opts.ajax || {};\n\t\n\t  api.getUrl = function () { return dbUrl; };\n\t  api.getHeaders = function () { return ajaxOpts.headers || {}; };\n\t\n\t  if (opts.auth || host.auth) {\n\t    var nAuth = opts.auth || host.auth;\n\t    var str = nAuth.username + ':' + nAuth.password;\n\t    var token = btoa$1(unescape(encodeURIComponent(str)));\n\t    ajaxOpts.headers = ajaxOpts.headers || {};\n\t    ajaxOpts.headers.Authorization = 'Basic ' + token;\n\t  }\n\t\n\t  function ajax(userOpts, options, callback) {\n\t    var reqAjax = userOpts.ajax || {};\n\t    var reqOpts = jsExtend.extend(clone(ajaxOpts), reqAjax, options);\n\t    log$1(reqOpts.method + ' ' + reqOpts.url);\n\t    return utils.ajax(reqOpts, callback);\n\t  }\n\t\n\t  function ajaxPromise(userOpts, opts) {\n\t    return new PouchPromise(function (resolve, reject) {\n\t      ajax(userOpts, opts, function (err, res) {\n\t        if (err) {\n\t          return reject(err);\n\t        }\n\t        resolve(res);\n\t      });\n\t    });\n\t  }\n\t\n\t  function adapterFun$$(name, fun) {\n\t    return adapterFun(name, getArguments(function (args) {\n\t      setup().then(function () {\n\t        return fun.apply(this, args);\n\t      }).catch(function(e) {\n\t        var callback = args.pop();\n\t        callback(e);\n\t      });\n\t    }));\n\t  }\n\t\n\t  var setupPromise;\n\t\n\t  function setup() {\n\t    // TODO: Remove `skipSetup` in favor of `skip_setup` in a future release\n\t    if (opts.skipSetup || opts.skip_setup) {\n\t      return PouchPromise.resolve();\n\t    }\n\t\n\t    // If there is a setup in process or previous successful setup\n\t    // done then we will use that\n\t    // If previous setups have been rejected we will try again\n\t    if (setupPromise) {\n\t      return setupPromise;\n\t    }\n\t\n\t    var checkExists = {method: 'GET', url: dbUrl};\n\t    setupPromise = ajaxPromise({}, checkExists).catch(function(err) {\n\t      if (err && err.status && err.status === 404) {\n\t        // Doesnt exist, create it\n\t        explainError(404, 'PouchDB is just detecting if the remote exists.');\n\t        return ajaxPromise({}, {method: 'PUT', url: dbUrl});\n\t      } else {\n\t        return PouchPromise.reject(err);\n\t      }\n\t    }).catch(function(err) {\n\t      // If we try to create a database that already exists\n\t      if (err && err.status && err.status === 412) {\n\t        return true;\n\t      }\n\t      return PouchPromise.reject(err);\n\t    });\n\t\n\t    setupPromise.catch(function() {\n\t      setupPromise = null;\n\t    });\n\t\n\t    return setupPromise;\n\t  }\n\t\n\t  setTimeout(function() {\n\t    callback(null, api);\n\t  });\n\t\n\t  api.type = function () {\n\t    return 'http';\n\t  };\n\t\n\t  api.id = adapterFun$$('id', function (callback) {\n\t    ajax({}, {method: 'GET', url: genUrl(host, '')}, function (err, result) {\n\t      var uuid = (result && result.uuid) ?\n\t        (result.uuid + host.db) : genDBUrl(host, '');\n\t      callback(null, uuid);\n\t    });\n\t  });\n\t\n\t  api.request = adapterFun$$('request', function (options, callback) {\n\t    options.url = genDBUrl(host, options.url);\n\t    ajax({}, options, callback);\n\t  });\n\t\n\t  // Sends a POST request to the host calling the couchdb _compact function\n\t  //    version: The version of CouchDB it is running\n\t  api.compact = adapterFun$$('compact', function (opts, callback) {\n\t    if (typeof opts === 'function') {\n\t      callback = opts;\n\t      opts = {};\n\t    }\n\t    opts = clone(opts);\n\t    ajax(opts, {\n\t      url: genDBUrl(host, '_compact'),\n\t      method: 'POST'\n\t    }, function () {\n\t      function ping() {\n\t        api.info(function (err, res) {\n\t          if (res && !res.compact_running) {\n\t            callback(null, {ok: true});\n\t          } else {\n\t            setTimeout(ping, opts.interval || 200);\n\t          }\n\t        });\n\t      }\n\t      // Ping the http if it's finished compaction\n\t      ping();\n\t    });\n\t  });\n\t\n\t  api.bulkGet = adapterFun('bulkGet', function (opts, callback) {\n\t    var self = this;\n\t\n\t    function doBulkGet(cb) {\n\t      var params = {};\n\t      if (opts.revs) {\n\t        params.revs = true;\n\t      }\n\t      if (opts.attachments) {\n\t        params.attachments = true;\n\t      }\n\t      ajax({}, {\n\t        url: genDBUrl(host, '_bulk_get' + paramsToStr(params)),\n\t        method: 'POST',\n\t        body: { docs: opts.docs}\n\t      }, cb);\n\t    }\n\t\n\t    function doBulkGetShim() {\n\t      // avoid \"url too long error\" by splitting up into multiple requests\n\t      var batchSize = MAX_SIMULTANEOUS_REVS;\n\t      var numBatches = Math.ceil(opts.docs.length / batchSize);\n\t      var numDone = 0;\n\t      var results = new Array(numBatches);\n\t\n\t      function onResult(batchNum) {\n\t        return function (err, res) {\n\t          // err is impossible because shim returns a list of errs in that case\n\t          results[batchNum] = res.results;\n\t          if (++numDone === numBatches) {\n\t            callback(null, {results: flatten(results)});\n\t          }\n\t        };\n\t      }\n\t\n\t      for (var i = 0; i < numBatches; i++) {\n\t        var subOpts = pick(opts, ['revs', 'attachments']);\n\t        subOpts.docs = opts.docs.slice(i * batchSize,\n\t          Math.min(opts.docs.length, (i + 1) * batchSize));\n\t        bulkGet(self, subOpts, onResult(i));\n\t      }\n\t    }\n\t\n\t    // mark the whole database as either supporting or not supporting _bulk_get\n\t    var dbUrl = genUrl(host, '');\n\t    var supportsBulkGet = supportsBulkGetMap[dbUrl];\n\t\n\t    if (typeof supportsBulkGet !== 'boolean') {\n\t      // check if this database supports _bulk_get\n\t      doBulkGet(function (err, res) {\n\t        /* istanbul ignore else */\n\t        if (err) {\n\t          var status = Math.floor(err.status / 100);\n\t          /* istanbul ignore else */\n\t          if (status === 4 || status === 5) { // 40x or 50x\n\t            supportsBulkGetMap[dbUrl] = false;\n\t            explainError(\n\t              err.status,\n\t              'PouchDB is just detecting if the remote ' +\n\t              'supports the _bulk_get API.'\n\t            );\n\t            doBulkGetShim();\n\t          } else {\n\t            callback(err);\n\t          }\n\t        } else {\n\t          supportsBulkGetMap[dbUrl] = true;\n\t          callback(null, res);\n\t        }\n\t      });\n\t    } else if (supportsBulkGet) {\n\t      /* istanbul ignore next */\n\t      doBulkGet(callback);\n\t    } else {\n\t      doBulkGetShim();\n\t    }\n\t  });\n\t\n\t  // Calls GET on the host, which gets back a JSON string containing\n\t  //    couchdb: A welcome string\n\t  //    version: The version of CouchDB it is running\n\t  api._info = function (callback) {\n\t    setup().then(function() {\n\t      ajax({}, {\n\t        method: 'GET',\n\t        url: genDBUrl(host, '')\n\t      }, function (err, res) {\n\t        /* istanbul ignore next */\n\t        if (err) {\n\t        return callback(err);\n\t        }\n\t        res.host = genDBUrl(host, '');\n\t        callback(null, res);\n\t      });\n\t    }).catch(callback);\n\t  };\n\t\n\t  // Get the document with the given id from the database given by host.\n\t  // The id could be solely the _id in the database, or it may be a\n\t  // _design/ID or _local/ID path\n\t  api.get = adapterFun$$('get', function (id, opts, callback) {\n\t    // If no options were given, set the callback to the second parameter\n\t    if (typeof opts === 'function') {\n\t      callback = opts;\n\t      opts = {};\n\t    }\n\t    opts = clone(opts);\n\t\n\t    // List of parameters to add to the GET request\n\t    var params = {};\n\t\n\t    if (opts.revs) {\n\t      params.revs = true;\n\t    }\n\t\n\t    if (opts.revs_info) {\n\t      params.revs_info = true;\n\t    }\n\t\n\t    if (opts.open_revs) {\n\t      if (opts.open_revs !== \"all\") {\n\t        opts.open_revs = JSON.stringify(opts.open_revs);\n\t      }\n\t      params.open_revs = opts.open_revs;\n\t    }\n\t\n\t    if (opts.rev) {\n\t      params.rev = opts.rev;\n\t    }\n\t\n\t    if (opts.conflicts) {\n\t      params.conflicts = opts.conflicts;\n\t    }\n\t\n\t    id = encodeDocId(id);\n\t\n\t    // Set the options for the ajax call\n\t    var options = {\n\t      method: 'GET',\n\t      url: genDBUrl(host, id + paramsToStr(params))\n\t    };\n\t\n\t    function fetchAttachments(doc) {\n\t      var atts = doc._attachments;\n\t      var filenames = atts && Object.keys(atts);\n\t      if (!atts || !filenames.length) {\n\t        return;\n\t      }\n\t      // we fetch these manually in separate XHRs, because\n\t      // Sync Gateway would normally send it back as multipart/mixed,\n\t      // which we cannot parse. Also, this is more efficient than\n\t      // receiving attachments as base64-encoded strings.\n\t      return PouchPromise.all(filenames.map(function (filename) {\n\t        var att = atts[filename];\n\t        var path = encodeDocId(doc._id) + '/' + encodeAttachmentId(filename) +\n\t          '?rev=' + doc._rev;\n\t        return ajaxPromise(opts, {\n\t          method: 'GET',\n\t          url: genDBUrl(host, path),\n\t          binary: true\n\t        }).then(function (blob) {\n\t          if (opts.binary) {\n\t            return blob;\n\t          }\n\t          return blobToBase64(blob);\n\t        }).then(function (data) {\n\t          delete att.stub;\n\t          delete att.length;\n\t          att.data = data;\n\t        });\n\t      }));\n\t    }\n\t\n\t    function fetchAllAttachments(docOrDocs) {\n\t      if (Array.isArray(docOrDocs)) {\n\t        return PouchPromise.all(docOrDocs.map(function (doc) {\n\t          if (doc.ok) {\n\t            return fetchAttachments(doc.ok);\n\t          }\n\t        }));\n\t      }\n\t      return fetchAttachments(docOrDocs);\n\t    }\n\t\n\t    ajaxPromise(opts, options).then(function (res) {\n\t      return PouchPromise.resolve().then(function () {\n\t        if (opts.attachments) {\n\t          return fetchAllAttachments(res);\n\t        }\n\t      }).then(function () {\n\t        callback(null, res);\n\t      });\n\t    }).catch(callback);\n\t  });\n\t\n\t  // Delete the document given by doc from the database given by host.\n\t  api.remove = adapterFun$$('remove',\n\t      function (docOrId, optsOrRev, opts, callback) {\n\t    var doc;\n\t    if (typeof optsOrRev === 'string') {\n\t      // id, rev, opts, callback style\n\t      doc = {\n\t        _id: docOrId,\n\t        _rev: optsOrRev\n\t      };\n\t      if (typeof opts === 'function') {\n\t        callback = opts;\n\t        opts = {};\n\t      }\n\t    } else {\n\t      // doc, opts, callback style\n\t      doc = docOrId;\n\t      if (typeof optsOrRev === 'function') {\n\t        callback = optsOrRev;\n\t        opts = {};\n\t      } else {\n\t        callback = opts;\n\t        opts = optsOrRev;\n\t      }\n\t    }\n\t\n\t    var rev = (doc._rev || opts.rev);\n\t\n\t    // Delete the document\n\t    ajax(opts, {\n\t      method: 'DELETE',\n\t      url: genDBUrl(host, encodeDocId(doc._id)) + '?rev=' + rev\n\t    }, callback);\n\t  });\n\t\n\t  function encodeAttachmentId(attachmentId) {\n\t    return attachmentId.split(\"/\").map(encodeURIComponent).join(\"/\");\n\t  }\n\t\n\t  // Get the attachment\n\t  api.getAttachment =\n\t    adapterFun$$('getAttachment', function (docId, attachmentId, opts,\n\t                                                callback) {\n\t    if (typeof opts === 'function') {\n\t      callback = opts;\n\t      opts = {};\n\t    }\n\t    var params = opts.rev ? ('?rev=' + opts.rev) : '';\n\t    var url = genDBUrl(host, encodeDocId(docId)) + '/' +\n\t      encodeAttachmentId(attachmentId) + params;\n\t    ajax(opts, {\n\t      method: 'GET',\n\t      url: url,\n\t      binary: true\n\t    }, callback);\n\t  });\n\t\n\t  // Remove the attachment given by the id and rev\n\t  api.removeAttachment =\n\t    adapterFun$$('removeAttachment', function (docId, attachmentId, rev,\n\t                                                   callback) {\n\t\n\t    var url = genDBUrl(host, encodeDocId(docId) + '/' +\n\t      encodeAttachmentId(attachmentId)) + '?rev=' + rev;\n\t\n\t    ajax({}, {\n\t      method: 'DELETE',\n\t      url: url\n\t    }, callback);\n\t  });\n\t\n\t  // Add the attachment given by blob and its contentType property\n\t  // to the document with the given id, the revision given by rev, and\n\t  // add it to the database given by host.\n\t  api.putAttachment =\n\t    adapterFun$$('putAttachment', function (docId, attachmentId, rev, blob,\n\t                                                type, callback) {\n\t    if (typeof type === 'function') {\n\t      callback = type;\n\t      type = blob;\n\t      blob = rev;\n\t      rev = null;\n\t    }\n\t    var id = encodeDocId(docId) + '/' + encodeAttachmentId(attachmentId);\n\t    var url = genDBUrl(host, id);\n\t    if (rev) {\n\t      url += '?rev=' + rev;\n\t    }\n\t\n\t    if (typeof blob === 'string') {\n\t      // input is assumed to be a base64 string\n\t      var binary;\n\t      try {\n\t        binary = atob$1(blob);\n\t      } catch (err) {\n\t        return callback(createError(BAD_ARG,\n\t                        'Attachment is not a valid base64 string'));\n\t      }\n\t      blob = binary ? binStringToBluffer(binary, type) : '';\n\t    }\n\t\n\t    var opts = {\n\t      headers: {'Content-Type': type},\n\t      method: 'PUT',\n\t      url: url,\n\t      processData: false,\n\t      body: blob,\n\t      timeout: ajaxOpts.timeout || 60000\n\t    };\n\t    // Add the attachment\n\t    ajax({}, opts, callback);\n\t  });\n\t\n\t  // Update/create multiple documents given by req in the database\n\t  // given by host.\n\t  api._bulkDocs = function (req, opts, callback) {\n\t    // If new_edits=false then it prevents the database from creating\n\t    // new revision numbers for the documents. Instead it just uses\n\t    // the old ones. This is used in database replication.\n\t    req.new_edits = opts.new_edits;\n\t\n\t    setup().then(function () {\n\t      return PouchPromise.all(req.docs.map(preprocessAttachments));\n\t    }).then(function () {\n\t      // Update/create the documents\n\t      ajax(opts, {\n\t        method: 'POST',\n\t        url: genDBUrl(host, '_bulk_docs'),\n\t        body: req\n\t      }, function (err, results) {\n\t        if (err) {\n\t          return callback(err);\n\t        }\n\t        results.forEach(function (result) {\n\t          result.ok = true; // smooths out cloudant not adding this\n\t        });\n\t        callback(null, results);\n\t      });\n\t    }).catch(callback);\n\t  };\n\t\n\t  // Get a listing of the documents in the database given\n\t  // by host and ordered by increasing id.\n\t  api.allDocs = adapterFun$$('allDocs', function (opts, callback) {\n\t    if (typeof opts === 'function') {\n\t      callback = opts;\n\t      opts = {};\n\t    }\n\t    opts = clone(opts);\n\t\n\t    // List of parameters to add to the GET request\n\t    var params = {};\n\t    var body;\n\t    var method = 'GET';\n\t\n\t    if (opts.conflicts) {\n\t      params.conflicts = true;\n\t    }\n\t\n\t    if (opts.descending) {\n\t      params.descending = true;\n\t    }\n\t\n\t    if (opts.include_docs) {\n\t      params.include_docs = true;\n\t    }\n\t\n\t    // added in CouchDB 1.6.0\n\t    if (opts.attachments) {\n\t      params.attachments = true;\n\t    }\n\t\n\t    if (opts.key) {\n\t      params.key = JSON.stringify(opts.key);\n\t    }\n\t\n\t    if (opts.start_key) {\n\t      opts.startkey = opts.start_key;\n\t    }\n\t\n\t    if (opts.startkey) {\n\t      params.startkey = JSON.stringify(opts.startkey);\n\t    }\n\t\n\t    if (opts.end_key) {\n\t      opts.endkey = opts.end_key;\n\t    }\n\t\n\t    if (opts.endkey) {\n\t      params.endkey = JSON.stringify(opts.endkey);\n\t    }\n\t\n\t    if (typeof opts.inclusive_end !== 'undefined') {\n\t      params.inclusive_end = !!opts.inclusive_end;\n\t    }\n\t\n\t    if (typeof opts.limit !== 'undefined') {\n\t      params.limit = opts.limit;\n\t    }\n\t\n\t    if (typeof opts.skip !== 'undefined') {\n\t      params.skip = opts.skip;\n\t    }\n\t\n\t    var paramStr = paramsToStr(params);\n\t\n\t    if (typeof opts.keys !== 'undefined') {\n\t\n\t      var keysAsString =\n\t        'keys=' + encodeURIComponent(JSON.stringify(opts.keys));\n\t      if (keysAsString.length + paramStr.length + 1 <= MAX_URL_LENGTH) {\n\t        // If the keys are short enough, do a GET. we do this to work around\n\t        // Safari not understanding 304s on POSTs (see issue #1239)\n\t        paramStr += '&' + keysAsString;\n\t      } else {\n\t        // If keys are too long, issue a POST request to circumvent GET\n\t        // query string limits\n\t        // see http://wiki.apache.org/couchdb/HTTP_view_API#Querying_Options\n\t        method = 'POST';\n\t        body = {keys: opts.keys};\n\t      }\n\t    }\n\t\n\t    // Get the document listing\n\t    ajaxPromise(opts, {\n\t      method: method,\n\t      url: genDBUrl(host, '_all_docs' + paramStr),\n\t      body: body\n\t    }).then(function (res) {\n\t      if (opts.include_docs && opts.attachments && opts.binary) {\n\t        res.rows.forEach(readAttachmentsAsBlobOrBuffer);\n\t      }\n\t      callback(null, res);\n\t    }).catch(callback);\n\t  });\n\t\n\t  // Get a list of changes made to documents in the database given by host.\n\t  // TODO According to the README, there should be two other methods here,\n\t  // api.changes.addListener and api.changes.removeListener.\n\t  api._changes = function (opts) {\n\t\n\t    // We internally page the results of a changes request, this means\n\t    // if there is a large set of changes to be returned we can start\n\t    // processing them quicker instead of waiting on the entire\n\t    // set of changes to return and attempting to process them at once\n\t    var batchSize = 'batch_size' in opts ? opts.batch_size : CHANGES_BATCH_SIZE;\n\t\n\t    opts = clone(opts);\n\t    opts.timeout = ('timeout' in opts) ? opts.timeout :\n\t      ('timeout' in ajaxOpts) ? ajaxOpts.timeout :\n\t      30 * 1000;\n\t\n\t    // We give a 5 second buffer for CouchDB changes to respond with\n\t    // an ok timeout (if a timeout it set)\n\t    var params = opts.timeout ? {timeout: opts.timeout - (5 * 1000)} : {};\n\t    var limit = (typeof opts.limit !== 'undefined') ? opts.limit : false;\n\t    var returnDocs;\n\t    if ('return_docs' in opts) {\n\t      returnDocs = opts.return_docs;\n\t    } else if ('returnDocs' in opts) {\n\t      // TODO: Remove 'returnDocs' in favor of 'return_docs' in a future release\n\t      returnDocs = opts.returnDocs;\n\t    } else {\n\t      returnDocs = true;\n\t    }\n\t    //\n\t    var leftToFetch = limit;\n\t\n\t    if (opts.style) {\n\t      params.style = opts.style;\n\t    }\n\t\n\t    if (opts.include_docs || opts.filter && typeof opts.filter === 'function') {\n\t      params.include_docs = true;\n\t    }\n\t\n\t    if (opts.attachments) {\n\t      params.attachments = true;\n\t    }\n\t\n\t    if (opts.continuous) {\n\t      params.feed = 'longpoll';\n\t    }\n\t\n\t    if (opts.conflicts) {\n\t      params.conflicts = true;\n\t    }\n\t\n\t    if (opts.descending) {\n\t      params.descending = true;\n\t    }\n\t\n\t    if ('heartbeat' in opts) {\n\t      // If the heartbeat value is false, it disables the default heartbeat\n\t      if (opts.heartbeat) {\n\t        params.heartbeat = opts.heartbeat;\n\t      }\n\t    } else {\n\t      // Default heartbeat to 10 seconds\n\t      params.heartbeat = 10000;\n\t    }\n\t\n\t    if (opts.filter && typeof opts.filter === 'string') {\n\t      params.filter = opts.filter;\n\t      if (opts.filter === '_view' &&\n\t          opts.view &&\n\t          typeof opts.view === 'string') {\n\t        params.view = opts.view;\n\t      }\n\t    }\n\t\n\t    // If opts.query_params exists, pass it through to the changes request.\n\t    // These parameters may be used by the filter on the source database.\n\t    if (opts.query_params && typeof opts.query_params === 'object') {\n\t      for (var param_name in opts.query_params) {\n\t        /* istanbul ignore else */\n\t        if (opts.query_params.hasOwnProperty(param_name)) {\n\t          params[param_name] = opts.query_params[param_name];\n\t        }\n\t      }\n\t    }\n\t\n\t    var method = 'GET';\n\t    var body;\n\t\n\t    if (opts.doc_ids) {\n\t      // set this automagically for the user; it's annoying that couchdb\n\t      // requires both a \"filter\" and a \"doc_ids\" param.\n\t      params.filter = '_doc_ids';\n\t\n\t      var docIdsJson = JSON.stringify(opts.doc_ids);\n\t\n\t      if (docIdsJson.length < MAX_URL_LENGTH) {\n\t        params.doc_ids = docIdsJson;\n\t      } else {\n\t        // anything greater than ~2000 is unsafe for gets, so\n\t        // use POST instead\n\t        method = 'POST';\n\t        body = {doc_ids: opts.doc_ids };\n\t      }\n\t    }\n\t\n\t    var xhr;\n\t    var lastFetchedSeq;\n\t\n\t    // Get all the changes starting wtih the one immediately after the\n\t    // sequence number given by since.\n\t    var fetch = function (since, callback) {\n\t      if (opts.aborted) {\n\t        return;\n\t      }\n\t      params.since = since;\n\t      // \"since\" can be any kind of json object in Coudant/CouchDB 2.x\n\t      /* istanbul ignore next */\n\t      if (typeof params.since === \"object\") {\n\t        params.since = JSON.stringify(params.since);\n\t      }\n\t\n\t      if (opts.descending) {\n\t        if (limit) {\n\t          params.limit = leftToFetch;\n\t        }\n\t      } else {\n\t        params.limit = (!limit || leftToFetch > batchSize) ?\n\t          batchSize : leftToFetch;\n\t      }\n\t\n\t      // Set the options for the ajax call\n\t      var xhrOpts = {\n\t        method: method,\n\t        url: genDBUrl(host, '_changes' + paramsToStr(params)),\n\t        timeout: opts.timeout,\n\t        body: body\n\t      };\n\t      lastFetchedSeq = since;\n\t\n\t      /* istanbul ignore if */\n\t      if (opts.aborted) {\n\t        return;\n\t      }\n\t\n\t      // Get the changes\n\t      setup().then(function() {\n\t        xhr = ajax(opts, xhrOpts, callback);\n\t      }).catch(callback);\n\t    };\n\t\n\t    // If opts.since exists, get all the changes from the sequence\n\t    // number given by opts.since. Otherwise, get all the changes\n\t    // from the sequence number 0.\n\t    var results = {results: []};\n\t\n\t    var fetched = function (err, res) {\n\t      if (opts.aborted) {\n\t        return;\n\t      }\n\t      var raw_results_length = 0;\n\t      // If the result of the ajax call (res) contains changes (res.results)\n\t      if (res && res.results) {\n\t        raw_results_length = res.results.length;\n\t        results.last_seq = res.last_seq;\n\t        // For each change\n\t        var req = {};\n\t        req.query = opts.query_params;\n\t        res.results = res.results.filter(function (c) {\n\t          leftToFetch--;\n\t          var ret = filterChange(opts)(c);\n\t          if (ret) {\n\t            if (opts.include_docs && opts.attachments && opts.binary) {\n\t              readAttachmentsAsBlobOrBuffer(c);\n\t            }\n\t            if (returnDocs) {\n\t              results.results.push(c);\n\t            }\n\t            opts.onChange(c);\n\t          }\n\t          return ret;\n\t        });\n\t      } else if (err) {\n\t        // In case of an error, stop listening for changes and call\n\t        // opts.complete\n\t        opts.aborted = true;\n\t        opts.complete(err);\n\t        return;\n\t      }\n\t\n\t      // The changes feed may have timed out with no results\n\t      // if so reuse last update sequence\n\t      if (res && res.last_seq) {\n\t        lastFetchedSeq = res.last_seq;\n\t      }\n\t\n\t      var finished = (limit && leftToFetch <= 0) ||\n\t        (res && raw_results_length < batchSize) ||\n\t        (opts.descending);\n\t\n\t      if ((opts.continuous && !(limit && leftToFetch <= 0)) || !finished) {\n\t        // Queue a call to fetch again with the newest sequence number\n\t        setTimeout(function () { fetch(lastFetchedSeq, fetched); }, 0);\n\t      } else {\n\t        // We're done, call the callback\n\t        opts.complete(null, results);\n\t      }\n\t    };\n\t\n\t    fetch(opts.since || 0, fetched);\n\t\n\t    // Return a method to cancel this method from processing any more\n\t    return {\n\t      cancel: function () {\n\t        opts.aborted = true;\n\t        if (xhr) {\n\t          xhr.abort();\n\t        }\n\t      }\n\t    };\n\t  };\n\t\n\t  // Given a set of document/revision IDs (given by req), tets the subset of\n\t  // those that do NOT correspond to revisions stored in the database.\n\t  // See http://wiki.apache.org/couchdb/HttpPostRevsDiff\n\t  api.revsDiff = adapterFun$$('revsDiff', function (req, opts, callback) {\n\t    // If no options were given, set the callback to be the second parameter\n\t    if (typeof opts === 'function') {\n\t      callback = opts;\n\t      opts = {};\n\t    }\n\t\n\t    // Get the missing document/revision IDs\n\t    ajax(opts, {\n\t      method: 'POST',\n\t      url: genDBUrl(host, '_revs_diff'),\n\t      body: req\n\t    }, callback);\n\t  });\n\t\n\t  api._close = function (callback) {\n\t    callback();\n\t  };\n\t\n\t  api._destroy = function (options, callback) {\n\t    ajax(options, {\n\t      url: genDBUrl(host, ''),\n\t      method: 'DELETE'\n\t    }, function (err, resp) {\n\t      if (err && err.status && err.status !== 404) {\n\t        return callback(err);\n\t      }\n\t      api.emit('destroyed');\n\t      api.constructor.emit('destroyed', opts.name);\n\t      callback(null, resp);\n\t    });\n\t  };\n\t}\n\t\n\t// HttpPouch is a valid adapter.\n\tHttpPouch.valid = function () {\n\t  return true;\n\t};\n\t\n\tfunction TaskQueue$1() {\n\t  this.promise = new PouchPromise(function (fulfill) {fulfill(); });\n\t}\n\tTaskQueue$1.prototype.add = function (promiseFactory) {\n\t  this.promise = this.promise.catch(function () {\n\t    // just recover\n\t  }).then(function () {\n\t    return promiseFactory();\n\t  });\n\t  return this.promise;\n\t};\n\tTaskQueue$1.prototype.finish = function () {\n\t  return this.promise;\n\t};\n\t\n\tfunction md5$1(string) {\n\t  return Md5.hash(string);\n\t}\n\t\n\tfunction createView(opts) {\n\t  var sourceDB = opts.db;\n\t  var viewName = opts.viewName;\n\t  var mapFun = opts.map;\n\t  var reduceFun = opts.reduce;\n\t  var temporary = opts.temporary;\n\t\n\t  // the \"undefined\" part is for backwards compatibility\n\t  var viewSignature = mapFun.toString() + (reduceFun && reduceFun.toString()) +\n\t    'undefined';\n\t\n\t  if (!temporary && sourceDB._cachedViews) {\n\t    var cachedView = sourceDB._cachedViews[viewSignature];\n\t    if (cachedView) {\n\t      return PouchPromise.resolve(cachedView);\n\t    }\n\t  }\n\t\n\t  return sourceDB.info().then(function (info) {\n\t\n\t    var depDbName = info.db_name + '-mrview-' +\n\t      (temporary ? 'temp' : md5$1(viewSignature));\n\t\n\t    // save the view name in the source db so it can be cleaned up if necessary\n\t    // (e.g. when the _design doc is deleted, remove all associated view data)\n\t    function diffFunction(doc) {\n\t      doc.views = doc.views || {};\n\t      var fullViewName = viewName;\n\t      if (fullViewName.indexOf('/') === -1) {\n\t        fullViewName = viewName + '/' + viewName;\n\t      }\n\t      var depDbs = doc.views[fullViewName] = doc.views[fullViewName] || {};\n\t      /* istanbul ignore if */\n\t      if (depDbs[depDbName]) {\n\t        return; // no update necessary\n\t      }\n\t      depDbs[depDbName] = true;\n\t      return doc;\n\t    }\n\t    return upsert(sourceDB, '_local/mrviews', diffFunction).then(function () {\n\t      return sourceDB.registerDependentDatabase(depDbName).then(function (res) {\n\t        var db = res.db;\n\t        db.auto_compaction = true;\n\t        var view = {\n\t          name: depDbName,\n\t          db: db,\n\t          sourceDB: sourceDB,\n\t          adapter: sourceDB.adapter,\n\t          mapFun: mapFun,\n\t          reduceFun: reduceFun\n\t        };\n\t        return view.db.get('_local/lastSeq').catch(function (err) {\n\t          /* istanbul ignore if */\n\t          if (err.status !== 404) {\n\t            throw err;\n\t          }\n\t        }).then(function (lastSeqDoc) {\n\t          view.seq = lastSeqDoc ? lastSeqDoc.seq : 0;\n\t          if (!temporary) {\n\t            sourceDB._cachedViews = sourceDB._cachedViews || {};\n\t            sourceDB._cachedViews[viewSignature] = view;\n\t            view.db.once('destroyed', function () {\n\t              delete sourceDB._cachedViews[viewSignature];\n\t            });\n\t          }\n\t          return view;\n\t        });\n\t      });\n\t    });\n\t  });\n\t}\n\t\n\tfunction evalfunc(func, emit, sum, log, isArray, toJSON) {\n\t  return scopedEval(\n\t    \"return (\" + func.replace(/;\\s*$/, \"\") + \");\",\n\t    {\n\t      emit: emit,\n\t      sum: sum,\n\t      log: log,\n\t      isArray: isArray,\n\t      toJSON: toJSON\n\t    }\n\t  );\n\t}\n\t\n\tvar promisedCallback$1 = function (promise, callback) {\n\t  if (callback) {\n\t    promise.then(function (res) {\n\t      process.nextTick(function () {\n\t        callback(null, res);\n\t      });\n\t    }, function (reason) {\n\t      process.nextTick(function () {\n\t        callback(reason);\n\t      });\n\t    });\n\t  }\n\t  return promise;\n\t};\n\t\n\tvar callbackify$1 = function (fun) {\n\t  return getArguments(function (args) {\n\t    var cb = args.pop();\n\t    var promise = fun.apply(this, args);\n\t    if (typeof cb === 'function') {\n\t      promisedCallback$1(promise, cb);\n\t    }\n\t    return promise;\n\t  });\n\t};\n\t\n\t// Promise finally util similar to Q.finally\n\tvar fin$1 = function (promise, finalPromiseFactory) {\n\t  return promise.then(function (res) {\n\t    return finalPromiseFactory().then(function () {\n\t      return res;\n\t    });\n\t  }, function (reason) {\n\t    return finalPromiseFactory().then(function () {\n\t      throw reason;\n\t    });\n\t  });\n\t};\n\t\n\tvar sequentialize$1 = function (queue, promiseFactory) {\n\t  return function () {\n\t    var args = arguments;\n\t    var that = this;\n\t    return queue.add(function () {\n\t      return promiseFactory.apply(that, args);\n\t    });\n\t  };\n\t};\n\t\n\t// uniq an array of strings, order not guaranteed\n\t// similar to underscore/lodash _.uniq\n\tvar uniq$1 = function (arr) {\n\t  var map = {};\n\t\n\t  for (var i = 0, len = arr.length; i < len; i++) {\n\t    map['$' + arr[i]] = true;\n\t  }\n\t\n\t  var keys = Object.keys(map);\n\t  var output = new Array(keys.length);\n\t\n\t  for (i = 0, len = keys.length; i < len; i++) {\n\t    output[i] = keys[i].substring(1);\n\t  }\n\t  return output;\n\t};\n\t\n\tvar utils$1 = {\n\t  uniq: uniq$1,\n\t  sequentialize: sequentialize$1,\n\t  fin: fin$1,\n\t  callbackify: callbackify$1,\n\t  promisedCallback: promisedCallback$1\n\t};\n\t\n\tvar collate$2 = pouchCollate__default.collate;\n\tvar toIndexableString = pouchCollate__default.toIndexableString;\n\tvar normalizeKey = pouchCollate__default.normalizeKey;\n\tvar parseIndexableString = pouchCollate__default.parseIndexableString;\n\tvar log$2;\n\t/* istanbul ignore else */\n\tif ((typeof console !== 'undefined') && (typeof console.log === 'function')) {\n\t  log$2 = Function.prototype.bind.call(console.log, console);\n\t} else {\n\t  log$2 = function () {};\n\t}\n\tvar callbackify = utils$1.callbackify;\n\tvar sequentialize = utils$1.sequentialize;\n\tvar uniq = utils$1.uniq;\n\tvar fin = utils$1.fin;\n\tvar promisedCallback = utils$1.promisedCallback;\n\tvar persistentQueues = {};\n\tvar tempViewQueue = new TaskQueue$1();\n\tvar CHANGES_BATCH_SIZE$1 = 50;\n\t\n\tfunction parseViewName(name) {\n\t  // can be either 'ddocname/viewname' or just 'viewname'\n\t  // (where the ddoc name is the same)\n\t  return name.indexOf('/') === -1 ? [name, name] : name.split('/');\n\t}\n\t\n\tfunction isGenOne$1(changes) {\n\t  // only return true if the current change is 1-\n\t  // and there are no other leafs\n\t  return changes.length === 1 && /^1-/.test(changes[0].rev);\n\t}\n\t\n\tfunction emitError(db, e) {\n\t  try {\n\t    db.emit('error', e);\n\t  } catch (err) {\n\t    console.error(\n\t      'The user\\'s map/reduce function threw an uncaught error.\\n' +\n\t      'You can debug this error by doing:\\n' +\n\t      'myDatabase.on(\\'error\\', function (err) { debugger; });\\n' +\n\t      'Please double-check your map/reduce function.');\n\t    console.error(e);\n\t  }\n\t}\n\t\n\tfunction tryCode(db, fun, args) {\n\t  // emit an event if there was an error thrown by a map/reduce function.\n\t  // putting try/catches in a single function also avoids deoptimizations.\n\t  try {\n\t    return {\n\t      output : fun.apply(null, args)\n\t    };\n\t  } catch (e) {\n\t    emitError(db, e);\n\t    return {error: e};\n\t  }\n\t}\n\t\n\tfunction sortByKeyThenValue(x, y) {\n\t  var keyCompare = collate$2(x.key, y.key);\n\t  return keyCompare !== 0 ? keyCompare : collate$2(x.value, y.value);\n\t}\n\t\n\tfunction sliceResults(results, limit, skip) {\n\t  skip = skip || 0;\n\t  if (typeof limit === 'number') {\n\t    return results.slice(skip, limit + skip);\n\t  } else if (skip > 0) {\n\t    return results.slice(skip);\n\t  }\n\t  return results;\n\t}\n\t\n\tfunction rowToDocId(row) {\n\t  var val = row.value;\n\t  // Users can explicitly specify a joined doc _id, or it\n\t  // defaults to the doc _id that emitted the key/value.\n\t  var docId = (val && typeof val === 'object' && val._id) || row.id;\n\t  return docId;\n\t}\n\t\n\tfunction readAttachmentsAsBlobOrBuffer$1(res) {\n\t  res.rows.forEach(function (row) {\n\t    var atts = row.doc && row.doc._attachments;\n\t    if (!atts) {\n\t      return;\n\t    }\n\t    Object.keys(atts).forEach(function (filename) {\n\t      var att = atts[filename];\n\t      atts[filename].data = b64ToBluffer(att.data, att.content_type);\n\t    });\n\t  });\n\t}\n\t\n\tfunction postprocessAttachments(opts) {\n\t  return function (res) {\n\t    if (opts.include_docs && opts.attachments && opts.binary) {\n\t      readAttachmentsAsBlobOrBuffer$1(res);\n\t    }\n\t    return res;\n\t  };\n\t}\n\t\n\tfunction createBuiltInError(name) {\n\t  var message = 'builtin ' + name +\n\t    ' function requires map values to be numbers' +\n\t    ' or number arrays';\n\t  return new BuiltInError(message);\n\t}\n\t\n\tfunction sum(values) {\n\t  var result = 0;\n\t  for (var i = 0, len = values.length; i < len; i++) {\n\t    var num = values[i];\n\t    if (typeof num !== 'number') {\n\t      if (Array.isArray(num)) {\n\t        // lists of numbers are also allowed, sum them separately\n\t        result = typeof result === 'number' ? [result] : result;\n\t        for (var j = 0, jLen = num.length; j < jLen; j++) {\n\t          var jNum = num[j];\n\t          if (typeof jNum !== 'number') {\n\t            throw createBuiltInError('_sum');\n\t          } else if (typeof result[j] === 'undefined') {\n\t            result.push(jNum);\n\t          } else {\n\t            result[j] += jNum;\n\t          }\n\t        }\n\t      } else { // not array/number\n\t        throw createBuiltInError('_sum');\n\t      }\n\t    } else if (typeof result === 'number') {\n\t      result += num;\n\t    } else { // add number to array\n\t      result[0] += num;\n\t    }\n\t  }\n\t  return result;\n\t}\n\t\n\tvar builtInReduce = {\n\t  _sum: function (keys, values) {\n\t    return sum(values);\n\t  },\n\t\n\t  _count: function (keys, values) {\n\t    return values.length;\n\t  },\n\t\n\t  _stats: function (keys, values) {\n\t    // no need to implement rereduce=true, because Pouch\n\t    // will never call it\n\t    function sumsqr(values) {\n\t      var _sumsqr = 0;\n\t      for (var i = 0, len = values.length; i < len; i++) {\n\t        var num = values[i];\n\t        _sumsqr += (num * num);\n\t      }\n\t      return _sumsqr;\n\t    }\n\t    return {\n\t      sum     : sum(values),\n\t      min     : Math.min.apply(null, values),\n\t      max     : Math.max.apply(null, values),\n\t      count   : values.length,\n\t      sumsqr : sumsqr(values)\n\t    };\n\t  }\n\t};\n\t\n\tfunction addHttpParam(paramName, opts, params, asJson) {\n\t  // add an http param from opts to params, optionally json-encoded\n\t  var val = opts[paramName];\n\t  if (typeof val !== 'undefined') {\n\t    if (asJson) {\n\t      val = encodeURIComponent(JSON.stringify(val));\n\t    }\n\t    params.push(paramName + '=' + val);\n\t  }\n\t}\n\t\n\tfunction coerceInteger (integerCandidate) {\n\t  if (typeof integerCandidate !== 'undefined') {\n\t    var asNumber = Number(integerCandidate);\n\t    // prevents e.g. '1foo' or '1.1' being coerced to 1\n\t    if (!isNaN(asNumber) && asNumber === parseInt(integerCandidate, 10)) {\n\t      return asNumber;\n\t    } else {\n\t      return integerCandidate;\n\t    }\n\t  }\n\t}\n\t\n\tfunction coerceOptions(opts) {\n\t  opts.group_level = coerceInteger(opts.group_level);\n\t  opts.limit = coerceInteger(opts.limit);\n\t  opts.skip = coerceInteger(opts.skip);\n\t  return opts;\n\t}\n\t\n\tfunction checkPositiveInteger (number) {\n\t  if (number) {\n\t    if (typeof number !== 'number') {\n\t      return  new QueryParseError('Invalid value for integer: \"' +\n\t      number + '\"');\n\t    }\n\t    if (number < 0) {\n\t      return new QueryParseError('Invalid value for positive integer: ' +\n\t        '\"' + number + '\"');\n\t    }\n\t  }\n\t}\n\t\n\tfunction checkQueryParseError(options, fun) {\n\t  var startkeyName = options.descending ? 'endkey' : 'startkey';\n\t  var endkeyName = options.descending ? 'startkey' : 'endkey';\n\t\n\t  if (typeof options[startkeyName] !== 'undefined' &&\n\t    typeof options[endkeyName] !== 'undefined' &&\n\t    collate$2(options[startkeyName], options[endkeyName]) > 0) {\n\t    throw new QueryParseError('No rows can match your key range, ' +\n\t    'reverse your start_key and end_key or set {descending : true}');\n\t  } else if (fun.reduce && options.reduce !== false) {\n\t    if (options.include_docs) {\n\t      throw new QueryParseError('{include_docs:true} is invalid for reduce');\n\t    } else if (options.keys && options.keys.length > 1 &&\n\t        !options.group && !options.group_level) {\n\t      throw new QueryParseError('Multi-key fetches for reduce views must use ' +\n\t      '{group: true}');\n\t    }\n\t  }\n\t  ['group_level', 'limit', 'skip'].forEach(function (optionName) {\n\t    var error = checkPositiveInteger(options[optionName]);\n\t    if (error) {\n\t      throw error;\n\t    }\n\t  });\n\t}\n\t\n\tfunction httpQuery(db, fun, opts) {\n\t  // List of parameters to add to the PUT request\n\t  var params = [];\n\t  var body;\n\t  var method = 'GET';\n\t\n\t  // If opts.reduce exists and is defined, then add it to the list\n\t  // of parameters.\n\t  // If reduce=false then the results are that of only the map function\n\t  // not the final result of map and reduce.\n\t  addHttpParam('reduce', opts, params);\n\t  addHttpParam('include_docs', opts, params);\n\t  addHttpParam('attachments', opts, params);\n\t  addHttpParam('limit', opts, params);\n\t  addHttpParam('descending', opts, params);\n\t  addHttpParam('group', opts, params);\n\t  addHttpParam('group_level', opts, params);\n\t  addHttpParam('skip', opts, params);\n\t  addHttpParam('stale', opts, params);\n\t  addHttpParam('conflicts', opts, params);\n\t  addHttpParam('startkey', opts, params, true);\n\t  addHttpParam('start_key', opts, params, true);\n\t  addHttpParam('endkey', opts, params, true);\n\t  addHttpParam('end_key', opts, params, true);\n\t  addHttpParam('inclusive_end', opts, params);\n\t  addHttpParam('key', opts, params, true);\n\t\n\t  // Format the list of parameters into a valid URI query string\n\t  params = params.join('&');\n\t  params = params === '' ? '' : '?' + params;\n\t\n\t  // If keys are supplied, issue a POST to circumvent GET query string limits\n\t  // see http://wiki.apache.org/couchdb/HTTP_view_API#Querying_Options\n\t  if (typeof opts.keys !== 'undefined') {\n\t    var MAX_URL_LENGTH = 2000;\n\t    // according to http://stackoverflow.com/a/417184/680742,\n\t    // the de facto URL length limit is 2000 characters\n\t\n\t    var keysAsString =\n\t      'keys=' + encodeURIComponent(JSON.stringify(opts.keys));\n\t    if (keysAsString.length + params.length + 1 <= MAX_URL_LENGTH) {\n\t      // If the keys are short enough, do a GET. we do this to work around\n\t      // Safari not understanding 304s on POSTs (see pouchdb/pouchdb#1239)\n\t      params += (params[0] === '?' ? '&' : '?') + keysAsString;\n\t    } else {\n\t      method = 'POST';\n\t      if (typeof fun === 'string') {\n\t        body = {keys: opts.keys};\n\t      } else { // fun is {map : mapfun}, so append to this\n\t        fun.keys = opts.keys;\n\t      }\n\t    }\n\t  }\n\t\n\t  // We are referencing a query defined in the design doc\n\t  if (typeof fun === 'string') {\n\t    var parts = parseViewName(fun);\n\t    return db.request({\n\t      method: method,\n\t      url: '_design/' + parts[0] + '/_view/' + parts[1] + params,\n\t      body: body\n\t    }).then(postprocessAttachments(opts));\n\t  }\n\t\n\t  // We are using a temporary view, terrible for performance, good for testing\n\t  body = body || {};\n\t  Object.keys(fun).forEach(function (key) {\n\t    if (Array.isArray(fun[key])) {\n\t      body[key] = fun[key];\n\t    } else {\n\t      body[key] = fun[key].toString();\n\t    }\n\t  });\n\t  return db.request({\n\t    method: 'POST',\n\t    url: '_temp_view' + params,\n\t    body: body\n\t  }).then(postprocessAttachments(opts));\n\t}\n\t\n\t// custom adapters can define their own api._query\n\t// and override the default behavior\n\t/* istanbul ignore next */\n\tfunction customQuery(db, fun, opts) {\n\t  return new PouchPromise(function (resolve, reject) {\n\t    db._query(fun, opts, function (err, res) {\n\t      if (err) {\n\t        return reject(err);\n\t      }\n\t      resolve(res);\n\t    });\n\t  });\n\t}\n\t\n\t// custom adapters can define their own api._viewCleanup\n\t// and override the default behavior\n\t/* istanbul ignore next */\n\tfunction customViewCleanup(db) {\n\t  return new PouchPromise(function (resolve, reject) {\n\t    db._viewCleanup(function (err, res) {\n\t      if (err) {\n\t        return reject(err);\n\t      }\n\t      resolve(res);\n\t    });\n\t  });\n\t}\n\t\n\tfunction defaultsTo(value) {\n\t  return function (reason) {\n\t    /* istanbul ignore else */\n\t    if (reason.status === 404) {\n\t      return value;\n\t    } else {\n\t      throw reason;\n\t    }\n\t  };\n\t}\n\t\n\t// returns a promise for a list of docs to update, based on the input docId.\n\t// the order doesn't matter, because post-3.2.0, bulkDocs\n\t// is an atomic operation in all three adapters.\n\tfunction getDocsToPersist(docId, view, docIdsToChangesAndEmits) {\n\t  var metaDocId = '_local/doc_' + docId;\n\t  var defaultMetaDoc = {_id: metaDocId, keys: []};\n\t  var docData = docIdsToChangesAndEmits[docId];\n\t  var indexableKeysToKeyValues = docData.indexableKeysToKeyValues;\n\t  var changes = docData.changes;\n\t\n\t  function getMetaDoc() {\n\t    if (isGenOne$1(changes)) {\n\t      // generation 1, so we can safely assume initial state\n\t      // for performance reasons (avoids unnecessary GETs)\n\t      return PouchPromise.resolve(defaultMetaDoc);\n\t    }\n\t    return view.db.get(metaDocId).catch(defaultsTo(defaultMetaDoc));\n\t  }\n\t\n\t  function getKeyValueDocs(metaDoc) {\n\t    if (!metaDoc.keys.length) {\n\t      // no keys, no need for a lookup\n\t      return PouchPromise.resolve({rows: []});\n\t    }\n\t    return view.db.allDocs({\n\t      keys: metaDoc.keys,\n\t      include_docs: true\n\t    });\n\t  }\n\t\n\t  function processKvDocs(metaDoc, kvDocsRes) {\n\t    var kvDocs = [];\n\t    var oldKeysMap = {};\n\t\n\t    for (var i = 0, len = kvDocsRes.rows.length; i < len; i++) {\n\t      var row = kvDocsRes.rows[i];\n\t      var doc = row.doc;\n\t      if (!doc) { // deleted\n\t        continue;\n\t      }\n\t      kvDocs.push(doc);\n\t      oldKeysMap[doc._id] = true;\n\t      doc._deleted = !indexableKeysToKeyValues[doc._id];\n\t      if (!doc._deleted) {\n\t        var keyValue = indexableKeysToKeyValues[doc._id];\n\t        if ('value' in keyValue) {\n\t          doc.value = keyValue.value;\n\t        }\n\t      }\n\t    }\n\t\n\t    var newKeys = Object.keys(indexableKeysToKeyValues);\n\t    newKeys.forEach(function (key) {\n\t      if (!oldKeysMap[key]) {\n\t        // new doc\n\t        var kvDoc = {\n\t          _id: key\n\t        };\n\t        var keyValue = indexableKeysToKeyValues[key];\n\t        if ('value' in keyValue) {\n\t          kvDoc.value = keyValue.value;\n\t        }\n\t        kvDocs.push(kvDoc);\n\t      }\n\t    });\n\t    metaDoc.keys = uniq(newKeys.concat(metaDoc.keys));\n\t    kvDocs.push(metaDoc);\n\t\n\t    return kvDocs;\n\t  }\n\t\n\t  return getMetaDoc().then(function (metaDoc) {\n\t    return getKeyValueDocs(metaDoc).then(function (kvDocsRes) {\n\t      return processKvDocs(metaDoc, kvDocsRes);\n\t    });\n\t  });\n\t}\n\t\n\t// updates all emitted key/value docs and metaDocs in the mrview database\n\t// for the given batch of documents from the source database\n\tfunction saveKeyValues(view, docIdsToChangesAndEmits, seq) {\n\t  var seqDocId = '_local/lastSeq';\n\t  return view.db.get(seqDocId)\n\t  .catch(defaultsTo({_id: seqDocId, seq: 0}))\n\t  .then(function (lastSeqDoc) {\n\t    var docIds = Object.keys(docIdsToChangesAndEmits);\n\t    return PouchPromise.all(docIds.map(function (docId) {\n\t      return getDocsToPersist(docId, view, docIdsToChangesAndEmits);\n\t    })).then(function (listOfDocsToPersist) {\n\t      var docsToPersist = flatten(listOfDocsToPersist);\n\t      lastSeqDoc.seq = seq;\n\t      docsToPersist.push(lastSeqDoc);\n\t      // write all docs in a single operation, update the seq once\n\t      return view.db.bulkDocs({docs : docsToPersist});\n\t    });\n\t  });\n\t}\n\t\n\tfunction getQueue(view) {\n\t  var viewName = typeof view === 'string' ? view : view.name;\n\t  var queue = persistentQueues[viewName];\n\t  if (!queue) {\n\t    queue = persistentQueues[viewName] = new TaskQueue$1();\n\t  }\n\t  return queue;\n\t}\n\t\n\tfunction updateView(view) {\n\t  return sequentialize(getQueue(view), function () {\n\t    return updateViewInQueue(view);\n\t  })();\n\t}\n\t\n\tfunction updateViewInQueue(view) {\n\t  // bind the emit function once\n\t  var mapResults;\n\t  var doc;\n\t\n\t  function emit(key, value) {\n\t    var output = {id: doc._id, key: normalizeKey(key)};\n\t    // Don't explicitly store the value unless it's defined and non-null.\n\t    // This saves on storage space, because often people don't use it.\n\t    if (typeof value !== 'undefined' && value !== null) {\n\t      output.value = normalizeKey(value);\n\t    }\n\t    mapResults.push(output);\n\t  }\n\t\n\t  var mapFun;\n\t  // for temp_views one can use emit(doc, emit), see #38\n\t  if (typeof view.mapFun === \"function\" && view.mapFun.length === 2) {\n\t    var origMap = view.mapFun;\n\t    mapFun = function (doc) {\n\t      return origMap(doc, emit);\n\t    };\n\t  } else {\n\t    mapFun = evalfunc(view.mapFun.toString(), emit, sum, log$2, Array.isArray,\n\t      JSON.parse);\n\t  }\n\t\n\t  var currentSeq = view.seq || 0;\n\t\n\t  function processChange(docIdsToChangesAndEmits, seq) {\n\t    return function () {\n\t      return saveKeyValues(view, docIdsToChangesAndEmits, seq);\n\t    };\n\t  }\n\t\n\t  var queue = new TaskQueue$1();\n\t  // TODO(neojski): https://github.com/daleharvey/pouchdb/issues/1521\n\t\n\t  return new PouchPromise(function (resolve, reject) {\n\t\n\t    function complete() {\n\t      queue.finish().then(function () {\n\t        view.seq = currentSeq;\n\t        resolve();\n\t      });\n\t    }\n\t\n\t    function processNextBatch() {\n\t      view.sourceDB.changes({\n\t        conflicts: true,\n\t        include_docs: true,\n\t        style: 'all_docs',\n\t        since: currentSeq,\n\t        limit: CHANGES_BATCH_SIZE$1\n\t      }).on('complete', function (response) {\n\t        var results = response.results;\n\t        if (!results.length) {\n\t          return complete();\n\t        }\n\t        var docIdsToChangesAndEmits = {};\n\t        for (var i = 0, l = results.length; i < l; i++) {\n\t          var change = results[i];\n\t          if (change.doc._id[0] !== '_') {\n\t            mapResults = [];\n\t            doc = change.doc;\n\t\n\t            if (!doc._deleted) {\n\t              tryCode(view.sourceDB, mapFun, [doc]);\n\t            }\n\t            mapResults.sort(sortByKeyThenValue);\n\t\n\t            var indexableKeysToKeyValues = {};\n\t            var lastKey;\n\t            for (var j = 0, jl = mapResults.length; j < jl; j++) {\n\t              var obj = mapResults[j];\n\t              var complexKey = [obj.key, obj.id];\n\t              if (collate$2(obj.key, lastKey) === 0) {\n\t                complexKey.push(j); // dup key+id, so make it unique\n\t              }\n\t              var indexableKey = toIndexableString(complexKey);\n\t              indexableKeysToKeyValues[indexableKey] = obj;\n\t              lastKey = obj.key;\n\t            }\n\t            docIdsToChangesAndEmits[change.doc._id] = {\n\t              indexableKeysToKeyValues: indexableKeysToKeyValues,\n\t              changes: change.changes\n\t            };\n\t          }\n\t          currentSeq = change.seq;\n\t        }\n\t        queue.add(processChange(docIdsToChangesAndEmits, currentSeq));\n\t        if (results.length < CHANGES_BATCH_SIZE$1) {\n\t          return complete();\n\t        }\n\t        return processNextBatch();\n\t      }).on('error', onError);\n\t      /* istanbul ignore next */\n\t      function onError(err) {\n\t        reject(err);\n\t      }\n\t    }\n\t\n\t    processNextBatch();\n\t  });\n\t}\n\t\n\tfunction reduceView(view, results, options) {\n\t  if (options.group_level === 0) {\n\t    delete options.group_level;\n\t  }\n\t\n\t  var shouldGroup = options.group || options.group_level;\n\t\n\t  var reduceFun;\n\t  if (builtInReduce[view.reduceFun]) {\n\t    reduceFun = builtInReduce[view.reduceFun];\n\t  } else {\n\t    reduceFun = evalfunc(\n\t      view.reduceFun.toString(), null, sum, log$2, Array.isArray, JSON.parse);\n\t  }\n\t\n\t  var groups = [];\n\t  var lvl = isNaN(options.group_level) ? Number.POSITIVE_INFINITY :\n\t    options.group_level;\n\t  results.forEach(function (e) {\n\t    var last = groups[groups.length - 1];\n\t    var groupKey = shouldGroup ? e.key : null;\n\t\n\t    // only set group_level for array keys\n\t    if (shouldGroup && Array.isArray(groupKey)) {\n\t      groupKey = groupKey.slice(0, lvl);\n\t    }\n\t\n\t    if (last && collate$2(last.groupKey, groupKey) === 0) {\n\t      last.keys.push([e.key, e.id]);\n\t      last.values.push(e.value);\n\t      return;\n\t    }\n\t    groups.push({\n\t      keys: [[e.key, e.id]],\n\t      values: [e.value],\n\t      groupKey: groupKey\n\t    });\n\t  });\n\t  results = [];\n\t  for (var i = 0, len = groups.length; i < len; i++) {\n\t    var e = groups[i];\n\t    var reduceTry = tryCode(view.sourceDB, reduceFun,\n\t      [e.keys, e.values, false]);\n\t    if (reduceTry.error && reduceTry.error instanceof BuiltInError) {\n\t      // CouchDB returns an error if a built-in errors out\n\t      throw reduceTry.error;\n\t    }\n\t    results.push({\n\t      // CouchDB just sets the value to null if a non-built-in errors out\n\t      value: reduceTry.error ? null : reduceTry.output,\n\t      key: e.groupKey\n\t    });\n\t  }\n\t  // no total_rows/offset when reducing\n\t  return {rows: sliceResults(results, options.limit, options.skip)};\n\t}\n\t\n\tfunction queryView(view, opts) {\n\t  return sequentialize(getQueue(view), function () {\n\t    return queryViewInQueue(view, opts);\n\t  })();\n\t}\n\t\n\tfunction queryViewInQueue(view, opts) {\n\t  var totalRows;\n\t  var shouldReduce = view.reduceFun && opts.reduce !== false;\n\t  var skip = opts.skip || 0;\n\t  if (typeof opts.keys !== 'undefined' && !opts.keys.length) {\n\t    // equivalent query\n\t    opts.limit = 0;\n\t    delete opts.keys;\n\t  }\n\t\n\t  function fetchFromView(viewOpts) {\n\t    viewOpts.include_docs = true;\n\t    return view.db.allDocs(viewOpts).then(function (res) {\n\t      totalRows = res.total_rows;\n\t      return res.rows.map(function (result) {\n\t\n\t        // implicit migration - in older versions of PouchDB,\n\t        // we explicitly stored the doc as {id: ..., key: ..., value: ...}\n\t        // this is tested in a migration test\n\t        /* istanbul ignore next */\n\t        if ('value' in result.doc && typeof result.doc.value === 'object' &&\n\t            result.doc.value !== null) {\n\t          var keys = Object.keys(result.doc.value).sort();\n\t          // this detection method is not perfect, but it's unlikely the user\n\t          // emitted a value which was an object with these 3 exact keys\n\t          var expectedKeys = ['id', 'key', 'value'];\n\t          if (!(keys < expectedKeys || keys > expectedKeys)) {\n\t            return result.doc.value;\n\t          }\n\t        }\n\t\n\t        var parsedKeyAndDocId = parseIndexableString(result.doc._id);\n\t        return {\n\t          key: parsedKeyAndDocId[0],\n\t          id: parsedKeyAndDocId[1],\n\t          value: ('value' in result.doc ? result.doc.value : null)\n\t        };\n\t      });\n\t    });\n\t  }\n\t\n\t  function onMapResultsReady(rows) {\n\t    var finalResults;\n\t    if (shouldReduce) {\n\t      finalResults = reduceView(view, rows, opts);\n\t    } else {\n\t      finalResults = {\n\t        total_rows: totalRows,\n\t        offset: skip,\n\t        rows: rows\n\t      };\n\t    }\n\t    if (opts.include_docs) {\n\t      var docIds = uniq(rows.map(rowToDocId));\n\t\n\t      return view.sourceDB.allDocs({\n\t        keys: docIds,\n\t        include_docs: true,\n\t        conflicts: opts.conflicts,\n\t        attachments: opts.attachments,\n\t        binary: opts.binary\n\t      }).then(function (allDocsRes) {\n\t        var docIdsToDocs = {};\n\t        allDocsRes.rows.forEach(function (row) {\n\t          if (row.doc) {\n\t            docIdsToDocs['$' + row.id] = row.doc;\n\t          }\n\t        });\n\t        rows.forEach(function (row) {\n\t          var docId = rowToDocId(row);\n\t          var doc = docIdsToDocs['$' + docId];\n\t          if (doc) {\n\t            row.doc = doc;\n\t          }\n\t        });\n\t        return finalResults;\n\t      });\n\t    } else {\n\t      return finalResults;\n\t    }\n\t  }\n\t\n\t  if (typeof opts.keys !== 'undefined') {\n\t    var keys = opts.keys;\n\t    var fetchPromises = keys.map(function (key) {\n\t      var viewOpts = {\n\t        startkey : toIndexableString([key]),\n\t        endkey   : toIndexableString([key, {}])\n\t      };\n\t      return fetchFromView(viewOpts);\n\t    });\n\t    return PouchPromise.all(fetchPromises).then(flatten).then(onMapResultsReady);\n\t  } else { // normal query, no 'keys'\n\t    var viewOpts = {\n\t      descending : opts.descending\n\t    };\n\t    if (opts.start_key) {\n\t        opts.startkey = opts.start_key;\n\t    }\n\t    if (opts.end_key) {\n\t        opts.endkey = opts.end_key;\n\t    }\n\t    if (typeof opts.startkey !== 'undefined') {\n\t      viewOpts.startkey = opts.descending ?\n\t        toIndexableString([opts.startkey, {}]) :\n\t        toIndexableString([opts.startkey]);\n\t    }\n\t    if (typeof opts.endkey !== 'undefined') {\n\t      var inclusiveEnd = opts.inclusive_end !== false;\n\t      if (opts.descending) {\n\t        inclusiveEnd = !inclusiveEnd;\n\t      }\n\t\n\t      viewOpts.endkey = toIndexableString(\n\t        inclusiveEnd ? [opts.endkey, {}] : [opts.endkey]);\n\t    }\n\t    if (typeof opts.key !== 'undefined') {\n\t      var keyStart = toIndexableString([opts.key]);\n\t      var keyEnd = toIndexableString([opts.key, {}]);\n\t      if (viewOpts.descending) {\n\t        viewOpts.endkey = keyStart;\n\t        viewOpts.startkey = keyEnd;\n\t      } else {\n\t        viewOpts.startkey = keyStart;\n\t        viewOpts.endkey = keyEnd;\n\t      }\n\t    }\n\t    if (!shouldReduce) {\n\t      if (typeof opts.limit === 'number') {\n\t        viewOpts.limit = opts.limit;\n\t      }\n\t      viewOpts.skip = skip;\n\t    }\n\t    return fetchFromView(viewOpts).then(onMapResultsReady);\n\t  }\n\t}\n\t\n\tfunction httpViewCleanup(db) {\n\t  return db.request({\n\t    method: 'POST',\n\t    url: '_view_cleanup'\n\t  });\n\t}\n\t\n\tfunction localViewCleanup(db) {\n\t  return db.get('_local/mrviews').then(function (metaDoc) {\n\t    var docsToViews = {};\n\t    Object.keys(metaDoc.views).forEach(function (fullViewName) {\n\t      var parts = parseViewName(fullViewName);\n\t      var designDocName = '_design/' + parts[0];\n\t      var viewName = parts[1];\n\t      docsToViews[designDocName] = docsToViews[designDocName] || {};\n\t      docsToViews[designDocName][viewName] = true;\n\t    });\n\t    var opts = {\n\t      keys : Object.keys(docsToViews),\n\t      include_docs : true\n\t    };\n\t    return db.allDocs(opts).then(function (res) {\n\t      var viewsToStatus = {};\n\t      res.rows.forEach(function (row) {\n\t        var ddocName = row.key.substring(8);\n\t        Object.keys(docsToViews[row.key]).forEach(function (viewName) {\n\t          var fullViewName = ddocName + '/' + viewName;\n\t          /* istanbul ignore if */\n\t          if (!metaDoc.views[fullViewName]) {\n\t            // new format, without slashes, to support PouchDB 2.2.0\n\t            // migration test in pouchdb's browser.migration.js verifies this\n\t            fullViewName = viewName;\n\t          }\n\t          var viewDBNames = Object.keys(metaDoc.views[fullViewName]);\n\t          // design doc deleted, or view function nonexistent\n\t          var statusIsGood = row.doc && row.doc.views &&\n\t            row.doc.views[viewName];\n\t          viewDBNames.forEach(function (viewDBName) {\n\t            viewsToStatus[viewDBName] =\n\t              viewsToStatus[viewDBName] || statusIsGood;\n\t          });\n\t        });\n\t      });\n\t      var dbsToDelete = Object.keys(viewsToStatus).filter(\n\t        function (viewDBName) { return !viewsToStatus[viewDBName]; });\n\t      var destroyPromises = dbsToDelete.map(function (viewDBName) {\n\t        return sequentialize(getQueue(viewDBName), function () {\n\t          return new db.constructor(viewDBName, db.__opts).destroy();\n\t        })();\n\t      });\n\t      return PouchPromise.all(destroyPromises).then(function () {\n\t        return {ok: true};\n\t      });\n\t    });\n\t  }, defaultsTo({ok: true}));\n\t}\n\t\n\tvar viewCleanup = callbackify(function () {\n\t  var db = this;\n\t  if (db._ddocCache) {\n\t    delete db._ddocCache;\n\t  }\n\t  if (db.type() === 'http') {\n\t    return httpViewCleanup(db);\n\t  }\n\t  /* istanbul ignore next */\n\t  if (typeof db._viewCleanup === 'function') {\n\t    return customViewCleanup(db);\n\t  }\n\t  return localViewCleanup(db);\n\t});\n\t\n\tfunction queryPromised(db, fun, opts) {\n\t  if (db.type() === 'http') {\n\t    return httpQuery(db, fun, opts);\n\t  }\n\t\n\t  /* istanbul ignore next */\n\t  if (typeof db._query === 'function') {\n\t    return customQuery(db, fun, opts);\n\t  }\n\t\n\t  if (typeof fun !== 'string') {\n\t    // temp_view\n\t    checkQueryParseError(opts, fun);\n\t\n\t    var createViewOpts = {\n\t      db : db,\n\t      viewName : 'temp_view/temp_view',\n\t      map : fun.map,\n\t      reduce : fun.reduce,\n\t      temporary : true\n\t    };\n\t    tempViewQueue.add(function () {\n\t      return createView(createViewOpts).then(function (view) {\n\t        function cleanup() {\n\t          return view.db.destroy();\n\t        }\n\t        return fin(updateView(view).then(function () {\n\t          return queryView(view, opts);\n\t        }), cleanup);\n\t      });\n\t    });\n\t    return tempViewQueue.finish();\n\t  } else {\n\t    // persistent view\n\t    var fullViewName = fun;\n\t    var parts = parseViewName(fullViewName);\n\t    var designDocName = parts[0];\n\t    var viewName = parts[1];\n\t    return db.getView(designDocName, viewName).then(function (fun) {\n\t      checkQueryParseError(opts, fun);\n\t\n\t      var createViewOpts = {\n\t        db : db,\n\t        viewName : fullViewName,\n\t        map : fun.map,\n\t        reduce : fun.reduce\n\t      };\n\t      return createView(createViewOpts).then(function (view) {\n\t        if (opts.stale === 'ok' || opts.stale === 'update_after') {\n\t          if (opts.stale === 'update_after') {\n\t            process.nextTick(function () {\n\t              updateView(view);\n\t            });\n\t          }\n\t          return queryView(view, opts);\n\t        } else { // stale not ok\n\t          return updateView(view).then(function () {\n\t            return queryView(view, opts);\n\t          });\n\t        }\n\t      });\n\t    });\n\t  }\n\t}\n\t\n\tvar query = function (fun, opts, callback) {\n\t  if (typeof opts === 'function') {\n\t    callback = opts;\n\t    opts = {};\n\t  }\n\t  opts = opts ? coerceOptions(opts) : {};\n\t\n\t  if (typeof fun === 'function') {\n\t    fun = {map : fun};\n\t  }\n\t\n\t  var db = this;\n\t  var promise = PouchPromise.resolve().then(function () {\n\t    return queryPromised(db, fun, opts);\n\t  });\n\t  promisedCallback(promise, callback);\n\t  return promise;\n\t};\n\t\n\tfunction QueryParseError(message) {\n\t  this.status = 400;\n\t  this.name = 'query_parse_error';\n\t  this.message = message;\n\t  this.error = true;\n\t  try {\n\t    Error.captureStackTrace(this, QueryParseError);\n\t  } catch (e) {}\n\t}\n\t\n\tinherits(QueryParseError, Error);\n\t\n\tfunction BuiltInError(message) {\n\t  this.status = 500;\n\t  this.name = 'invalid_value';\n\t  this.message = message;\n\t  this.error = true;\n\t  try {\n\t    Error.captureStackTrace(this, BuiltInError);\n\t  } catch (e) {}\n\t}\n\t\n\tinherits(BuiltInError, Error);\n\t\n\tvar mapreduce = {\n\t  query: query,\n\t  viewCleanup: viewCleanup\n\t};\n\t\n\tfunction arrayBufferToBase64(buffer) {\n\t  return btoa$1(arrayBufferToBinaryString(buffer));\n\t}\n\t\n\tfunction preprocessAttachments$1(docInfos, blobType, callback) {\n\t\n\t  if (!docInfos.length) {\n\t    return callback();\n\t  }\n\t\n\t  var docv = 0;\n\t\n\t  function parseBase64(data) {\n\t    try {\n\t      return atob$1(data);\n\t    } catch (e) {\n\t      var err = createError(BAD_ARG,\n\t        'Attachment is not a valid base64 string');\n\t      return {error: err};\n\t    }\n\t  }\n\t\n\t  function preprocessAttachment(att, callback) {\n\t    if (att.stub) {\n\t      return callback();\n\t    }\n\t    if (typeof att.data === 'string') {\n\t      // input is assumed to be a base64 string\n\t\n\t      var asBinary = parseBase64(att.data);\n\t      if (asBinary.error) {\n\t        return callback(asBinary.error);\n\t      }\n\t\n\t      att.length = asBinary.length;\n\t      if (blobType === 'blob') {\n\t        att.data = binStringToBluffer(asBinary, att.content_type);\n\t      } else if (blobType === 'base64') {\n\t        att.data = btoa$1(asBinary);\n\t      } else { // binary\n\t        att.data = asBinary;\n\t      }\n\t      md5(asBinary).then(function (result) {\n\t        att.digest = 'md5-' + result;\n\t        callback();\n\t      });\n\t    } else { // input is a blob\n\t      readAsArrayBuffer(att.data, function (buff) {\n\t        if (blobType === 'binary') {\n\t          att.data = arrayBufferToBinaryString(buff);\n\t        } else if (blobType === 'base64') {\n\t          att.data = arrayBufferToBase64(buff);\n\t        }\n\t        md5(buff).then(function (result) {\n\t          att.digest = 'md5-' + result;\n\t          att.length = buff.byteLength;\n\t          callback();\n\t        });\n\t      });\n\t    }\n\t  }\n\t\n\t  var overallErr;\n\t\n\t  docInfos.forEach(function (docInfo) {\n\t    var attachments = docInfo.data && docInfo.data._attachments ?\n\t      Object.keys(docInfo.data._attachments) : [];\n\t    var recv = 0;\n\t\n\t    if (!attachments.length) {\n\t      return done();\n\t    }\n\t\n\t    function processedAttachment(err) {\n\t      overallErr = err;\n\t      recv++;\n\t      if (recv === attachments.length) {\n\t        done();\n\t      }\n\t    }\n\t\n\t    for (var key in docInfo.data._attachments) {\n\t      if (docInfo.data._attachments.hasOwnProperty(key)) {\n\t        preprocessAttachment(docInfo.data._attachments[key],\n\t          processedAttachment);\n\t      }\n\t    }\n\t  });\n\t\n\t  function done() {\n\t    docv++;\n\t    if (docInfos.length === docv) {\n\t      if (overallErr) {\n\t        callback(overallErr);\n\t      } else {\n\t        callback();\n\t      }\n\t    }\n\t  }\n\t}\n\t\n\tfunction sortByPos$1(a, b) {\n\t  return a.pos - b.pos;\n\t}\n\t\n\t// classic binary search\n\tfunction binarySearch(arr, item, comparator) {\n\t  var low = 0;\n\t  var high = arr.length;\n\t  var mid;\n\t  while (low < high) {\n\t    mid = (low + high) >>> 1;\n\t    if (comparator(arr[mid], item) < 0) {\n\t      low = mid + 1;\n\t    } else {\n\t      high = mid;\n\t    }\n\t  }\n\t  return low;\n\t}\n\t\n\t// assuming the arr is sorted, insert the item in the proper place\n\tfunction insertSorted(arr, item, comparator) {\n\t  var idx = binarySearch(arr, item, comparator);\n\t  arr.splice(idx, 0, item);\n\t}\n\t\n\t// Turn a path as a flat array into a tree with a single branch.\n\t// If any should be stemmed from the beginning of the array, that's passed\n\t// in as the second argument\n\tfunction pathToTree(path, numStemmed) {\n\t  var root;\n\t  var leaf;\n\t  for (var i = numStemmed, len = path.length; i < len; i++) {\n\t    var node = path[i];\n\t    var currentLeaf = [node.id, node.opts, []];\n\t    if (leaf) {\n\t      leaf[2].push(currentLeaf);\n\t      leaf = currentLeaf;\n\t    } else {\n\t      root = leaf = currentLeaf;\n\t    }\n\t  }\n\t  return root;\n\t}\n\t\n\t// compare the IDs of two trees\n\tfunction compareTree(a, b) {\n\t  return a[0] < b[0] ? -1 : 1;\n\t}\n\t\n\t// Merge two trees together\n\t// The roots of tree1 and tree2 must be the same revision\n\tfunction mergeTree(in_tree1, in_tree2) {\n\t  var queue = [{tree1: in_tree1, tree2: in_tree2}];\n\t  var conflicts = false;\n\t  while (queue.length > 0) {\n\t    var item = queue.pop();\n\t    var tree1 = item.tree1;\n\t    var tree2 = item.tree2;\n\t\n\t    if (tree1[1].status || tree2[1].status) {\n\t      tree1[1].status =\n\t        (tree1[1].status ===  'available' ||\n\t        tree2[1].status === 'available') ? 'available' : 'missing';\n\t    }\n\t\n\t    for (var i = 0; i < tree2[2].length; i++) {\n\t      if (!tree1[2][0]) {\n\t        conflicts = 'new_leaf';\n\t        tree1[2][0] = tree2[2][i];\n\t        continue;\n\t      }\n\t\n\t      var merged = false;\n\t      for (var j = 0; j < tree1[2].length; j++) {\n\t        if (tree1[2][j][0] === tree2[2][i][0]) {\n\t          queue.push({tree1: tree1[2][j], tree2: tree2[2][i]});\n\t          merged = true;\n\t        }\n\t      }\n\t      if (!merged) {\n\t        conflicts = 'new_branch';\n\t        insertSorted(tree1[2], tree2[2][i], compareTree);\n\t      }\n\t    }\n\t  }\n\t  return {conflicts: conflicts, tree: in_tree1};\n\t}\n\t\n\tfunction doMerge(tree, path, dontExpand) {\n\t  var restree = [];\n\t  var conflicts = false;\n\t  var merged = false;\n\t  var res;\n\t\n\t  if (!tree.length) {\n\t    return {tree: [path], conflicts: 'new_leaf'};\n\t  }\n\t\n\t  for (var i = 0, len = tree.length; i < len; i++) {\n\t    var branch = tree[i];\n\t    if (branch.pos === path.pos && branch.ids[0] === path.ids[0]) {\n\t      // Paths start at the same position and have the same root, so they need\n\t      // merged\n\t      res = mergeTree(branch.ids, path.ids);\n\t      restree.push({pos: branch.pos, ids: res.tree});\n\t      conflicts = conflicts || res.conflicts;\n\t      merged = true;\n\t    } else if (dontExpand !== true) {\n\t      // The paths start at a different position, take the earliest path and\n\t      // traverse up until it as at the same point from root as the path we\n\t      // want to merge.  If the keys match we return the longer path with the\n\t      // other merged After stemming we dont want to expand the trees\n\t\n\t      var t1 = branch.pos < path.pos ? branch : path;\n\t      var t2 = branch.pos < path.pos ? path : branch;\n\t      var diff = t2.pos - t1.pos;\n\t\n\t      var candidateParents = [];\n\t\n\t      var trees = [];\n\t      trees.push({ids: t1.ids, diff: diff, parent: null, parentIdx: null});\n\t      while (trees.length > 0) {\n\t        var item = trees.pop();\n\t        if (item.diff === 0) {\n\t          if (item.ids[0] === t2.ids[0]) {\n\t            candidateParents.push(item);\n\t          }\n\t          continue;\n\t        }\n\t        var elements = item.ids[2];\n\t        for (var j = 0, elementsLen = elements.length; j < elementsLen; j++) {\n\t          trees.push({\n\t            ids: elements[j],\n\t            diff: item.diff - 1,\n\t            parent: item.ids,\n\t            parentIdx: j\n\t          });\n\t        }\n\t      }\n\t\n\t      var el = candidateParents[0];\n\t\n\t      if (!el) {\n\t        restree.push(branch);\n\t      } else {\n\t        res = mergeTree(el.ids, t2.ids);\n\t        el.parent[2][el.parentIdx] = res.tree;\n\t        restree.push({pos: t1.pos, ids: t1.ids});\n\t        conflicts = conflicts || res.conflicts;\n\t        merged = true;\n\t      }\n\t    } else {\n\t      restree.push(branch);\n\t    }\n\t  }\n\t\n\t  // We didnt find\n\t  if (!merged) {\n\t    restree.push(path);\n\t  }\n\t\n\t  restree.sort(sortByPos$1);\n\t\n\t  return {\n\t    tree: restree,\n\t    conflicts: conflicts || 'internal_node'\n\t  };\n\t}\n\t\n\t// To ensure we dont grow the revision tree infinitely, we stem old revisions\n\tfunction stem(tree, depth) {\n\t  // First we break out the tree into a complete list of root to leaf paths\n\t  var paths = rootToLeaf(tree);\n\t  var maybeStem = {};\n\t\n\t  var result;\n\t  for (var i = 0, len = paths.length; i < len; i++) {\n\t    // Then for each path, we cut off the start of the path based on the\n\t    // `depth` to stem to, and generate a new set of flat trees\n\t    var path = paths[i];\n\t    var stemmed = path.ids;\n\t    var numStemmed = Math.max(0, stemmed.length - depth);\n\t    var stemmedNode = {\n\t      pos: path.pos + numStemmed,\n\t      ids: pathToTree(stemmed, numStemmed)\n\t    };\n\t\n\t    for (var s = 0; s < numStemmed; s++) {\n\t      var rev = (path.pos + s) + '-' + stemmed[s].id;\n\t      maybeStem[rev] = true;\n\t    }\n\t\n\t    // Then we remerge all those flat trees together, ensuring that we dont\n\t    // connect trees that would go beyond the depth limit\n\t    if (result) {\n\t      result = doMerge(result, stemmedNode, true).tree;\n\t    } else {\n\t      result = [stemmedNode];\n\t    }\n\t  }\n\t\n\t  traverseRevTree(result, function (isLeaf, pos, revHash) {\n\t    // some revisions may have been removed in a branch but not in another\n\t    delete maybeStem[pos + '-' + revHash];\n\t  });\n\t\n\t  return {\n\t    tree: result,\n\t    revs: Object.keys(maybeStem)\n\t  };\n\t}\n\t\n\tfunction merge(tree, path, depth) {\n\t  var newTree = doMerge(tree, path);\n\t  var stemmed = stem(newTree.tree, depth);\n\t  return {\n\t    tree: stemmed.tree,\n\t    stemmedRevs: stemmed.revs,\n\t    conflicts: newTree.conflicts\n\t  };\n\t}\n\t\n\t// return true if a rev exists in the rev tree, false otherwise\n\tfunction revExists(revs, rev) {\n\t  var toVisit = revs.slice();\n\t  var splitRev = rev.split('-');\n\t  var targetPos = parseInt(splitRev[0], 10);\n\t  var targetId = splitRev[1];\n\t\n\t  var node;\n\t  while ((node = toVisit.pop())) {\n\t    if (node.pos === targetPos && node.ids[0] === targetId) {\n\t      return true;\n\t    }\n\t    var branches = node.ids[2];\n\t    for (var i = 0, len = branches.length; i < len; i++) {\n\t      toVisit.push({pos: node.pos + 1, ids: branches[i]});\n\t    }\n\t  }\n\t  return false;\n\t}\n\t\n\tfunction updateDoc(revLimit, prev, docInfo, results,\n\t                   i, cb, writeDoc, newEdits) {\n\t\n\t  if (revExists(prev.rev_tree, docInfo.metadata.rev)) {\n\t    results[i] = docInfo;\n\t    return cb();\n\t  }\n\t\n\t  // sometimes this is pre-calculated. historically not always\n\t  var previousWinningRev = prev.winningRev || winningRev(prev);\n\t  var previouslyDeleted = 'deleted' in prev ? prev.deleted :\n\t    isDeleted(prev, previousWinningRev);\n\t  var deleted = 'deleted' in docInfo.metadata ? docInfo.metadata.deleted :\n\t    isDeleted(docInfo.metadata);\n\t  var isRoot = /^1-/.test(docInfo.metadata.rev);\n\t\n\t  if (previouslyDeleted && !deleted && newEdits && isRoot) {\n\t    var newDoc = docInfo.data;\n\t    newDoc._rev = previousWinningRev;\n\t    newDoc._id = docInfo.metadata.id;\n\t    docInfo = parseDoc(newDoc, newEdits);\n\t  }\n\t\n\t  var merged = merge(prev.rev_tree, docInfo.metadata.rev_tree[0], revLimit);\n\t\n\t  var inConflict = newEdits && (((previouslyDeleted && deleted) ||\n\t    (!previouslyDeleted && merged.conflicts !== 'new_leaf') ||\n\t    (previouslyDeleted && !deleted && merged.conflicts === 'new_branch')));\n\t\n\t  if (inConflict) {\n\t    var err = createError(REV_CONFLICT);\n\t    results[i] = err;\n\t    return cb();\n\t  }\n\t\n\t  var newRev = docInfo.metadata.rev;\n\t  docInfo.metadata.rev_tree = merged.tree;\n\t  docInfo.stemmedRevs = merged.stemmedRevs || [];\n\t  /* istanbul ignore else */\n\t  if (prev.rev_map) {\n\t    docInfo.metadata.rev_map = prev.rev_map; // used only by leveldb\n\t  }\n\t\n\t  // recalculate\n\t  var winningRev$$ = winningRev(docInfo.metadata);\n\t  var winningRevIsDeleted = isDeleted(docInfo.metadata, winningRev$$);\n\t\n\t  // calculate the total number of documents that were added/removed,\n\t  // from the perspective of total_rows/doc_count\n\t  var delta = (previouslyDeleted === winningRevIsDeleted) ? 0 :\n\t    previouslyDeleted < winningRevIsDeleted ? -1 : 1;\n\t\n\t  var newRevIsDeleted;\n\t  if (newRev === winningRev$$) {\n\t    // if the new rev is the same as the winning rev, we can reuse that value\n\t    newRevIsDeleted = winningRevIsDeleted;\n\t  } else {\n\t    // if they're not the same, then we need to recalculate\n\t    newRevIsDeleted = isDeleted(docInfo.metadata, newRev);\n\t  }\n\t\n\t  writeDoc(docInfo, winningRev$$, winningRevIsDeleted, newRevIsDeleted,\n\t    true, delta, i, cb);\n\t}\n\t\n\tfunction rootIsMissing(docInfo) {\n\t  return docInfo.metadata.rev_tree[0].ids[1].status === 'missing';\n\t}\n\t\n\tfunction processDocs(revLimit, docInfos, api, fetchedDocs, tx, results,\n\t                     writeDoc, opts, overallCallback) {\n\t\n\t  // Default to 1000 locally\n\t  revLimit = revLimit || 1000;\n\t\n\t  function insertDoc(docInfo, resultsIdx, callback) {\n\t    // Cant insert new deleted documents\n\t    var winningRev$$ = winningRev(docInfo.metadata);\n\t    var deleted = isDeleted(docInfo.metadata, winningRev$$);\n\t    if ('was_delete' in opts && deleted) {\n\t      results[resultsIdx] = createError(MISSING_DOC, 'deleted');\n\t      return callback();\n\t    }\n\t\n\t    // 4712 - detect whether a new document was inserted with a _rev\n\t    var inConflict = newEdits && rootIsMissing(docInfo);\n\t\n\t    if (inConflict) {\n\t      var err = createError(REV_CONFLICT);\n\t      results[resultsIdx] = err;\n\t      return callback();\n\t    }\n\t\n\t    var delta = deleted ? 0 : 1;\n\t\n\t    writeDoc(docInfo, winningRev$$, deleted, deleted, false,\n\t      delta, resultsIdx, callback);\n\t  }\n\t\n\t  var newEdits = opts.new_edits;\n\t  var idsToDocs = new pouchdbCollections.Map();\n\t\n\t  var docsDone = 0;\n\t  var docsToDo = docInfos.length;\n\t\n\t  function checkAllDocsDone() {\n\t    if (++docsDone === docsToDo && overallCallback) {\n\t      overallCallback();\n\t    }\n\t  }\n\t\n\t  docInfos.forEach(function (currentDoc, resultsIdx) {\n\t\n\t    if (currentDoc._id && isLocalId(currentDoc._id)) {\n\t      var fun = currentDoc._deleted ? '_removeLocal' : '_putLocal';\n\t      api[fun](currentDoc, {ctx: tx}, function (err, res) {\n\t        results[resultsIdx] = err || res;\n\t        checkAllDocsDone();\n\t      });\n\t      return;\n\t    }\n\t\n\t    var id = currentDoc.metadata.id;\n\t    if (idsToDocs.has(id)) {\n\t      docsToDo--; // duplicate\n\t      idsToDocs.get(id).push([currentDoc, resultsIdx]);\n\t    } else {\n\t      idsToDocs.set(id, [[currentDoc, resultsIdx]]);\n\t    }\n\t  });\n\t\n\t  // in the case of new_edits, the user can provide multiple docs\n\t  // with the same id. these need to be processed sequentially\n\t  idsToDocs.forEach(function (docs, id) {\n\t    var numDone = 0;\n\t\n\t    function docWritten() {\n\t      if (++numDone < docs.length) {\n\t        nextDoc();\n\t      } else {\n\t        checkAllDocsDone();\n\t      }\n\t    }\n\t    function nextDoc() {\n\t      var value = docs[numDone];\n\t      var currentDoc = value[0];\n\t      var resultsIdx = value[1];\n\t\n\t      if (fetchedDocs.has(id)) {\n\t        updateDoc(revLimit, fetchedDocs.get(id), currentDoc, results,\n\t          resultsIdx, docWritten, writeDoc, newEdits);\n\t      } else {\n\t        // Ensure stemming applies to new writes as well\n\t        var merged = merge([], currentDoc.metadata.rev_tree[0], revLimit);\n\t        currentDoc.metadata.rev_tree = merged.tree;\n\t        currentDoc.stemmedRevs = merged.stemmedRevs || [];\n\t        insertDoc(currentDoc, resultsIdx, docWritten);\n\t      }\n\t    }\n\t    nextDoc();\n\t  });\n\t}\n\t\n\t// compact a tree by marking its non-leafs as missing,\n\t// and return a list of revs to delete\n\tfunction compactTree(metadata) {\n\t  var revs = [];\n\t  traverseRevTree(metadata.rev_tree, function (isLeaf, pos,\n\t                                               revHash, ctx, opts) {\n\t    if (opts.status === 'available' && !isLeaf) {\n\t      revs.push(pos + '-' + revHash);\n\t      opts.status = 'missing';\n\t    }\n\t  });\n\t  return revs;\n\t}\n\t\n\t// IndexedDB requires a versioned database structure, so we use the\n\t// version here to manage migrations.\n\tvar ADAPTER_VERSION = 5;\n\t\n\t// The object stores created for each database\n\t// DOC_STORE stores the document meta data, its revision history and state\n\t// Keyed by document id\n\tvar DOC_STORE = 'document-store';\n\t// BY_SEQ_STORE stores a particular version of a document, keyed by its\n\t// sequence id\n\tvar BY_SEQ_STORE = 'by-sequence';\n\t// Where we store attachments\n\tvar ATTACH_STORE = 'attach-store';\n\t// Where we store many-to-many relations\n\t// between attachment digests and seqs\n\tvar ATTACH_AND_SEQ_STORE = 'attach-seq-store';\n\t\n\t// Where we store database-wide meta data in a single record\n\t// keyed by id: META_STORE\n\tvar META_STORE = 'meta-store';\n\t// Where we store local documents\n\tvar LOCAL_STORE = 'local-store';\n\t// Where we detect blob support\n\tvar DETECT_BLOB_SUPPORT_STORE = 'detect-blob-support';\n\t\n\tfunction slowJsonParse(str) {\n\t  try {\n\t    return JSON.parse(str);\n\t  } catch (e) {\n\t    /* istanbul ignore next */\n\t    return vuvuzela.parse(str);\n\t  }\n\t}\n\t\n\tfunction safeJsonParse(str) {\n\t  // try/catch is deoptimized in V8, leading to slower\n\t  // times than we'd like to have. Most documents are _not_\n\t  // huge, and do not require a slower code path just to parse them.\n\t  // We can be pretty sure that a document under 50000 characters\n\t  // will not be so deeply nested as to throw a stack overflow error\n\t  // (depends on the engine and available memory, though, so this is\n\t  // just a hunch). 50000 was chosen based on the average length\n\t  // of this string in our test suite, to try to find a number that covers\n\t  // most of our test cases (26 over this size, 26378 under it).\n\t  if (str.length < 50000) {\n\t    return JSON.parse(str);\n\t  }\n\t  return slowJsonParse(str);\n\t}\n\t\n\tfunction safeJsonStringify(json) {\n\t  try {\n\t    return JSON.stringify(json);\n\t  } catch (e) {\n\t    /* istanbul ignore next */\n\t    return vuvuzela.stringify(json);\n\t  }\n\t}\n\t\n\tfunction tryCode$1(fun, that, args, PouchDB) {\n\t  try {\n\t    fun.apply(that, args);\n\t  } catch (err) {\n\t    // Shouldn't happen, but in some odd cases\n\t    // IndexedDB implementations might throw a sync\n\t    // error, in which case this will at least log it.\n\t    PouchDB.emit('error', err);\n\t  }\n\t}\n\t\n\tvar taskQueue = {\n\t  running: false,\n\t  queue: []\n\t};\n\t\n\tfunction applyNext(PouchDB) {\n\t  if (taskQueue.running || !taskQueue.queue.length) {\n\t    return;\n\t  }\n\t  taskQueue.running = true;\n\t  var item = taskQueue.queue.shift();\n\t  item.action(function (err, res) {\n\t    tryCode$1(item.callback, this, [err, res], PouchDB);\n\t    taskQueue.running = false;\n\t    process.nextTick(function () {\n\t      applyNext(PouchDB);\n\t    });\n\t  });\n\t}\n\t\n\tfunction idbError(callback) {\n\t  return function (evt) {\n\t    var message = 'unknown_error';\n\t    if (evt.target && evt.target.error) {\n\t      message = evt.target.error.name || evt.target.error.message;\n\t    }\n\t    callback(createError(IDB_ERROR, message, evt.type));\n\t  };\n\t}\n\t\n\t// Unfortunately, the metadata has to be stringified\n\t// when it is put into the database, because otherwise\n\t// IndexedDB can throw errors for deeply-nested objects.\n\t// Originally we just used JSON.parse/JSON.stringify; now\n\t// we use this custom vuvuzela library that avoids recursion.\n\t// If we could do it all over again, we'd probably use a\n\t// format for the revision trees other than JSON.\n\tfunction encodeMetadata(metadata, winningRev, deleted) {\n\t  return {\n\t    data: safeJsonStringify(metadata),\n\t    winningRev: winningRev,\n\t    deletedOrLocal: deleted ? '1' : '0',\n\t    seq: metadata.seq, // highest seq for this doc\n\t    id: metadata.id\n\t  };\n\t}\n\t\n\tfunction decodeMetadata(storedObject) {\n\t  if (!storedObject) {\n\t    return null;\n\t  }\n\t  var metadata = safeJsonParse(storedObject.data);\n\t  metadata.winningRev = storedObject.winningRev;\n\t  metadata.deleted = storedObject.deletedOrLocal === '1';\n\t  metadata.seq = storedObject.seq;\n\t  return metadata;\n\t}\n\t\n\t// read the doc back out from the database. we don't store the\n\t// _id or _rev because we already have _doc_id_rev.\n\tfunction decodeDoc(doc) {\n\t  if (!doc) {\n\t    return doc;\n\t  }\n\t  var idx = doc._doc_id_rev.lastIndexOf(':');\n\t  doc._id = doc._doc_id_rev.substring(0, idx - 1);\n\t  doc._rev = doc._doc_id_rev.substring(idx + 1);\n\t  delete doc._doc_id_rev;\n\t  return doc;\n\t}\n\t\n\t// Read a blob from the database, encoding as necessary\n\t// and translating from base64 if the IDB doesn't support\n\t// native Blobs\n\tfunction readBlobData(body, type, asBlob, callback) {\n\t  if (asBlob) {\n\t    if (!body) {\n\t      callback(createBlob([''], {type: type}));\n\t    } else if (typeof body !== 'string') { // we have blob support\n\t      callback(body);\n\t    } else { // no blob support\n\t      callback(b64ToBluffer(body, type));\n\t    }\n\t  } else { // as base64 string\n\t    if (!body) {\n\t      callback('');\n\t    } else if (typeof body !== 'string') { // we have blob support\n\t      readAsBinaryString(body, function (binary) {\n\t        callback(btoa$1(binary));\n\t      });\n\t    } else { // no blob support\n\t      callback(body);\n\t    }\n\t  }\n\t}\n\t\n\tfunction fetchAttachmentsIfNecessary(doc, opts, txn, cb) {\n\t  var attachments = Object.keys(doc._attachments || {});\n\t  if (!attachments.length) {\n\t    return cb && cb();\n\t  }\n\t  var numDone = 0;\n\t\n\t  function checkDone() {\n\t    if (++numDone === attachments.length && cb) {\n\t      cb();\n\t    }\n\t  }\n\t\n\t  function fetchAttachment(doc, att) {\n\t    var attObj = doc._attachments[att];\n\t    var digest = attObj.digest;\n\t    var req = txn.objectStore(ATTACH_STORE).get(digest);\n\t    req.onsuccess = function (e) {\n\t      attObj.body = e.target.result.body;\n\t      checkDone();\n\t    };\n\t  }\n\t\n\t  attachments.forEach(function (att) {\n\t    if (opts.attachments && opts.include_docs) {\n\t      fetchAttachment(doc, att);\n\t    } else {\n\t      doc._attachments[att].stub = true;\n\t      checkDone();\n\t    }\n\t  });\n\t}\n\t\n\t// IDB-specific postprocessing necessary because\n\t// we don't know whether we stored a true Blob or\n\t// a base64-encoded string, and if it's a Blob it\n\t// needs to be read outside of the transaction context\n\tfunction postProcessAttachments(results, asBlob) {\n\t  return PouchPromise.all(results.map(function (row) {\n\t    if (row.doc && row.doc._attachments) {\n\t      var attNames = Object.keys(row.doc._attachments);\n\t      return PouchPromise.all(attNames.map(function (att) {\n\t        var attObj = row.doc._attachments[att];\n\t        if (!('body' in attObj)) { // already processed\n\t          return;\n\t        }\n\t        var body = attObj.body;\n\t        var type = attObj.content_type;\n\t        return new PouchPromise(function (resolve) {\n\t          readBlobData(body, type, asBlob, function (data) {\n\t            row.doc._attachments[att] = jsExtend.extend(\n\t              pick(attObj, ['digest', 'content_type']),\n\t              {data: data}\n\t            );\n\t            resolve();\n\t          });\n\t        });\n\t      }));\n\t    }\n\t  }));\n\t}\n\t\n\tfunction compactRevs(revs, docId, txn) {\n\t\n\t  var possiblyOrphanedDigests = [];\n\t  var seqStore = txn.objectStore(BY_SEQ_STORE);\n\t  var attStore = txn.objectStore(ATTACH_STORE);\n\t  var attAndSeqStore = txn.objectStore(ATTACH_AND_SEQ_STORE);\n\t  var count = revs.length;\n\t\n\t  function checkDone() {\n\t    count--;\n\t    if (!count) { // done processing all revs\n\t      deleteOrphanedAttachments();\n\t    }\n\t  }\n\t\n\t  function deleteOrphanedAttachments() {\n\t    if (!possiblyOrphanedDigests.length) {\n\t      return;\n\t    }\n\t    possiblyOrphanedDigests.forEach(function (digest) {\n\t      var countReq = attAndSeqStore.index('digestSeq').count(\n\t        IDBKeyRange.bound(\n\t          digest + '::', digest + '::\\uffff', false, false));\n\t      countReq.onsuccess = function (e) {\n\t        var count = e.target.result;\n\t        if (!count) {\n\t          // orphaned\n\t          attStore.delete(digest);\n\t        }\n\t      };\n\t    });\n\t  }\n\t\n\t  revs.forEach(function (rev) {\n\t    var index = seqStore.index('_doc_id_rev');\n\t    var key = docId + \"::\" + rev;\n\t    index.getKey(key).onsuccess = function (e) {\n\t      var seq = e.target.result;\n\t      if (typeof seq !== 'number') {\n\t        return checkDone();\n\t      }\n\t      seqStore.delete(seq);\n\t\n\t      var cursor = attAndSeqStore.index('seq')\n\t        .openCursor(IDBKeyRange.only(seq));\n\t\n\t      cursor.onsuccess = function (event) {\n\t        var cursor = event.target.result;\n\t        if (cursor) {\n\t          var digest = cursor.value.digestSeq.split('::')[0];\n\t          possiblyOrphanedDigests.push(digest);\n\t          attAndSeqStore.delete(cursor.primaryKey);\n\t          cursor.continue();\n\t        } else { // done\n\t          checkDone();\n\t        }\n\t      };\n\t    };\n\t  });\n\t}\n\t\n\tfunction openTransactionSafely(idb, stores, mode) {\n\t  try {\n\t    return {\n\t      txn: idb.transaction(stores, mode)\n\t    };\n\t  } catch (err) {\n\t    return {\n\t      error: err\n\t    };\n\t  }\n\t}\n\t\n\tfunction idbBulkDocs(dbOpts, req, opts, api, idb, idbChanges, callback) {\n\t  var docInfos = req.docs;\n\t  var txn;\n\t  var docStore;\n\t  var bySeqStore;\n\t  var attachStore;\n\t  var attachAndSeqStore;\n\t  var docInfoError;\n\t  var docCountDelta = 0;\n\t\n\t  for (var i = 0, len = docInfos.length; i < len; i++) {\n\t    var doc = docInfos[i];\n\t    if (doc._id && isLocalId(doc._id)) {\n\t      continue;\n\t    }\n\t    doc = docInfos[i] = parseDoc(doc, opts.new_edits);\n\t    if (doc.error && !docInfoError) {\n\t      docInfoError = doc;\n\t    }\n\t  }\n\t\n\t  if (docInfoError) {\n\t    return callback(docInfoError);\n\t  }\n\t\n\t  var results = new Array(docInfos.length);\n\t  var fetchedDocs = new pouchdbCollections.Map();\n\t  var preconditionErrored = false;\n\t  var blobType = api._meta.blobSupport ? 'blob' : 'base64';\n\t\n\t  preprocessAttachments$1(docInfos, blobType, function (err) {\n\t    if (err) {\n\t      return callback(err);\n\t    }\n\t    startTransaction();\n\t  });\n\t\n\t  function startTransaction() {\n\t\n\t    var stores = [\n\t      DOC_STORE, BY_SEQ_STORE,\n\t      ATTACH_STORE,\n\t      LOCAL_STORE, ATTACH_AND_SEQ_STORE\n\t    ];\n\t    var txnResult = openTransactionSafely(idb, stores, 'readwrite');\n\t    if (txnResult.error) {\n\t      return callback(txnResult.error);\n\t    }\n\t    txn = txnResult.txn;\n\t    txn.onabort = idbError(callback);\n\t    txn.ontimeout = idbError(callback);\n\t    txn.oncomplete = complete;\n\t    docStore = txn.objectStore(DOC_STORE);\n\t    bySeqStore = txn.objectStore(BY_SEQ_STORE);\n\t    attachStore = txn.objectStore(ATTACH_STORE);\n\t    attachAndSeqStore = txn.objectStore(ATTACH_AND_SEQ_STORE);\n\t\n\t    verifyAttachments(function (err) {\n\t      if (err) {\n\t        preconditionErrored = true;\n\t        return callback(err);\n\t      }\n\t      fetchExistingDocs();\n\t    });\n\t  }\n\t\n\t  function idbProcessDocs() {\n\t    processDocs(dbOpts.revs_limit, docInfos, api, fetchedDocs,\n\t                txn, results, writeDoc, opts);\n\t  }\n\t\n\t  function fetchExistingDocs() {\n\t\n\t    if (!docInfos.length) {\n\t      return;\n\t    }\n\t\n\t    var numFetched = 0;\n\t\n\t    function checkDone() {\n\t      if (++numFetched === docInfos.length) {\n\t        idbProcessDocs();\n\t      }\n\t    }\n\t\n\t    function readMetadata(event) {\n\t      var metadata = decodeMetadata(event.target.result);\n\t\n\t      if (metadata) {\n\t        fetchedDocs.set(metadata.id, metadata);\n\t      }\n\t      checkDone();\n\t    }\n\t\n\t    for (var i = 0, len = docInfos.length; i < len; i++) {\n\t      var docInfo = docInfos[i];\n\t      if (docInfo._id && isLocalId(docInfo._id)) {\n\t        checkDone(); // skip local docs\n\t        continue;\n\t      }\n\t      var req = docStore.get(docInfo.metadata.id);\n\t      req.onsuccess = readMetadata;\n\t    }\n\t  }\n\t\n\t  function complete() {\n\t    if (preconditionErrored) {\n\t      return;\n\t    }\n\t\n\t    idbChanges.notify(api._meta.name);\n\t    api._meta.docCount += docCountDelta;\n\t    callback(null, results);\n\t  }\n\t\n\t  function verifyAttachment(digest, callback) {\n\t\n\t    var req = attachStore.get(digest);\n\t    req.onsuccess = function (e) {\n\t      if (!e.target.result) {\n\t        var err = createError(MISSING_STUB,\n\t          'unknown stub attachment with digest ' +\n\t          digest);\n\t        err.status = 412;\n\t        callback(err);\n\t      } else {\n\t        callback();\n\t      }\n\t    };\n\t  }\n\t\n\t  function verifyAttachments(finish) {\n\t\n\t\n\t    var digests = [];\n\t    docInfos.forEach(function (docInfo) {\n\t      if (docInfo.data && docInfo.data._attachments) {\n\t        Object.keys(docInfo.data._attachments).forEach(function (filename) {\n\t          var att = docInfo.data._attachments[filename];\n\t          if (att.stub) {\n\t            digests.push(att.digest);\n\t          }\n\t        });\n\t      }\n\t    });\n\t    if (!digests.length) {\n\t      return finish();\n\t    }\n\t    var numDone = 0;\n\t    var err;\n\t\n\t    function checkDone() {\n\t      if (++numDone === digests.length) {\n\t        finish(err);\n\t      }\n\t    }\n\t    digests.forEach(function (digest) {\n\t      verifyAttachment(digest, function (attErr) {\n\t        if (attErr && !err) {\n\t          err = attErr;\n\t        }\n\t        checkDone();\n\t      });\n\t    });\n\t  }\n\t\n\t  function writeDoc(docInfo, winningRev, winningRevIsDeleted, newRevIsDeleted,\n\t                    isUpdate, delta, resultsIdx, callback) {\n\t\n\t    docCountDelta += delta;\n\t\n\t    docInfo.metadata.winningRev = winningRev;\n\t    docInfo.metadata.deleted = winningRevIsDeleted;\n\t\n\t    var doc = docInfo.data;\n\t    doc._id = docInfo.metadata.id;\n\t    doc._rev = docInfo.metadata.rev;\n\t\n\t    if (newRevIsDeleted) {\n\t      doc._deleted = true;\n\t    }\n\t\n\t    var hasAttachments = doc._attachments &&\n\t      Object.keys(doc._attachments).length;\n\t    if (hasAttachments) {\n\t      return writeAttachments(docInfo, winningRev, winningRevIsDeleted,\n\t        isUpdate, resultsIdx, callback);\n\t    }\n\t\n\t    finishDoc(docInfo, winningRev, winningRevIsDeleted,\n\t      isUpdate, resultsIdx, callback);\n\t  }\n\t\n\t  function autoCompact(docInfo) {\n\t\n\t    var revsToDelete = compactTree(docInfo.metadata);\n\t    compactRevs(revsToDelete, docInfo.metadata.id, txn);\n\t  }\n\t\n\t  function finishDoc(docInfo, winningRev, winningRevIsDeleted,\n\t                     isUpdate, resultsIdx, callback) {\n\t\n\t    var doc = docInfo.data;\n\t    var metadata = docInfo.metadata;\n\t\n\t    doc._doc_id_rev = metadata.id + '::' + metadata.rev;\n\t    delete doc._id;\n\t    delete doc._rev;\n\t\n\t    function afterPutDoc(e) {\n\t      if (isUpdate && api.auto_compaction) {\n\t        autoCompact(docInfo);\n\t      } else if (docInfo.stemmedRevs.length) {\n\t        compactRevs(docInfo.stemmedRevs, docInfo.metadata.id, txn);\n\t      }\n\t\n\t      metadata.seq = e.target.result;\n\t      // Current _rev is calculated from _rev_tree on read\n\t      delete metadata.rev;\n\t      var metadataToStore = encodeMetadata(metadata, winningRev,\n\t        winningRevIsDeleted);\n\t      var metaDataReq = docStore.put(metadataToStore);\n\t      metaDataReq.onsuccess = afterPutMetadata;\n\t    }\n\t\n\t    function afterPutDocError(e) {\n\t      // ConstraintError, need to update, not put (see #1638 for details)\n\t      e.preventDefault(); // avoid transaction abort\n\t      e.stopPropagation(); // avoid transaction onerror\n\t      var index = bySeqStore.index('_doc_id_rev');\n\t      var getKeyReq = index.getKey(doc._doc_id_rev);\n\t      getKeyReq.onsuccess = function (e) {\n\t        var putReq = bySeqStore.put(doc, e.target.result);\n\t        putReq.onsuccess = afterPutDoc;\n\t      };\n\t    }\n\t\n\t    function afterPutMetadata() {\n\t      results[resultsIdx] = {\n\t        ok: true,\n\t        id: metadata.id,\n\t        rev: winningRev\n\t      };\n\t      fetchedDocs.set(docInfo.metadata.id, docInfo.metadata);\n\t      insertAttachmentMappings(docInfo, metadata.seq, callback);\n\t    }\n\t\n\t    var putReq = bySeqStore.put(doc);\n\t\n\t    putReq.onsuccess = afterPutDoc;\n\t    putReq.onerror = afterPutDocError;\n\t  }\n\t\n\t  function writeAttachments(docInfo, winningRev, winningRevIsDeleted,\n\t                            isUpdate, resultsIdx, callback) {\n\t\n\t\n\t    var doc = docInfo.data;\n\t\n\t    var numDone = 0;\n\t    var attachments = Object.keys(doc._attachments);\n\t\n\t    function collectResults() {\n\t      if (numDone === attachments.length) {\n\t        finishDoc(docInfo, winningRev, winningRevIsDeleted,\n\t          isUpdate, resultsIdx, callback);\n\t      }\n\t    }\n\t\n\t    function attachmentSaved() {\n\t      numDone++;\n\t      collectResults();\n\t    }\n\t\n\t    attachments.forEach(function (key) {\n\t      var att = docInfo.data._attachments[key];\n\t      if (!att.stub) {\n\t        var data = att.data;\n\t        delete att.data;\n\t        var digest = att.digest;\n\t        saveAttachment(digest, data, attachmentSaved);\n\t      } else {\n\t        numDone++;\n\t        collectResults();\n\t      }\n\t    });\n\t  }\n\t\n\t  // map seqs to attachment digests, which\n\t  // we will need later during compaction\n\t  function insertAttachmentMappings(docInfo, seq, callback) {\n\t\n\t    var attsAdded = 0;\n\t    var attsToAdd = Object.keys(docInfo.data._attachments || {});\n\t\n\t    if (!attsToAdd.length) {\n\t      return callback();\n\t    }\n\t\n\t    function checkDone() {\n\t      if (++attsAdded === attsToAdd.length) {\n\t        callback();\n\t      }\n\t    }\n\t\n\t    function add(att) {\n\t      var digest = docInfo.data._attachments[att].digest;\n\t      var req = attachAndSeqStore.put({\n\t        seq: seq,\n\t        digestSeq: digest + '::' + seq\n\t      });\n\t\n\t      req.onsuccess = checkDone;\n\t      req.onerror = function (e) {\n\t        // this callback is for a constaint error, which we ignore\n\t        // because this docid/rev has already been associated with\n\t        // the digest (e.g. when new_edits == false)\n\t        e.preventDefault(); // avoid transaction abort\n\t        e.stopPropagation(); // avoid transaction onerror\n\t        checkDone();\n\t      };\n\t    }\n\t    for (var i = 0; i < attsToAdd.length; i++) {\n\t      add(attsToAdd[i]); // do in parallel\n\t    }\n\t  }\n\t\n\t  function saveAttachment(digest, data, callback) {\n\t\n\t\n\t    var getKeyReq = attachStore.count(digest);\n\t    getKeyReq.onsuccess = function(e) {\n\t      var count = e.target.result;\n\t      if (count) {\n\t        return callback(); // already exists\n\t      }\n\t      var newAtt = {\n\t        digest: digest,\n\t        body: data\n\t      };\n\t      var putReq = attachStore.put(newAtt);\n\t      putReq.onsuccess = callback;\n\t    };\n\t  }\n\t}\n\t\n\tfunction createKeyRange(start, end, inclusiveEnd, key, descending) {\n\t  try {\n\t    if (start && end) {\n\t      if (descending) {\n\t        return IDBKeyRange.bound(end, start, !inclusiveEnd, false);\n\t      } else {\n\t        return IDBKeyRange.bound(start, end, false, !inclusiveEnd);\n\t      }\n\t    } else if (start) {\n\t      if (descending) {\n\t        return IDBKeyRange.upperBound(start);\n\t      } else {\n\t        return IDBKeyRange.lowerBound(start);\n\t      }\n\t    } else if (end) {\n\t      if (descending) {\n\t        return IDBKeyRange.lowerBound(end, !inclusiveEnd);\n\t      } else {\n\t        return IDBKeyRange.upperBound(end, !inclusiveEnd);\n\t      }\n\t    } else if (key) {\n\t      return IDBKeyRange.only(key);\n\t    }\n\t  } catch (e) {\n\t    return {error: e};\n\t  }\n\t  return null;\n\t}\n\t\n\tfunction handleKeyRangeError(api, opts, err, callback) {\n\t  if (err.name === \"DataError\" && err.code === 0) {\n\t    // data error, start is less than end\n\t    return callback(null, {\n\t      total_rows: api._meta.docCount,\n\t      offset: opts.skip,\n\t      rows: []\n\t    });\n\t  }\n\t  callback(createError(IDB_ERROR, err.name, err.message));\n\t}\n\t\n\tfunction idbAllDocs(opts, api, idb, callback) {\n\t\n\t  function allDocsQuery(opts, callback) {\n\t    var start = 'startkey' in opts ? opts.startkey : false;\n\t    var end = 'endkey' in opts ? opts.endkey : false;\n\t    var key = 'key' in opts ? opts.key : false;\n\t    var skip = opts.skip || 0;\n\t    var limit = typeof opts.limit === 'number' ? opts.limit : -1;\n\t    var inclusiveEnd = opts.inclusive_end !== false;\n\t    var descending = 'descending' in opts && opts.descending ? 'prev' : null;\n\t\n\t    var keyRange = createKeyRange(start, end, inclusiveEnd, key, descending);\n\t    if (keyRange && keyRange.error) {\n\t      return handleKeyRangeError(api, opts, keyRange.error, callback);\n\t    }\n\t\n\t    var stores = [DOC_STORE, BY_SEQ_STORE];\n\t\n\t    if (opts.attachments) {\n\t      stores.push(ATTACH_STORE);\n\t    }\n\t    var txnResult = openTransactionSafely(idb, stores, 'readonly');\n\t    if (txnResult.error) {\n\t      return callback(txnResult.error);\n\t    }\n\t    var txn = txnResult.txn;\n\t    var docStore = txn.objectStore(DOC_STORE);\n\t    var seqStore = txn.objectStore(BY_SEQ_STORE);\n\t    var cursor = descending ?\n\t      docStore.openCursor(keyRange, descending) :\n\t      docStore.openCursor(keyRange);\n\t    var docIdRevIndex = seqStore.index('_doc_id_rev');\n\t    var results = [];\n\t    var docCount = 0;\n\t\n\t    // if the user specifies include_docs=true, then we don't\n\t    // want to block the main cursor while we're fetching the doc\n\t    function fetchDocAsynchronously(metadata, row, winningRev) {\n\t      var key = metadata.id + \"::\" + winningRev;\n\t      docIdRevIndex.get(key).onsuccess =  function onGetDoc(e) {\n\t        row.doc = decodeDoc(e.target.result);\n\t        if (opts.conflicts) {\n\t          row.doc._conflicts = collectConflicts(metadata);\n\t        }\n\t        fetchAttachmentsIfNecessary(row.doc, opts, txn);\n\t      };\n\t    }\n\t\n\t    function allDocsInner(cursor, winningRev, metadata) {\n\t      var row = {\n\t        id: metadata.id,\n\t        key: metadata.id,\n\t        value: {\n\t          rev: winningRev\n\t        }\n\t      };\n\t      var deleted = metadata.deleted;\n\t      if (opts.deleted === 'ok') {\n\t        results.push(row);\n\t        // deleted docs are okay with \"keys\" requests\n\t        if (deleted) {\n\t          row.value.deleted = true;\n\t          row.doc = null;\n\t        } else if (opts.include_docs) {\n\t          fetchDocAsynchronously(metadata, row, winningRev);\n\t        }\n\t      } else if (!deleted && skip-- <= 0) {\n\t        results.push(row);\n\t        if (opts.include_docs) {\n\t          fetchDocAsynchronously(metadata, row, winningRev);\n\t        }\n\t        if (--limit === 0) {\n\t          return;\n\t        }\n\t      }\n\t      cursor.continue();\n\t    }\n\t\n\t    function onGetCursor(e) {\n\t      docCount = api._meta.docCount; // do this within the txn for consistency\n\t      var cursor = e.target.result;\n\t      if (!cursor) {\n\t        return;\n\t      }\n\t      var metadata = decodeMetadata(cursor.value);\n\t      var winningRev = metadata.winningRev;\n\t\n\t      allDocsInner(cursor, winningRev, metadata);\n\t    }\n\t\n\t    function onResultsReady() {\n\t      callback(null, {\n\t        total_rows: docCount,\n\t        offset: opts.skip,\n\t        rows: results\n\t      });\n\t    }\n\t\n\t    function onTxnComplete() {\n\t      if (opts.attachments) {\n\t        postProcessAttachments(results, opts.binary).then(onResultsReady);\n\t      } else {\n\t        onResultsReady();\n\t      }\n\t    }\n\t\n\t    txn.oncomplete = onTxnComplete;\n\t    cursor.onsuccess = onGetCursor;\n\t  }\n\t\n\t  function allDocs(opts, callback) {\n\t\n\t    if (opts.limit === 0) {\n\t      return callback(null, {\n\t        total_rows: api._meta.docCount,\n\t        offset: opts.skip,\n\t        rows: []\n\t      });\n\t    }\n\t    allDocsQuery(opts, callback);\n\t  }\n\t\n\t  allDocs(opts, callback);\n\t}\n\t\n\t//\n\t// Blobs are not supported in all versions of IndexedDB, notably\n\t// Chrome <37 and Android <5. In those versions, storing a blob will throw.\n\t//\n\t// Various other blob bugs exist in Chrome v37-42 (inclusive).\n\t// Detecting them is expensive and confusing to users, and Chrome 37-42\n\t// is at very low usage worldwide, so we do a hacky userAgent check instead.\n\t//\n\t// content-type bug: https://code.google.com/p/chromium/issues/detail?id=408120\n\t// 404 bug: https://code.google.com/p/chromium/issues/detail?id=447916\n\t// FileReader bug: https://code.google.com/p/chromium/issues/detail?id=447836\n\t//\n\tfunction checkBlobSupport(txn) {\n\t  return new PouchPromise(function (resolve) {\n\t    var blob = createBlob(['']);\n\t    txn.objectStore(DETECT_BLOB_SUPPORT_STORE).put(blob, 'key');\n\t\n\t    txn.onabort = function (e) {\n\t      // If the transaction aborts now its due to not being able to\n\t      // write to the database, likely due to the disk being full\n\t      e.preventDefault();\n\t      e.stopPropagation();\n\t      resolve(false);\n\t    };\n\t\n\t    txn.oncomplete = function () {\n\t      var matchedChrome = navigator.userAgent.match(/Chrome\\/(\\d+)/);\n\t      var matchedEdge = navigator.userAgent.match(/Edge\\//);\n\t      // MS Edge pretends to be Chrome 42:\n\t      // https://msdn.microsoft.com/en-us/library/hh869301%28v=vs.85%29.aspx\n\t      resolve(matchedEdge || !matchedChrome ||\n\t        parseInt(matchedChrome[1], 10) >= 43);\n\t    };\n\t  }).catch(function () {\n\t    return false; // error, so assume unsupported\n\t  });\n\t}\n\t\n\tinherits(Changes$1, events.EventEmitter);\n\t\n\t/* istanbul ignore next */\n\tfunction attachBrowserEvents(self) {\n\t  if (isChromeApp()) {\n\t    chrome.storage.onChanged.addListener(function (e) {\n\t      // make sure it's event addressed to us\n\t      if (e.db_name != null) {\n\t        //object only has oldValue, newValue members\n\t        self.emit(e.dbName.newValue);\n\t      }\n\t    });\n\t  } else if (hasLocalStorage()) {\n\t    if (typeof addEventListener !== 'undefined') {\n\t      addEventListener(\"storage\", function (e) {\n\t        self.emit(e.key);\n\t      });\n\t    } else { // old IE\n\t      window.attachEvent(\"storage\", function (e) {\n\t        self.emit(e.key);\n\t      });\n\t    }\n\t  }\n\t}\n\t\n\tfunction Changes$1() {\n\t  events.EventEmitter.call(this);\n\t  this._listeners = {};\n\t\n\t  attachBrowserEvents(this);\n\t}\n\tChanges$1.prototype.addListener = function (dbName, id, db, opts) {\n\t  /* istanbul ignore if */\n\t  if (this._listeners[id]) {\n\t    return;\n\t  }\n\t  var self = this;\n\t  var inprogress = false;\n\t  function eventFunction() {\n\t    /* istanbul ignore if */\n\t    if (!self._listeners[id]) {\n\t      return;\n\t    }\n\t    if (inprogress) {\n\t      inprogress = 'waiting';\n\t      return;\n\t    }\n\t    inprogress = true;\n\t    var changesOpts = pick(opts, [\n\t      'style', 'include_docs', 'attachments', 'conflicts', 'filter',\n\t      'doc_ids', 'view', 'since', 'query_params', 'binary'\n\t    ]);\n\t\n\t    /* istanbul ignore next */\n\t    function onError() {\n\t      inprogress = false;\n\t    }\n\t\n\t    db.changes(changesOpts).on('change', function (c) {\n\t      if (c.seq > opts.since && !opts.cancelled) {\n\t        opts.since = c.seq;\n\t        opts.onChange(c);\n\t      }\n\t    }).on('complete', function () {\n\t      if (inprogress === 'waiting') {\n\t        setTimeout(function(){\n\t          eventFunction();\n\t        },0);\n\t      }\n\t      inprogress = false;\n\t    }).on('error', onError);\n\t  }\n\t  this._listeners[id] = eventFunction;\n\t  this.on(dbName, eventFunction);\n\t};\n\t\n\tChanges$1.prototype.removeListener = function (dbName, id) {\n\t  /* istanbul ignore if */\n\t  if (!(id in this._listeners)) {\n\t    return;\n\t  }\n\t  events.EventEmitter.prototype.removeListener.call(this, dbName,\n\t    this._listeners[id]);\n\t};\n\t\n\t\n\t/* istanbul ignore next */\n\tChanges$1.prototype.notifyLocalWindows = function (dbName) {\n\t  //do a useless change on a storage thing\n\t  //in order to get other windows's listeners to activate\n\t  if (isChromeApp()) {\n\t    chrome.storage.local.set({dbName: dbName});\n\t  } else if (hasLocalStorage()) {\n\t    localStorage[dbName] = (localStorage[dbName] === \"a\") ? \"b\" : \"a\";\n\t  }\n\t};\n\t\n\tChanges$1.prototype.notify = function (dbName) {\n\t  this.emit(dbName);\n\t  this.notifyLocalWindows(dbName);\n\t};\n\t\n\tvar cachedDBs = new pouchdbCollections.Map();\n\tvar blobSupportPromise;\n\tvar idbChanges = new Changes$1();\n\tvar openReqList = new pouchdbCollections.Map();\n\t\n\tfunction IdbPouch(opts, callback) {\n\t  var api = this;\n\t\n\t  taskQueue.queue.push({\n\t    action: function (thisCallback) {\n\t      init(api, opts, thisCallback);\n\t    },\n\t    callback: callback\n\t  });\n\t  applyNext(api.constructor);\n\t}\n\t\n\tfunction init(api, opts, callback) {\n\t\n\t  var dbName = opts.name;\n\t\n\t  var idb = null;\n\t  api._meta = null;\n\t\n\t  // called when creating a fresh new database\n\t  function createSchema(db) {\n\t    var docStore = db.createObjectStore(DOC_STORE, {keyPath : 'id'});\n\t    db.createObjectStore(BY_SEQ_STORE, {autoIncrement: true})\n\t      .createIndex('_doc_id_rev', '_doc_id_rev', {unique: true});\n\t    db.createObjectStore(ATTACH_STORE, {keyPath: 'digest'});\n\t    db.createObjectStore(META_STORE, {keyPath: 'id', autoIncrement: false});\n\t    db.createObjectStore(DETECT_BLOB_SUPPORT_STORE);\n\t\n\t    // added in v2\n\t    docStore.createIndex('deletedOrLocal', 'deletedOrLocal', {unique : false});\n\t\n\t    // added in v3\n\t    db.createObjectStore(LOCAL_STORE, {keyPath: '_id'});\n\t\n\t    // added in v4\n\t    var attAndSeqStore = db.createObjectStore(ATTACH_AND_SEQ_STORE,\n\t      {autoIncrement: true});\n\t    attAndSeqStore.createIndex('seq', 'seq');\n\t    attAndSeqStore.createIndex('digestSeq', 'digestSeq', {unique: true});\n\t  }\n\t\n\t  // migration to version 2\n\t  // unfortunately \"deletedOrLocal\" is a misnomer now that we no longer\n\t  // store local docs in the main doc-store, but whaddyagonnado\n\t  function addDeletedOrLocalIndex(txn, callback) {\n\t    var docStore = txn.objectStore(DOC_STORE);\n\t    docStore.createIndex('deletedOrLocal', 'deletedOrLocal', {unique : false});\n\t\n\t    docStore.openCursor().onsuccess = function (event) {\n\t      var cursor = event.target.result;\n\t      if (cursor) {\n\t        var metadata = cursor.value;\n\t        var deleted = isDeleted(metadata);\n\t        metadata.deletedOrLocal = deleted ? \"1\" : \"0\";\n\t        docStore.put(metadata);\n\t        cursor.continue();\n\t      } else {\n\t        callback();\n\t      }\n\t    };\n\t  }\n\t\n\t  // migration to version 3 (part 1)\n\t  function createLocalStoreSchema(db) {\n\t    db.createObjectStore(LOCAL_STORE, {keyPath: '_id'})\n\t      .createIndex('_doc_id_rev', '_doc_id_rev', {unique: true});\n\t  }\n\t\n\t  // migration to version 3 (part 2)\n\t  function migrateLocalStore(txn, cb) {\n\t    var localStore = txn.objectStore(LOCAL_STORE);\n\t    var docStore = txn.objectStore(DOC_STORE);\n\t    var seqStore = txn.objectStore(BY_SEQ_STORE);\n\t\n\t    var cursor = docStore.openCursor();\n\t    cursor.onsuccess = function (event) {\n\t      var cursor = event.target.result;\n\t      if (cursor) {\n\t        var metadata = cursor.value;\n\t        var docId = metadata.id;\n\t        var local = isLocalId(docId);\n\t        var rev = winningRev(metadata);\n\t        if (local) {\n\t          var docIdRev = docId + \"::\" + rev;\n\t          // remove all seq entries\n\t          // associated with this docId\n\t          var start = docId + \"::\";\n\t          var end = docId + \"::~\";\n\t          var index = seqStore.index('_doc_id_rev');\n\t          var range = IDBKeyRange.bound(start, end, false, false);\n\t          var seqCursor = index.openCursor(range);\n\t          seqCursor.onsuccess = function (e) {\n\t            seqCursor = e.target.result;\n\t            if (!seqCursor) {\n\t              // done\n\t              docStore.delete(cursor.primaryKey);\n\t              cursor.continue();\n\t            } else {\n\t              var data = seqCursor.value;\n\t              if (data._doc_id_rev === docIdRev) {\n\t                localStore.put(data);\n\t              }\n\t              seqStore.delete(seqCursor.primaryKey);\n\t              seqCursor.continue();\n\t            }\n\t          };\n\t        } else {\n\t          cursor.continue();\n\t        }\n\t      } else if (cb) {\n\t        cb();\n\t      }\n\t    };\n\t  }\n\t\n\t  // migration to version 4 (part 1)\n\t  function addAttachAndSeqStore(db) {\n\t    var attAndSeqStore = db.createObjectStore(ATTACH_AND_SEQ_STORE,\n\t      {autoIncrement: true});\n\t    attAndSeqStore.createIndex('seq', 'seq');\n\t    attAndSeqStore.createIndex('digestSeq', 'digestSeq', {unique: true});\n\t  }\n\t\n\t  // migration to version 4 (part 2)\n\t  function migrateAttsAndSeqs(txn, callback) {\n\t    var seqStore = txn.objectStore(BY_SEQ_STORE);\n\t    var attStore = txn.objectStore(ATTACH_STORE);\n\t    var attAndSeqStore = txn.objectStore(ATTACH_AND_SEQ_STORE);\n\t\n\t    // need to actually populate the table. this is the expensive part,\n\t    // so as an optimization, check first that this database even\n\t    // contains attachments\n\t    var req = attStore.count();\n\t    req.onsuccess = function (e) {\n\t      var count = e.target.result;\n\t      if (!count) {\n\t        return callback(); // done\n\t      }\n\t\n\t      seqStore.openCursor().onsuccess = function (e) {\n\t        var cursor = e.target.result;\n\t        if (!cursor) {\n\t          return callback(); // done\n\t        }\n\t        var doc = cursor.value;\n\t        var seq = cursor.primaryKey;\n\t        var atts = Object.keys(doc._attachments || {});\n\t        var digestMap = {};\n\t        for (var j = 0; j < atts.length; j++) {\n\t          var att = doc._attachments[atts[j]];\n\t          digestMap[att.digest] = true; // uniq digests, just in case\n\t        }\n\t        var digests = Object.keys(digestMap);\n\t        for (j = 0; j < digests.length; j++) {\n\t          var digest = digests[j];\n\t          attAndSeqStore.put({\n\t            seq: seq,\n\t            digestSeq: digest + '::' + seq\n\t          });\n\t        }\n\t        cursor.continue();\n\t      };\n\t    };\n\t  }\n\t\n\t  // migration to version 5\n\t  // Instead of relying on on-the-fly migration of metadata,\n\t  // this brings the doc-store to its modern form:\n\t  // - metadata.winningrev\n\t  // - metadata.seq\n\t  // - stringify the metadata when storing it\n\t  function migrateMetadata(txn) {\n\t\n\t    function decodeMetadataCompat(storedObject) {\n\t      if (!storedObject.data) {\n\t        // old format, when we didn't store it stringified\n\t        storedObject.deleted = storedObject.deletedOrLocal === '1';\n\t        return storedObject;\n\t      }\n\t      return decodeMetadata(storedObject);\n\t    }\n\t\n\t    // ensure that every metadata has a winningRev and seq,\n\t    // which was previously created on-the-fly but better to migrate\n\t    var bySeqStore = txn.objectStore(BY_SEQ_STORE);\n\t    var docStore = txn.objectStore(DOC_STORE);\n\t    var cursor = docStore.openCursor();\n\t    cursor.onsuccess = function (e) {\n\t      var cursor = e.target.result;\n\t      if (!cursor) {\n\t        return; // done\n\t      }\n\t      var metadata = decodeMetadataCompat(cursor.value);\n\t\n\t      metadata.winningRev = metadata.winningRev ||\n\t        winningRev(metadata);\n\t\n\t      function fetchMetadataSeq() {\n\t        // metadata.seq was added post-3.2.0, so if it's missing,\n\t        // we need to fetch it manually\n\t        var start = metadata.id + '::';\n\t        var end = metadata.id + '::\\uffff';\n\t        var req = bySeqStore.index('_doc_id_rev').openCursor(\n\t          IDBKeyRange.bound(start, end));\n\t\n\t        var metadataSeq = 0;\n\t        req.onsuccess = function (e) {\n\t          var cursor = e.target.result;\n\t          if (!cursor) {\n\t            metadata.seq = metadataSeq;\n\t            return onGetMetadataSeq();\n\t          }\n\t          var seq = cursor.primaryKey;\n\t          if (seq > metadataSeq) {\n\t            metadataSeq = seq;\n\t          }\n\t          cursor.continue();\n\t        };\n\t      }\n\t\n\t      function onGetMetadataSeq() {\n\t        var metadataToStore = encodeMetadata(metadata,\n\t          metadata.winningRev, metadata.deleted);\n\t\n\t        var req = docStore.put(metadataToStore);\n\t        req.onsuccess = function () {\n\t          cursor.continue();\n\t        };\n\t      }\n\t\n\t      if (metadata.seq) {\n\t        return onGetMetadataSeq();\n\t      }\n\t\n\t      fetchMetadataSeq();\n\t    };\n\t\n\t  }\n\t\n\t  api.type = function () {\n\t    return 'idb';\n\t  };\n\t\n\t  api._id = toPromise(function (callback) {\n\t    callback(null, api._meta.instanceId);\n\t  });\n\t\n\t  api._bulkDocs = function idb_bulkDocs(req, reqOpts, callback) {\n\t    idbBulkDocs(opts, req, reqOpts, api, idb, idbChanges, callback);\n\t  };\n\t\n\t  // First we look up the metadata in the ids database, then we fetch the\n\t  // current revision(s) from the by sequence store\n\t  api._get = function idb_get(id, opts, callback) {\n\t    var doc;\n\t    var metadata;\n\t    var err;\n\t    var txn = opts.ctx;\n\t    if (!txn) {\n\t      var txnResult = openTransactionSafely(idb,\n\t        [DOC_STORE, BY_SEQ_STORE, ATTACH_STORE], 'readonly');\n\t      if (txnResult.error) {\n\t        return callback(txnResult.error);\n\t      }\n\t      txn = txnResult.txn;\n\t    }\n\t\n\t    function finish() {\n\t      callback(err, {doc: doc, metadata: metadata, ctx: txn});\n\t    }\n\t\n\t    txn.objectStore(DOC_STORE).get(id).onsuccess = function (e) {\n\t      metadata = decodeMetadata(e.target.result);\n\t      // we can determine the result here if:\n\t      // 1. there is no such document\n\t      // 2. the document is deleted and we don't ask about specific rev\n\t      // When we ask with opts.rev we expect the answer to be either\n\t      // doc (possibly with _deleted=true) or missing error\n\t      if (!metadata) {\n\t        err = createError(MISSING_DOC, 'missing');\n\t        return finish();\n\t      }\n\t      if (isDeleted(metadata) && !opts.rev) {\n\t        err = createError(MISSING_DOC, \"deleted\");\n\t        return finish();\n\t      }\n\t      var objectStore = txn.objectStore(BY_SEQ_STORE);\n\t\n\t      var rev = opts.rev || metadata.winningRev;\n\t      var key = metadata.id + '::' + rev;\n\t\n\t      objectStore.index('_doc_id_rev').get(key).onsuccess = function (e) {\n\t        doc = e.target.result;\n\t        if (doc) {\n\t          doc = decodeDoc(doc);\n\t        }\n\t        if (!doc) {\n\t          err = createError(MISSING_DOC, 'missing');\n\t          return finish();\n\t        }\n\t        finish();\n\t      };\n\t    };\n\t  };\n\t\n\t  api._getAttachment = function (attachment, opts, callback) {\n\t    var txn;\n\t    if (opts.ctx) {\n\t      txn = opts.ctx;\n\t    } else {\n\t      var txnResult = openTransactionSafely(idb,\n\t        [DOC_STORE, BY_SEQ_STORE, ATTACH_STORE], 'readonly');\n\t      if (txnResult.error) {\n\t        return callback(txnResult.error);\n\t      }\n\t      txn = txnResult.txn;\n\t    }\n\t    var digest = attachment.digest;\n\t    var type = attachment.content_type;\n\t\n\t    txn.objectStore(ATTACH_STORE).get(digest).onsuccess = function (e) {\n\t      var body = e.target.result.body;\n\t      readBlobData(body, type, opts.binary, function (blobData) {\n\t        callback(null, blobData);\n\t      });\n\t    };\n\t  };\n\t\n\t  api._info = function idb_info(callback) {\n\t\n\t    if (idb === null || !cachedDBs.has(dbName)) {\n\t      var error = new Error('db isn\\'t open');\n\t      error.id = 'idbNull';\n\t      return callback(error);\n\t    }\n\t    var updateSeq;\n\t    var docCount;\n\t\n\t    var txnResult = openTransactionSafely(idb, [BY_SEQ_STORE], 'readonly');\n\t    if (txnResult.error) {\n\t      return callback(txnResult.error);\n\t    }\n\t    var txn = txnResult.txn;\n\t    var cursor = txn.objectStore(BY_SEQ_STORE).openCursor(null, 'prev');\n\t    cursor.onsuccess = function (event) {\n\t      var cursor = event.target.result;\n\t      updateSeq = cursor ? cursor.key : 0;\n\t      // count within the same txn for consistency\n\t      docCount = api._meta.docCount;\n\t    };\n\t\n\t    txn.oncomplete = function () {\n\t      callback(null, {\n\t        doc_count: docCount,\n\t        update_seq: updateSeq,\n\t        // for debugging\n\t        idb_attachment_format: (api._meta.blobSupport ? 'binary' : 'base64')\n\t      });\n\t    };\n\t  };\n\t\n\t  api._allDocs = function idb_allDocs(opts, callback) {\n\t    idbAllDocs(opts, api, idb, callback);\n\t  };\n\t\n\t  api._changes = function (opts) {\n\t    opts = clone(opts);\n\t\n\t    if (opts.continuous) {\n\t      var id = dbName + ':' + uuid();\n\t      idbChanges.addListener(dbName, id, api, opts);\n\t      idbChanges.notify(dbName);\n\t      return {\n\t        cancel: function () {\n\t          idbChanges.removeListener(dbName, id);\n\t        }\n\t      };\n\t    }\n\t\n\t    var docIds = opts.doc_ids && new pouchdbCollections.Set(opts.doc_ids);\n\t\n\t    opts.since = opts.since || 0;\n\t    var lastSeq = opts.since;\n\t\n\t    var limit = 'limit' in opts ? opts.limit : -1;\n\t    if (limit === 0) {\n\t      limit = 1; // per CouchDB _changes spec\n\t    }\n\t    var returnDocs;\n\t    if ('return_docs' in opts) {\n\t      returnDocs = opts.return_docs;\n\t    } else if ('returnDocs' in opts) {\n\t      // TODO: Remove 'returnDocs' in favor of 'return_docs' in a future release\n\t      returnDocs = opts.returnDocs;\n\t    } else {\n\t      returnDocs = true;\n\t    }\n\t\n\t    var results = [];\n\t    var numResults = 0;\n\t    var filter = filterChange(opts);\n\t    var docIdsToMetadata = new pouchdbCollections.Map();\n\t\n\t    var txn;\n\t    var bySeqStore;\n\t    var docStore;\n\t    var docIdRevIndex;\n\t\n\t    function onGetCursor(cursor) {\n\t\n\t      var doc = decodeDoc(cursor.value);\n\t      var seq = cursor.key;\n\t\n\t      if (docIds && !docIds.has(doc._id)) {\n\t        return cursor.continue();\n\t      }\n\t\n\t      var metadata;\n\t\n\t      function onGetMetadata() {\n\t        if (metadata.seq !== seq) {\n\t          // some other seq is later\n\t          return cursor.continue();\n\t        }\n\t\n\t        lastSeq = seq;\n\t\n\t        if (metadata.winningRev === doc._rev) {\n\t          return onGetWinningDoc(doc);\n\t        }\n\t\n\t        fetchWinningDoc();\n\t      }\n\t\n\t      function fetchWinningDoc() {\n\t        var docIdRev = doc._id + '::' + metadata.winningRev;\n\t        var req = docIdRevIndex.get(docIdRev);\n\t        req.onsuccess = function (e) {\n\t          onGetWinningDoc(decodeDoc(e.target.result));\n\t        };\n\t      }\n\t\n\t      function onGetWinningDoc(winningDoc) {\n\t\n\t        var change = opts.processChange(winningDoc, metadata, opts);\n\t        change.seq = metadata.seq;\n\t\n\t        var filtered = filter(change);\n\t        if (typeof filtered === 'object') {\n\t          return opts.complete(filtered);\n\t        }\n\t\n\t        if (filtered) {\n\t          numResults++;\n\t          if (returnDocs) {\n\t            results.push(change);\n\t          }\n\t          // process the attachment immediately\n\t          // for the benefit of live listeners\n\t          if (opts.attachments && opts.include_docs) {\n\t            fetchAttachmentsIfNecessary(winningDoc, opts, txn, function () {\n\t              postProcessAttachments([change], opts.binary).then(function () {\n\t                opts.onChange(change);\n\t              });\n\t            });\n\t          } else {\n\t            opts.onChange(change);\n\t          }\n\t        }\n\t        if (numResults !== limit) {\n\t          cursor.continue();\n\t        }\n\t      }\n\t\n\t      metadata = docIdsToMetadata.get(doc._id);\n\t      if (metadata) { // cached\n\t        return onGetMetadata();\n\t      }\n\t      // metadata not cached, have to go fetch it\n\t      docStore.get(doc._id).onsuccess = function (event) {\n\t        metadata = decodeMetadata(event.target.result);\n\t        docIdsToMetadata.set(doc._id, metadata);\n\t        onGetMetadata();\n\t      };\n\t    }\n\t\n\t    function onsuccess(event) {\n\t      var cursor = event.target.result;\n\t\n\t      if (!cursor) {\n\t        return;\n\t      }\n\t      onGetCursor(cursor);\n\t    }\n\t\n\t    function fetchChanges() {\n\t      var objectStores = [DOC_STORE, BY_SEQ_STORE];\n\t      if (opts.attachments) {\n\t        objectStores.push(ATTACH_STORE);\n\t      }\n\t      var txnResult = openTransactionSafely(idb, objectStores, 'readonly');\n\t      if (txnResult.error) {\n\t        return opts.complete(txnResult.error);\n\t      }\n\t      txn = txnResult.txn;\n\t      txn.onabort = idbError(opts.complete);\n\t      txn.oncomplete = onTxnComplete;\n\t\n\t      bySeqStore = txn.objectStore(BY_SEQ_STORE);\n\t      docStore = txn.objectStore(DOC_STORE);\n\t      docIdRevIndex = bySeqStore.index('_doc_id_rev');\n\t\n\t      var req;\n\t\n\t      if (opts.descending) {\n\t        req = bySeqStore.openCursor(null, 'prev');\n\t      } else {\n\t        req = bySeqStore.openCursor(IDBKeyRange.lowerBound(opts.since, true));\n\t      }\n\t\n\t      req.onsuccess = onsuccess;\n\t    }\n\t\n\t    fetchChanges();\n\t\n\t    function onTxnComplete() {\n\t\n\t      function finish() {\n\t        opts.complete(null, {\n\t          results: results,\n\t          last_seq: lastSeq\n\t        });\n\t      }\n\t\n\t      if (!opts.continuous && opts.attachments) {\n\t        // cannot guarantee that postProcessing was already done,\n\t        // so do it again\n\t        postProcessAttachments(results).then(finish);\n\t      } else {\n\t        finish();\n\t      }\n\t    }\n\t  };\n\t\n\t  api._close = function (callback) {\n\t    if (idb === null) {\n\t      return callback(createError(NOT_OPEN));\n\t    }\n\t\n\t    // https://developer.mozilla.org/en-US/docs/IndexedDB/IDBDatabase#close\n\t    // \"Returns immediately and closes the connection in a separate thread...\"\n\t    idb.close();\n\t    cachedDBs.delete(dbName);\n\t    idb = null;\n\t    callback();\n\t  };\n\t\n\t  api._getRevisionTree = function (docId, callback) {\n\t    var txnResult = openTransactionSafely(idb, [DOC_STORE], 'readonly');\n\t    if (txnResult.error) {\n\t      return callback(txnResult.error);\n\t    }\n\t    var txn = txnResult.txn;\n\t    var req = txn.objectStore(DOC_STORE).get(docId);\n\t    req.onsuccess = function (event) {\n\t      var doc = decodeMetadata(event.target.result);\n\t      if (!doc) {\n\t        callback(createError(MISSING_DOC));\n\t      } else {\n\t        callback(null, doc.rev_tree);\n\t      }\n\t    };\n\t  };\n\t\n\t  // This function removes revisions of document docId\n\t  // which are listed in revs and sets this document\n\t  // revision to to rev_tree\n\t  api._doCompaction = function (docId, revs, callback) {\n\t    var stores = [\n\t      DOC_STORE,\n\t      BY_SEQ_STORE,\n\t      ATTACH_STORE,\n\t      ATTACH_AND_SEQ_STORE\n\t    ];\n\t    var txnResult = openTransactionSafely(idb, stores, 'readwrite');\n\t    if (txnResult.error) {\n\t      return callback(txnResult.error);\n\t    }\n\t    var txn = txnResult.txn;\n\t\n\t    var docStore = txn.objectStore(DOC_STORE);\n\t\n\t    docStore.get(docId).onsuccess = function (event) {\n\t      var metadata = decodeMetadata(event.target.result);\n\t      traverseRevTree(metadata.rev_tree, function (isLeaf, pos,\n\t                                                         revHash, ctx, opts) {\n\t        var rev = pos + '-' + revHash;\n\t        if (revs.indexOf(rev) !== -1) {\n\t          opts.status = 'missing';\n\t        }\n\t      });\n\t      compactRevs(revs, docId, txn);\n\t      var winningRev = metadata.winningRev;\n\t      var deleted = metadata.deleted;\n\t      txn.objectStore(DOC_STORE).put(\n\t        encodeMetadata(metadata, winningRev, deleted));\n\t    };\n\t    txn.onabort = idbError(callback);\n\t    txn.oncomplete = function () {\n\t      callback();\n\t    };\n\t  };\n\t\n\t\n\t  api._getLocal = function (id, callback) {\n\t    var txnResult = openTransactionSafely(idb, [LOCAL_STORE], 'readonly');\n\t    if (txnResult.error) {\n\t      return callback(txnResult.error);\n\t    }\n\t    var tx = txnResult.txn;\n\t    var req = tx.objectStore(LOCAL_STORE).get(id);\n\t\n\t    req.onerror = idbError(callback);\n\t    req.onsuccess = function (e) {\n\t      var doc = e.target.result;\n\t      if (!doc) {\n\t        callback(createError(MISSING_DOC));\n\t      } else {\n\t        delete doc['_doc_id_rev']; // for backwards compat\n\t        callback(null, doc);\n\t      }\n\t    };\n\t  };\n\t\n\t  api._putLocal = function (doc, opts, callback) {\n\t    if (typeof opts === 'function') {\n\t      callback = opts;\n\t      opts = {};\n\t    }\n\t    delete doc._revisions; // ignore this, trust the rev\n\t    var oldRev = doc._rev;\n\t    var id = doc._id;\n\t    if (!oldRev) {\n\t      doc._rev = '0-1';\n\t    } else {\n\t      doc._rev = '0-' + (parseInt(oldRev.split('-')[1], 10) + 1);\n\t    }\n\t\n\t    var tx = opts.ctx;\n\t    var ret;\n\t    if (!tx) {\n\t      var txnResult = openTransactionSafely(idb, [LOCAL_STORE], 'readwrite');\n\t      if (txnResult.error) {\n\t        return callback(txnResult.error);\n\t      }\n\t      tx = txnResult.txn;\n\t      tx.onerror = idbError(callback);\n\t      tx.oncomplete = function () {\n\t        if (ret) {\n\t          callback(null, ret);\n\t        }\n\t      };\n\t    }\n\t\n\t    var oStore = tx.objectStore(LOCAL_STORE);\n\t    var req;\n\t    if (oldRev) {\n\t      req = oStore.get(id);\n\t      req.onsuccess = function (e) {\n\t        var oldDoc = e.target.result;\n\t        if (!oldDoc || oldDoc._rev !== oldRev) {\n\t          callback(createError(REV_CONFLICT));\n\t        } else { // update\n\t          var req = oStore.put(doc);\n\t          req.onsuccess = function () {\n\t            ret = {ok: true, id: doc._id, rev: doc._rev};\n\t            if (opts.ctx) { // return immediately\n\t              callback(null, ret);\n\t            }\n\t          };\n\t        }\n\t      };\n\t    } else { // new doc\n\t      req = oStore.add(doc);\n\t      req.onerror = function (e) {\n\t        // constraint error, already exists\n\t        callback(createError(REV_CONFLICT));\n\t        e.preventDefault(); // avoid transaction abort\n\t        e.stopPropagation(); // avoid transaction onerror\n\t      };\n\t      req.onsuccess = function () {\n\t        ret = {ok: true, id: doc._id, rev: doc._rev};\n\t        if (opts.ctx) { // return immediately\n\t          callback(null, ret);\n\t        }\n\t      };\n\t    }\n\t  };\n\t\n\t  api._removeLocal = function (doc, opts, callback) {\n\t    if (typeof opts === 'function') {\n\t      callback = opts;\n\t      opts = {};\n\t    }\n\t    var tx = opts.ctx;\n\t    if (!tx) {\n\t      var txnResult = openTransactionSafely(idb, [LOCAL_STORE], 'readwrite');\n\t      if (txnResult.error) {\n\t        return callback(txnResult.error);\n\t      }\n\t      tx = txnResult.txn;\n\t      tx.oncomplete = function () {\n\t        if (ret) {\n\t          callback(null, ret);\n\t        }\n\t      };\n\t    }\n\t    var ret;\n\t    var id = doc._id;\n\t    var oStore = tx.objectStore(LOCAL_STORE);\n\t    var req = oStore.get(id);\n\t\n\t    req.onerror = idbError(callback);\n\t    req.onsuccess = function (e) {\n\t      var oldDoc = e.target.result;\n\t      if (!oldDoc || oldDoc._rev !== doc._rev) {\n\t        callback(createError(MISSING_DOC));\n\t      } else {\n\t        oStore.delete(id);\n\t        ret = {ok: true, id: id, rev: '0-0'};\n\t        if (opts.ctx) { // return immediately\n\t          callback(null, ret);\n\t        }\n\t      }\n\t    };\n\t  };\n\t\n\t  api._destroy = function (opts, callback) {\n\t    idbChanges.removeAllListeners(dbName);\n\t\n\t    //Close open request for \"dbName\" database to fix ie delay.\n\t    var openReq = openReqList.get(dbName);\n\t    if (openReq && openReq.result) {\n\t      openReq.result.close();\n\t      cachedDBs.delete(dbName);\n\t    }\n\t    var req = indexedDB.deleteDatabase(dbName);\n\t\n\t    req.onsuccess = function () {\n\t      //Remove open request from the list.\n\t      openReqList.delete(dbName);\n\t      if (hasLocalStorage() && (dbName in localStorage)) {\n\t        delete localStorage[dbName];\n\t      }\n\t      callback(null, { 'ok': true });\n\t    };\n\t\n\t    req.onerror = idbError(callback);\n\t  };\n\t\n\t  var cached = cachedDBs.get(dbName);\n\t\n\t  if (cached) {\n\t    idb = cached.idb;\n\t    api._meta = cached.global;\n\t    process.nextTick(function () {\n\t      callback(null, api);\n\t    });\n\t    return;\n\t  }\n\t\n\t  var req;\n\t  if (opts.storage) {\n\t    req = tryStorageOption(dbName, opts.storage);\n\t  } else {\n\t    req = indexedDB.open(dbName, ADAPTER_VERSION);\n\t  }\n\t\n\t  openReqList.set(dbName, req);\n\t\n\t  req.onupgradeneeded = function (e) {\n\t    var db = e.target.result;\n\t    if (e.oldVersion < 1) {\n\t      return createSchema(db); // new db, initial schema\n\t    }\n\t    // do migrations\n\t\n\t    var txn = e.currentTarget.transaction;\n\t    // these migrations have to be done in this function, before\n\t    // control is returned to the event loop, because IndexedDB\n\t\n\t    if (e.oldVersion < 3) {\n\t      createLocalStoreSchema(db); // v2 -> v3\n\t    }\n\t    if (e.oldVersion < 4) {\n\t      addAttachAndSeqStore(db); // v3 -> v4\n\t    }\n\t\n\t    var migrations = [\n\t      addDeletedOrLocalIndex, // v1 -> v2\n\t      migrateLocalStore,      // v2 -> v3\n\t      migrateAttsAndSeqs,     // v3 -> v4\n\t      migrateMetadata         // v4 -> v5\n\t    ];\n\t\n\t    var i = e.oldVersion;\n\t\n\t    function next() {\n\t      var migration = migrations[i - 1];\n\t      i++;\n\t      if (migration) {\n\t        migration(txn, next);\n\t      }\n\t    }\n\t\n\t    next();\n\t  };\n\t\n\t  req.onsuccess = function (e) {\n\t\n\t    idb = e.target.result;\n\t\n\t    idb.onversionchange = function () {\n\t      idb.close();\n\t      cachedDBs.delete(dbName);\n\t    };\n\t\n\t    idb.onabort = function (e) {\n\t      console.error('Database has a global failure', e.target.error);\n\t      idb.close();\n\t      cachedDBs.delete(dbName);\n\t    };\n\t\n\t    var txn = idb.transaction([\n\t      META_STORE,\n\t      DETECT_BLOB_SUPPORT_STORE,\n\t      DOC_STORE\n\t    ], 'readwrite');\n\t\n\t    var req = txn.objectStore(META_STORE).get(META_STORE);\n\t\n\t    var blobSupport = null;\n\t    var docCount = null;\n\t    var instanceId = null;\n\t\n\t    req.onsuccess = function (e) {\n\t\n\t      var checkSetupComplete = function () {\n\t        if (blobSupport === null || docCount === null ||\n\t            instanceId === null) {\n\t          return;\n\t        } else {\n\t          api._meta = {\n\t            name: dbName,\n\t            instanceId: instanceId,\n\t            blobSupport: blobSupport,\n\t            docCount: docCount\n\t          };\n\t\n\t          cachedDBs.set(dbName, {\n\t            idb: idb,\n\t            global: api._meta\n\t          });\n\t          callback(null, api);\n\t        }\n\t      };\n\t\n\t      //\n\t      // fetch/store the id\n\t      //\n\t\n\t      var meta = e.target.result || {id: META_STORE};\n\t      if (dbName  + '_id' in meta) {\n\t        instanceId = meta[dbName + '_id'];\n\t        checkSetupComplete();\n\t      } else {\n\t        instanceId = uuid();\n\t        meta[dbName + '_id'] = instanceId;\n\t        txn.objectStore(META_STORE).put(meta).onsuccess = function () {\n\t          checkSetupComplete();\n\t        };\n\t      }\n\t\n\t      //\n\t      // check blob support\n\t      //\n\t\n\t      if (!blobSupportPromise) {\n\t        // make sure blob support is only checked once\n\t        blobSupportPromise = checkBlobSupport(txn);\n\t      }\n\t\n\t      blobSupportPromise.then(function (val) {\n\t        blobSupport = val;\n\t        checkSetupComplete();\n\t      });\n\t\n\t      //\n\t      // count docs\n\t      //\n\t\n\t      var index = txn.objectStore(DOC_STORE).index('deletedOrLocal');\n\t      index.count(IDBKeyRange.only('0')).onsuccess = function (e) {\n\t        docCount = e.target.result;\n\t        checkSetupComplete();\n\t      };\n\t\n\t    };\n\t  };\n\t\n\t  req.onerror = function() {\n\t    var msg = 'Failed to open indexedDB, are you in private browsing mode?';\n\t    console.error(msg);\n\t    callback(createError(IDB_ERROR, msg));\n\t  };\n\t}\n\t\n\tIdbPouch.valid = function () {\n\t  // Issue #2533, we finally gave up on doing bug\n\t  // detection instead of browser sniffing. Safari brought us\n\t  // to our knees.\n\t  var isSafari = typeof openDatabase !== 'undefined' &&\n\t    /(Safari|iPhone|iPad|iPod)/.test(navigator.userAgent) &&\n\t    !/Chrome/.test(navigator.userAgent) &&\n\t    !/BlackBerry/.test(navigator.platform);\n\t\n\t  // some outdated implementations of IDB that appear on Samsung\n\t  // and HTC Android devices <4.4 are missing IDBKeyRange\n\t  return !isSafari && typeof indexedDB !== 'undefined' &&\n\t    typeof IDBKeyRange !== 'undefined';\n\t};\n\t\n\tfunction tryStorageOption(dbName, storage) {\n\t  try { // option only available in Firefox 26+\n\t    return indexedDB.open(dbName, {\n\t      version: ADAPTER_VERSION,\n\t      storage: storage\n\t    });\n\t  } catch(err) {\n\t      return indexedDB.open(dbName, ADAPTER_VERSION);\n\t  }\n\t}\n\t\n\t//\n\t// Parsing hex strings. Yeah.\n\t//\n\t// So basically we need this because of a bug in WebSQL:\n\t// https://code.google.com/p/chromium/issues/detail?id=422690\n\t// https://bugs.webkit.org/show_bug.cgi?id=137637\n\t//\n\t// UTF-8 and UTF-16 are provided as separate functions\n\t// for meager performance improvements\n\t//\n\t\n\tfunction decodeUtf8(str) {\n\t  return decodeURIComponent(window.escape(str));\n\t}\n\t\n\tfunction hexToInt(charCode) {\n\t  // '0'-'9' is 48-57\n\t  // 'A'-'F' is 65-70\n\t  // SQLite will only give us uppercase hex\n\t  return charCode < 65 ? (charCode - 48) : (charCode - 55);\n\t}\n\t\n\t\n\t// Example:\n\t// pragma encoding=utf8;\n\t// select hex('A');\n\t// returns '41'\n\tfunction parseHexUtf8(str, start, end) {\n\t  var result = '';\n\t  while (start < end) {\n\t    result += String.fromCharCode(\n\t      (hexToInt(str.charCodeAt(start++)) << 4) |\n\t        hexToInt(str.charCodeAt(start++)));\n\t  }\n\t  return result;\n\t}\n\t\n\t// Example:\n\t// pragma encoding=utf16;\n\t// select hex('A');\n\t// returns '4100'\n\t// notice that the 00 comes after the 41 (i.e. it's swizzled)\n\tfunction parseHexUtf16(str, start, end) {\n\t  var result = '';\n\t  while (start < end) {\n\t    // UTF-16, so swizzle the bytes\n\t    result += String.fromCharCode(\n\t      (hexToInt(str.charCodeAt(start + 2)) << 12) |\n\t        (hexToInt(str.charCodeAt(start + 3)) << 8) |\n\t        (hexToInt(str.charCodeAt(start)) << 4) |\n\t        hexToInt(str.charCodeAt(start + 1)));\n\t    start += 4;\n\t  }\n\t  return result;\n\t}\n\t\n\tfunction parseHexString(str, encoding) {\n\t  if (encoding === 'UTF-8') {\n\t    return decodeUtf8(parseHexUtf8(str, 0, str.length));\n\t  } else {\n\t    return parseHexUtf16(str, 0, str.length);\n\t  }\n\t}\n\t\n\tfunction quote(str) {\n\t  return \"'\" + str + \"'\";\n\t}\n\t\n\tvar ADAPTER_VERSION$1 = 7; // used to manage migrations\n\t\n\t// The object stores created for each database\n\t// DOC_STORE stores the document meta data, its revision history and state\n\tvar DOC_STORE$1 = quote('document-store');\n\t// BY_SEQ_STORE stores a particular version of a document, keyed by its\n\t// sequence id\n\tvar BY_SEQ_STORE$1 = quote('by-sequence');\n\t// Where we store attachments\n\tvar ATTACH_STORE$1 = quote('attach-store');\n\tvar LOCAL_STORE$1 = quote('local-store');\n\tvar META_STORE$1 = quote('metadata-store');\n\t// where we store many-to-many relations between attachment\n\t// digests and seqs\n\tvar ATTACH_AND_SEQ_STORE$1 = quote('attach-seq-store');\n\t\n\tfunction createOpenDBFunction() {\n\t  if (typeof sqlitePlugin !== 'undefined') {\n\t    // The SQLite Plugin started deviating pretty heavily from the\n\t    // standard openDatabase() function, as they started adding more features.\n\t    // It's better to just use their \"new\" format and pass in a big ol'\n\t    // options object.\n\t    return sqlitePlugin.openDatabase.bind(sqlitePlugin);\n\t  }\n\t\n\t  if (typeof openDatabase !== 'undefined') {\n\t    return function openDB(opts) {\n\t      // Traditional WebSQL API\n\t      return openDatabase(opts.name, opts.version, opts.description, opts.size);\n\t    };\n\t  }\n\t}\n\t\n\tfunction valid() {\n\t  // SQLitePlugin leaks this global object, which we can use\n\t  // to detect if it's installed or not. The benefit is that it's\n\t  // declared immediately, before the 'deviceready' event has fired.\n\t  return typeof openDatabase !== 'undefined' ||\n\t    typeof SQLitePlugin !== 'undefined';\n\t}\n\t\n\t// escapeBlob and unescapeBlob are workarounds for a websql bug:\n\t// https://code.google.com/p/chromium/issues/detail?id=422690\n\t// https://bugs.webkit.org/show_bug.cgi?id=137637\n\t// The goal is to never actually insert the \\u0000 character\n\t// in the database.\n\tfunction escapeBlob(str) {\n\t  return str\n\t    .replace(/\\u0002/g, '\\u0002\\u0002')\n\t    .replace(/\\u0001/g, '\\u0001\\u0002')\n\t    .replace(/\\u0000/g, '\\u0001\\u0001');\n\t}\n\t\n\tfunction unescapeBlob(str) {\n\t  return str\n\t    .replace(/\\u0001\\u0001/g, '\\u0000')\n\t    .replace(/\\u0001\\u0002/g, '\\u0001')\n\t    .replace(/\\u0002\\u0002/g, '\\u0002');\n\t}\n\t\n\tfunction stringifyDoc(doc) {\n\t  // don't bother storing the id/rev. it uses lots of space,\n\t  // in persistent map/reduce especially\n\t  delete doc._id;\n\t  delete doc._rev;\n\t  return JSON.stringify(doc);\n\t}\n\t\n\tfunction unstringifyDoc(doc, id, rev) {\n\t  doc = JSON.parse(doc);\n\t  doc._id = id;\n\t  doc._rev = rev;\n\t  return doc;\n\t}\n\t\n\t// question mark groups IN queries, e.g. 3 -> '(?,?,?)'\n\tfunction qMarks(num) {\n\t  var s = '(';\n\t  while (num--) {\n\t    s += '?';\n\t    if (num) {\n\t      s += ',';\n\t    }\n\t  }\n\t  return s + ')';\n\t}\n\t\n\tfunction select(selector, table, joiner, where, orderBy) {\n\t  return 'SELECT ' + selector + ' FROM ' +\n\t    (typeof table === 'string' ? table : table.join(' JOIN ')) +\n\t    (joiner ? (' ON ' + joiner) : '') +\n\t    (where ? (' WHERE ' +\n\t    (typeof where === 'string' ? where : where.join(' AND '))) : '') +\n\t    (orderBy ? (' ORDER BY ' + orderBy) : '');\n\t}\n\t\n\tfunction compactRevs$1(revs, docId, tx) {\n\t\n\t  if (!revs.length) {\n\t    return;\n\t  }\n\t\n\t  var numDone = 0;\n\t  var seqs = [];\n\t\n\t  function checkDone() {\n\t    if (++numDone === revs.length) { // done\n\t      deleteOrphans();\n\t    }\n\t  }\n\t\n\t  function deleteOrphans() {\n\t    // find orphaned attachment digests\n\t\n\t    if (!seqs.length) {\n\t      return;\n\t    }\n\t\n\t    var sql = 'SELECT DISTINCT digest AS digest FROM ' +\n\t      ATTACH_AND_SEQ_STORE$1 + ' WHERE seq IN ' + qMarks(seqs.length);\n\t\n\t    tx.executeSql(sql, seqs, function (tx, res) {\n\t\n\t      var digestsToCheck = [];\n\t      for (var i = 0; i < res.rows.length; i++) {\n\t        digestsToCheck.push(res.rows.item(i).digest);\n\t      }\n\t      if (!digestsToCheck.length) {\n\t        return;\n\t      }\n\t\n\t      var sql = 'DELETE FROM ' + ATTACH_AND_SEQ_STORE$1 +\n\t        ' WHERE seq IN (' +\n\t        seqs.map(function () { return '?'; }).join(',') +\n\t        ')';\n\t      tx.executeSql(sql, seqs, function (tx) {\n\t\n\t        var sql = 'SELECT digest FROM ' + ATTACH_AND_SEQ_STORE$1 +\n\t          ' WHERE digest IN (' +\n\t          digestsToCheck.map(function () { return '?'; }).join(',') +\n\t          ')';\n\t        tx.executeSql(sql, digestsToCheck, function (tx, res) {\n\t          var nonOrphanedDigests = new pouchdbCollections.Set();\n\t          for (var i = 0; i < res.rows.length; i++) {\n\t            nonOrphanedDigests.add(res.rows.item(i).digest);\n\t          }\n\t          digestsToCheck.forEach(function (digest) {\n\t            if (nonOrphanedDigests.has(digest)) {\n\t              return;\n\t            }\n\t            tx.executeSql(\n\t              'DELETE FROM ' + ATTACH_AND_SEQ_STORE$1 + ' WHERE digest=?',\n\t              [digest]);\n\t            tx.executeSql(\n\t              'DELETE FROM ' + ATTACH_STORE$1 + ' WHERE digest=?', [digest]);\n\t          });\n\t        });\n\t      });\n\t    });\n\t  }\n\t\n\t  // update by-seq and attach stores in parallel\n\t  revs.forEach(function (rev) {\n\t    var sql = 'SELECT seq FROM ' + BY_SEQ_STORE$1 +\n\t      ' WHERE doc_id=? AND rev=?';\n\t\n\t    tx.executeSql(sql, [docId, rev], function (tx, res) {\n\t      if (!res.rows.length) { // already deleted\n\t        return checkDone();\n\t      }\n\t      var seq = res.rows.item(0).seq;\n\t      seqs.push(seq);\n\t\n\t      tx.executeSql(\n\t        'DELETE FROM ' + BY_SEQ_STORE$1 + ' WHERE seq=?', [seq], checkDone);\n\t    });\n\t  });\n\t}\n\t\n\tfunction websqlError(callback) {\n\t  return function (event) {\n\t    console.error('WebSQL threw an error', event);\n\t    // event may actually be a SQLError object, so report is as such\n\t    var errorNameMatch = event && event.constructor.toString()\n\t        .match(/function ([^\\(]+)/);\n\t    var errorName = (errorNameMatch && errorNameMatch[1]) || event.type;\n\t    var errorReason = event.target || event.message;\n\t    callback(createError(WSQ_ERROR, errorReason, errorName));\n\t  };\n\t}\n\t\n\tfunction getSize(opts) {\n\t  if ('size' in opts) {\n\t    // triggers immediate popup in iOS, fixes #2347\n\t    // e.g. 5000001 asks for 5 MB, 10000001 asks for 10 MB,\n\t    return opts.size * 1000000;\n\t  }\n\t  // In iOS, doesn't matter as long as it's <= 5000000.\n\t  // Except that if you request too much, our tests fail\n\t  // because of the native \"do you accept?\" popup.\n\t  // In Android <=4.3, this value is actually used as an\n\t  // honest-to-god ceiling for data, so we need to\n\t  // set it to a decently high number.\n\t  var isAndroid = typeof navigator !== 'undefined' &&\n\t    /Android/.test(navigator.userAgent);\n\t  return isAndroid ? 5000000 : 1; // in PhantomJS, if you use 0 it will crash\n\t}\n\t\n\tfunction openDBSafely(openDBFunction, opts) {\n\t  try {\n\t    return {\n\t      db: openDBFunction(opts)\n\t    };\n\t  } catch (err) {\n\t    return {\n\t      error: err\n\t    };\n\t  }\n\t}\n\t\n\tvar cachedDatabases = new pouchdbCollections.Map();\n\t\n\tfunction openDB(opts) {\n\t  var cachedResult = cachedDatabases.get(opts.name);\n\t  if (!cachedResult) {\n\t    var openDBFun = createOpenDBFunction();\n\t    cachedResult = openDBSafely(openDBFun, opts);\n\t    cachedDatabases.set(opts.name, cachedResult);\n\t    if (cachedResult.db) {\n\t      cachedResult.db._sqlitePlugin = typeof sqlitePlugin !== 'undefined';\n\t    }\n\t  }\n\t  return cachedResult;\n\t}\n\t\n\tfunction websqlBulkDocs(dbOpts, req, opts, api, db, websqlChanges, callback) {\n\t  var newEdits = opts.new_edits;\n\t  var userDocs = req.docs;\n\t\n\t  // Parse the docs, give them a sequence number for the result\n\t  var docInfos = userDocs.map(function (doc) {\n\t    if (doc._id && isLocalId(doc._id)) {\n\t      return doc;\n\t    }\n\t    var newDoc = parseDoc(doc, newEdits);\n\t    return newDoc;\n\t  });\n\t\n\t  var docInfoErrors = docInfos.filter(function (docInfo) {\n\t    return docInfo.error;\n\t  });\n\t  if (docInfoErrors.length) {\n\t    return callback(docInfoErrors[0]);\n\t  }\n\t\n\t  var tx;\n\t  var results = new Array(docInfos.length);\n\t  var fetchedDocs = new pouchdbCollections.Map();\n\t\n\t  var preconditionErrored;\n\t  function complete() {\n\t    if (preconditionErrored) {\n\t      return callback(preconditionErrored);\n\t    }\n\t    websqlChanges.notify(api._name);\n\t    api._docCount = -1; // invalidate\n\t    callback(null, results);\n\t  }\n\t\n\t  function verifyAttachment(digest, callback) {\n\t    var sql = 'SELECT count(*) as cnt FROM ' + ATTACH_STORE$1 +\n\t      ' WHERE digest=?';\n\t    tx.executeSql(sql, [digest], function (tx, result) {\n\t      if (result.rows.item(0).cnt === 0) {\n\t        var err = createError(MISSING_STUB,\n\t          'unknown stub attachment with digest ' +\n\t          digest);\n\t        callback(err);\n\t      } else {\n\t        callback();\n\t      }\n\t    });\n\t  }\n\t\n\t  function verifyAttachments(finish) {\n\t    var digests = [];\n\t    docInfos.forEach(function (docInfo) {\n\t      if (docInfo.data && docInfo.data._attachments) {\n\t        Object.keys(docInfo.data._attachments).forEach(function (filename) {\n\t          var att = docInfo.data._attachments[filename];\n\t          if (att.stub) {\n\t            digests.push(att.digest);\n\t          }\n\t        });\n\t      }\n\t    });\n\t    if (!digests.length) {\n\t      return finish();\n\t    }\n\t    var numDone = 0;\n\t    var err;\n\t\n\t    function checkDone() {\n\t      if (++numDone === digests.length) {\n\t        finish(err);\n\t      }\n\t    }\n\t    digests.forEach(function (digest) {\n\t      verifyAttachment(digest, function (attErr) {\n\t        if (attErr && !err) {\n\t          err = attErr;\n\t        }\n\t        checkDone();\n\t      });\n\t    });\n\t  }\n\t\n\t  function writeDoc(docInfo, winningRev, winningRevIsDeleted, newRevIsDeleted,\n\t                    isUpdate, delta, resultsIdx, callback) {\n\t\n\t    function finish() {\n\t      var data = docInfo.data;\n\t      var deletedInt = newRevIsDeleted ? 1 : 0;\n\t\n\t      var id = data._id;\n\t      var rev = data._rev;\n\t      var json = stringifyDoc(data);\n\t      var sql = 'INSERT INTO ' + BY_SEQ_STORE$1 +\n\t        ' (doc_id, rev, json, deleted) VALUES (?, ?, ?, ?);';\n\t      var sqlArgs = [id, rev, json, deletedInt];\n\t\n\t      // map seqs to attachment digests, which\n\t      // we will need later during compaction\n\t      function insertAttachmentMappings(seq, callback) {\n\t        var attsAdded = 0;\n\t        var attsToAdd = Object.keys(data._attachments || {});\n\t\n\t        if (!attsToAdd.length) {\n\t          return callback();\n\t        }\n\t        function checkDone() {\n\t          if (++attsAdded === attsToAdd.length) {\n\t            callback();\n\t          }\n\t          return false; // ack handling a constraint error\n\t        }\n\t        function add(att) {\n\t          var sql = 'INSERT INTO ' + ATTACH_AND_SEQ_STORE$1 +\n\t            ' (digest, seq) VALUES (?,?)';\n\t          var sqlArgs = [data._attachments[att].digest, seq];\n\t          tx.executeSql(sql, sqlArgs, checkDone, checkDone);\n\t          // second callback is for a constaint error, which we ignore\n\t          // because this docid/rev has already been associated with\n\t          // the digest (e.g. when new_edits == false)\n\t        }\n\t        for (var i = 0; i < attsToAdd.length; i++) {\n\t          add(attsToAdd[i]); // do in parallel\n\t        }\n\t      }\n\t\n\t      tx.executeSql(sql, sqlArgs, function (tx, result) {\n\t        var seq = result.insertId;\n\t        insertAttachmentMappings(seq, function () {\n\t          dataWritten(tx, seq);\n\t        });\n\t      }, function () {\n\t        // constraint error, recover by updating instead (see #1638)\n\t        var fetchSql = select('seq', BY_SEQ_STORE$1, null,\n\t          'doc_id=? AND rev=?');\n\t        tx.executeSql(fetchSql, [id, rev], function (tx, res) {\n\t          var seq = res.rows.item(0).seq;\n\t          var sql = 'UPDATE ' + BY_SEQ_STORE$1 +\n\t            ' SET json=?, deleted=? WHERE doc_id=? AND rev=?;';\n\t          var sqlArgs = [json, deletedInt, id, rev];\n\t          tx.executeSql(sql, sqlArgs, function (tx) {\n\t            insertAttachmentMappings(seq, function () {\n\t              dataWritten(tx, seq);\n\t            });\n\t          });\n\t        });\n\t        return false; // ack that we've handled the error\n\t      });\n\t    }\n\t\n\t    function collectResults(attachmentErr) {\n\t      if (!err) {\n\t        if (attachmentErr) {\n\t          err = attachmentErr;\n\t          callback(err);\n\t        } else if (recv === attachments.length) {\n\t          finish();\n\t        }\n\t      }\n\t    }\n\t\n\t    var err = null;\n\t    var recv = 0;\n\t\n\t    docInfo.data._id = docInfo.metadata.id;\n\t    docInfo.data._rev = docInfo.metadata.rev;\n\t    var attachments = Object.keys(docInfo.data._attachments || {});\n\t\n\t\n\t    if (newRevIsDeleted) {\n\t      docInfo.data._deleted = true;\n\t    }\n\t\n\t    function attachmentSaved(err) {\n\t      recv++;\n\t      collectResults(err);\n\t    }\n\t\n\t    attachments.forEach(function (key) {\n\t      var att = docInfo.data._attachments[key];\n\t      if (!att.stub) {\n\t        var data = att.data;\n\t        delete att.data;\n\t        var digest = att.digest;\n\t        saveAttachment(digest, data, attachmentSaved);\n\t      } else {\n\t        recv++;\n\t        collectResults();\n\t      }\n\t    });\n\t\n\t    if (!attachments.length) {\n\t      finish();\n\t    }\n\t\n\t    function dataWritten(tx, seq) {\n\t      var id = docInfo.metadata.id;\n\t      if (isUpdate && api.auto_compaction) {\n\t        compactRevs$1(compactTree(docInfo.metadata), id, tx);\n\t      } else if (docInfo.stemmedRevs.length) {\n\t        compactRevs$1(docInfo.stemmedRevs, id, tx);\n\t      }\n\t\n\t      docInfo.metadata.seq = seq;\n\t      delete docInfo.metadata.rev;\n\t\n\t      var sql = isUpdate ?\n\t      'UPDATE ' + DOC_STORE$1 +\n\t      ' SET json=?, max_seq=?, winningseq=' +\n\t      '(SELECT seq FROM ' + BY_SEQ_STORE$1 +\n\t      ' WHERE doc_id=' + DOC_STORE$1 + '.id AND rev=?) WHERE id=?'\n\t        : 'INSERT INTO ' + DOC_STORE$1 +\n\t      ' (id, winningseq, max_seq, json) VALUES (?,?,?,?);';\n\t      var metadataStr = safeJsonStringify(docInfo.metadata);\n\t      var params = isUpdate ?\n\t        [metadataStr, seq, winningRev, id] :\n\t        [id, seq, seq, metadataStr];\n\t      tx.executeSql(sql, params, function () {\n\t        results[resultsIdx] = {\n\t          ok: true,\n\t          id: docInfo.metadata.id,\n\t          rev: winningRev\n\t        };\n\t        fetchedDocs.set(id, docInfo.metadata);\n\t        callback();\n\t      });\n\t    }\n\t  }\n\t\n\t  function websqlProcessDocs() {\n\t    processDocs(dbOpts.revs_limit, docInfos, api, fetchedDocs, tx,\n\t                results, writeDoc, opts);\n\t  }\n\t\n\t  function fetchExistingDocs(callback) {\n\t    if (!docInfos.length) {\n\t      return callback();\n\t    }\n\t\n\t    var numFetched = 0;\n\t\n\t    function checkDone() {\n\t      if (++numFetched === docInfos.length) {\n\t        callback();\n\t      }\n\t    }\n\t\n\t    docInfos.forEach(function (docInfo) {\n\t      if (docInfo._id && isLocalId(docInfo._id)) {\n\t        return checkDone(); // skip local docs\n\t      }\n\t      var id = docInfo.metadata.id;\n\t      tx.executeSql('SELECT json FROM ' + DOC_STORE$1 +\n\t      ' WHERE id = ?', [id], function (tx, result) {\n\t        if (result.rows.length) {\n\t          var metadata = safeJsonParse(result.rows.item(0).json);\n\t          fetchedDocs.set(id, metadata);\n\t        }\n\t        checkDone();\n\t      });\n\t    });\n\t  }\n\t\n\t  function saveAttachment(digest, data, callback) {\n\t    var sql = 'SELECT digest FROM ' + ATTACH_STORE$1 + ' WHERE digest=?';\n\t    tx.executeSql(sql, [digest], function (tx, result) {\n\t      if (result.rows.length) { // attachment already exists\n\t        return callback();\n\t      }\n\t      // we could just insert before selecting and catch the error,\n\t      // but my hunch is that it's cheaper not to serialize the blob\n\t      // from JS to C if we don't have to (TODO: confirm this)\n\t      sql = 'INSERT INTO ' + ATTACH_STORE$1 +\n\t      ' (digest, body, escaped) VALUES (?,?,1)';\n\t      tx.executeSql(sql, [digest, escapeBlob(data)], function () {\n\t        callback();\n\t      }, function () {\n\t        // ignore constaint errors, means it already exists\n\t        callback();\n\t        return false; // ack we handled the error\n\t      });\n\t    });\n\t  }\n\t\n\t  preprocessAttachments$1(docInfos, 'binary', function (err) {\n\t    if (err) {\n\t      return callback(err);\n\t    }\n\t    db.transaction(function (txn) {\n\t      tx = txn;\n\t      verifyAttachments(function (err) {\n\t        if (err) {\n\t          preconditionErrored = err;\n\t        } else {\n\t          fetchExistingDocs(websqlProcessDocs);\n\t        }\n\t      });\n\t    }, websqlError(callback), complete);\n\t  });\n\t}\n\t\n\tvar websqlChanges = new Changes$1();\n\t\n\tfunction fetchAttachmentsIfNecessary$1(doc, opts, api, txn, cb) {\n\t  var attachments = Object.keys(doc._attachments || {});\n\t  if (!attachments.length) {\n\t    return cb && cb();\n\t  }\n\t  var numDone = 0;\n\t\n\t  function checkDone() {\n\t    if (++numDone === attachments.length && cb) {\n\t      cb();\n\t    }\n\t  }\n\t\n\t  function fetchAttachment(doc, att) {\n\t    var attObj = doc._attachments[att];\n\t    var attOpts = {binary: opts.binary, ctx: txn};\n\t    api._getAttachment(attObj, attOpts, function (_, data) {\n\t      doc._attachments[att] = jsExtend.extend(\n\t        pick(attObj, ['digest', 'content_type']),\n\t        { data: data }\n\t      );\n\t      checkDone();\n\t    });\n\t  }\n\t\n\t  attachments.forEach(function (att) {\n\t    if (opts.attachments && opts.include_docs) {\n\t      fetchAttachment(doc, att);\n\t    } else {\n\t      doc._attachments[att].stub = true;\n\t      checkDone();\n\t    }\n\t  });\n\t}\n\t\n\tvar POUCH_VERSION = 1;\n\t\n\t// these indexes cover the ground for most allDocs queries\n\tvar BY_SEQ_STORE_DELETED_INDEX_SQL =\n\t  'CREATE INDEX IF NOT EXISTS \\'by-seq-deleted-idx\\' ON ' +\n\t  BY_SEQ_STORE$1 + ' (seq, deleted)';\n\tvar BY_SEQ_STORE_DOC_ID_REV_INDEX_SQL =\n\t  'CREATE UNIQUE INDEX IF NOT EXISTS \\'by-seq-doc-id-rev\\' ON ' +\n\t    BY_SEQ_STORE$1 + ' (doc_id, rev)';\n\tvar DOC_STORE_WINNINGSEQ_INDEX_SQL =\n\t  'CREATE INDEX IF NOT EXISTS \\'doc-winningseq-idx\\' ON ' +\n\t  DOC_STORE$1 + ' (winningseq)';\n\tvar ATTACH_AND_SEQ_STORE_SEQ_INDEX_SQL =\n\t  'CREATE INDEX IF NOT EXISTS \\'attach-seq-seq-idx\\' ON ' +\n\t    ATTACH_AND_SEQ_STORE$1 + ' (seq)';\n\tvar ATTACH_AND_SEQ_STORE_ATTACH_INDEX_SQL =\n\t  'CREATE UNIQUE INDEX IF NOT EXISTS \\'attach-seq-digest-idx\\' ON ' +\n\t    ATTACH_AND_SEQ_STORE$1 + ' (digest, seq)';\n\t\n\tvar DOC_STORE_AND_BY_SEQ_JOINER = BY_SEQ_STORE$1 +\n\t  '.seq = ' + DOC_STORE$1 + '.winningseq';\n\t\n\tvar SELECT_DOCS = BY_SEQ_STORE$1 + '.seq AS seq, ' +\n\t  BY_SEQ_STORE$1 + '.deleted AS deleted, ' +\n\t  BY_SEQ_STORE$1 + '.json AS data, ' +\n\t  BY_SEQ_STORE$1 + '.rev AS rev, ' +\n\t  DOC_STORE$1 + '.json AS metadata';\n\t\n\tfunction WebSqlPouch(opts, callback) {\n\t  var api = this;\n\t  var instanceId = null;\n\t  var size = getSize(opts);\n\t  var idRequests = [];\n\t  var encoding;\n\t\n\t  api._docCount = -1; // cache sqlite count(*) for performance\n\t  api._name = opts.name;\n\t\n\t  var openDBResult = openDB({\n\t    name: api._name,\n\t    version: POUCH_VERSION,\n\t    description: api._name,\n\t    size: size,\n\t    location: opts.location,\n\t    createFromLocation: opts.createFromLocation,\n\t    androidDatabaseImplementation: opts.androidDatabaseImplementation\n\t  });\n\t  if (openDBResult.error) {\n\t    return websqlError(callback)(openDBResult.error);\n\t  }\n\t  var db = openDBResult.db;\n\t  if (typeof db.readTransaction !== 'function') {\n\t    // doesn't exist in sqlite plugin\n\t    db.readTransaction = db.transaction;\n\t  }\n\t\n\t  function dbCreated() {\n\t    // note the db name in case the browser upgrades to idb\n\t    if (hasLocalStorage()) {\n\t      window.localStorage['_pouch__websqldb_' + api._name] = true;\n\t    }\n\t    callback(null, api);\n\t  }\n\t\n\t  // In this migration, we added the 'deleted' and 'local' columns to the\n\t  // by-seq and doc store tables.\n\t  // To preserve existing user data, we re-process all the existing JSON\n\t  // and add these values.\n\t  // Called migration2 because it corresponds to adapter version (db_version) #2\n\t  function runMigration2(tx, callback) {\n\t    // index used for the join in the allDocs query\n\t    tx.executeSql(DOC_STORE_WINNINGSEQ_INDEX_SQL);\n\t\n\t    tx.executeSql('ALTER TABLE ' + BY_SEQ_STORE$1 +\n\t      ' ADD COLUMN deleted TINYINT(1) DEFAULT 0', [], function () {\n\t      tx.executeSql(BY_SEQ_STORE_DELETED_INDEX_SQL);\n\t      tx.executeSql('ALTER TABLE ' + DOC_STORE$1 +\n\t        ' ADD COLUMN local TINYINT(1) DEFAULT 0', [], function () {\n\t        tx.executeSql('CREATE INDEX IF NOT EXISTS \\'doc-store-local-idx\\' ON ' +\n\t          DOC_STORE$1 + ' (local, id)');\n\t\n\t        var sql = 'SELECT ' + DOC_STORE$1 + '.winningseq AS seq, ' + DOC_STORE$1 +\n\t          '.json AS metadata FROM ' + BY_SEQ_STORE$1 + ' JOIN ' + DOC_STORE$1 +\n\t          ' ON ' + BY_SEQ_STORE$1 + '.seq = ' + DOC_STORE$1 + '.winningseq';\n\t\n\t        tx.executeSql(sql, [], function (tx, result) {\n\t\n\t          var deleted = [];\n\t          var local = [];\n\t\n\t          for (var i = 0; i < result.rows.length; i++) {\n\t            var item = result.rows.item(i);\n\t            var seq = item.seq;\n\t            var metadata = JSON.parse(item.metadata);\n\t            if (isDeleted(metadata)) {\n\t              deleted.push(seq);\n\t            }\n\t            if (isLocalId(metadata.id)) {\n\t              local.push(metadata.id);\n\t            }\n\t          }\n\t          tx.executeSql('UPDATE ' + DOC_STORE$1 + 'SET local = 1 WHERE id IN ' +\n\t            qMarks(local.length), local, function () {\n\t            tx.executeSql('UPDATE ' + BY_SEQ_STORE$1 +\n\t              ' SET deleted = 1 WHERE seq IN ' +\n\t              qMarks(deleted.length), deleted, callback);\n\t          });\n\t        });\n\t      });\n\t    });\n\t  }\n\t\n\t  // in this migration, we make all the local docs unversioned\n\t  function runMigration3(tx, callback) {\n\t    var local = 'CREATE TABLE IF NOT EXISTS ' + LOCAL_STORE$1 +\n\t      ' (id UNIQUE, rev, json)';\n\t    tx.executeSql(local, [], function () {\n\t      var sql = 'SELECT ' + DOC_STORE$1 + '.id AS id, ' +\n\t        BY_SEQ_STORE$1 + '.json AS data ' +\n\t        'FROM ' + BY_SEQ_STORE$1 + ' JOIN ' +\n\t        DOC_STORE$1 + ' ON ' + BY_SEQ_STORE$1 + '.seq = ' +\n\t        DOC_STORE$1 + '.winningseq WHERE local = 1';\n\t      tx.executeSql(sql, [], function (tx, res) {\n\t        var rows = [];\n\t        for (var i = 0; i < res.rows.length; i++) {\n\t          rows.push(res.rows.item(i));\n\t        }\n\t        function doNext() {\n\t          if (!rows.length) {\n\t            return callback(tx);\n\t          }\n\t          var row = rows.shift();\n\t          var rev = JSON.parse(row.data)._rev;\n\t          tx.executeSql('INSERT INTO ' + LOCAL_STORE$1 +\n\t              ' (id, rev, json) VALUES (?,?,?)',\n\t              [row.id, rev, row.data], function (tx) {\n\t            tx.executeSql('DELETE FROM ' + DOC_STORE$1 + ' WHERE id=?',\n\t                [row.id], function (tx) {\n\t              tx.executeSql('DELETE FROM ' + BY_SEQ_STORE$1 + ' WHERE seq=?',\n\t                  [row.seq], function () {\n\t                doNext();\n\t              });\n\t            });\n\t          });\n\t        }\n\t        doNext();\n\t      });\n\t    });\n\t  }\n\t\n\t  // in this migration, we remove doc_id_rev and just use rev\n\t  function runMigration4(tx, callback) {\n\t\n\t    function updateRows(rows) {\n\t      function doNext() {\n\t        if (!rows.length) {\n\t          return callback(tx);\n\t        }\n\t        var row = rows.shift();\n\t        var doc_id_rev = parseHexString(row.hex, encoding);\n\t        var idx = doc_id_rev.lastIndexOf('::');\n\t        var doc_id = doc_id_rev.substring(0, idx);\n\t        var rev = doc_id_rev.substring(idx + 2);\n\t        var sql = 'UPDATE ' + BY_SEQ_STORE$1 +\n\t          ' SET doc_id=?, rev=? WHERE doc_id_rev=?';\n\t        tx.executeSql(sql, [doc_id, rev, doc_id_rev], function () {\n\t          doNext();\n\t        });\n\t      }\n\t      doNext();\n\t    }\n\t\n\t    var sql = 'ALTER TABLE ' + BY_SEQ_STORE$1 + ' ADD COLUMN doc_id';\n\t    tx.executeSql(sql, [], function (tx) {\n\t      var sql = 'ALTER TABLE ' + BY_SEQ_STORE$1 + ' ADD COLUMN rev';\n\t      tx.executeSql(sql, [], function (tx) {\n\t        tx.executeSql(BY_SEQ_STORE_DOC_ID_REV_INDEX_SQL, [], function (tx) {\n\t          var sql = 'SELECT hex(doc_id_rev) as hex FROM ' + BY_SEQ_STORE$1;\n\t          tx.executeSql(sql, [], function (tx, res) {\n\t            var rows = [];\n\t            for (var i = 0; i < res.rows.length; i++) {\n\t              rows.push(res.rows.item(i));\n\t            }\n\t            updateRows(rows);\n\t          });\n\t        });\n\t      });\n\t    });\n\t  }\n\t\n\t  // in this migration, we add the attach_and_seq table\n\t  // for issue #2818\n\t  function runMigration5(tx, callback) {\n\t\n\t    function migrateAttsAndSeqs(tx) {\n\t      // need to actually populate the table. this is the expensive part,\n\t      // so as an optimization, check first that this database even\n\t      // contains attachments\n\t      var sql = 'SELECT COUNT(*) AS cnt FROM ' + ATTACH_STORE$1;\n\t      tx.executeSql(sql, [], function (tx, res) {\n\t        var count = res.rows.item(0).cnt;\n\t        if (!count) {\n\t          return callback(tx);\n\t        }\n\t\n\t        var offset = 0;\n\t        var pageSize = 10;\n\t        function nextPage() {\n\t          var sql = select(\n\t            SELECT_DOCS + ', ' + DOC_STORE$1 + '.id AS id',\n\t            [DOC_STORE$1, BY_SEQ_STORE$1],\n\t            DOC_STORE_AND_BY_SEQ_JOINER,\n\t            null,\n\t            DOC_STORE$1 + '.id '\n\t          );\n\t          sql += ' LIMIT ' + pageSize + ' OFFSET ' + offset;\n\t          offset += pageSize;\n\t          tx.executeSql(sql, [], function (tx, res) {\n\t            if (!res.rows.length) {\n\t              return callback(tx);\n\t            }\n\t            var digestSeqs = {};\n\t            function addDigestSeq(digest, seq) {\n\t              // uniq digest/seq pairs, just in case there are dups\n\t              var seqs = digestSeqs[digest] = (digestSeqs[digest] || []);\n\t              if (seqs.indexOf(seq) === -1) {\n\t                seqs.push(seq);\n\t              }\n\t            }\n\t            for (var i = 0; i < res.rows.length; i++) {\n\t              var row = res.rows.item(i);\n\t              var doc = unstringifyDoc(row.data, row.id, row.rev);\n\t              var atts = Object.keys(doc._attachments || {});\n\t              for (var j = 0; j < atts.length; j++) {\n\t                var att = doc._attachments[atts[j]];\n\t                addDigestSeq(att.digest, row.seq);\n\t              }\n\t            }\n\t            var digestSeqPairs = [];\n\t            Object.keys(digestSeqs).forEach(function (digest) {\n\t              var seqs = digestSeqs[digest];\n\t              seqs.forEach(function (seq) {\n\t                digestSeqPairs.push([digest, seq]);\n\t              });\n\t            });\n\t            if (!digestSeqPairs.length) {\n\t              return nextPage();\n\t            }\n\t            var numDone = 0;\n\t            digestSeqPairs.forEach(function (pair) {\n\t              var sql = 'INSERT INTO ' + ATTACH_AND_SEQ_STORE$1 +\n\t                ' (digest, seq) VALUES (?,?)';\n\t              tx.executeSql(sql, pair, function () {\n\t                if (++numDone === digestSeqPairs.length) {\n\t                  nextPage();\n\t                }\n\t              });\n\t            });\n\t          });\n\t        }\n\t        nextPage();\n\t      });\n\t    }\n\t\n\t    var attachAndRev = 'CREATE TABLE IF NOT EXISTS ' +\n\t      ATTACH_AND_SEQ_STORE$1 + ' (digest, seq INTEGER)';\n\t    tx.executeSql(attachAndRev, [], function (tx) {\n\t      tx.executeSql(\n\t        ATTACH_AND_SEQ_STORE_ATTACH_INDEX_SQL, [], function (tx) {\n\t          tx.executeSql(\n\t            ATTACH_AND_SEQ_STORE_SEQ_INDEX_SQL, [],\n\t            migrateAttsAndSeqs);\n\t        });\n\t    });\n\t  }\n\t\n\t  // in this migration, we use escapeBlob() and unescapeBlob()\n\t  // instead of reading out the binary as HEX, which is slow\n\t  function runMigration6(tx, callback) {\n\t    var sql = 'ALTER TABLE ' + ATTACH_STORE$1 +\n\t      ' ADD COLUMN escaped TINYINT(1) DEFAULT 0';\n\t    tx.executeSql(sql, [], callback);\n\t  }\n\t\n\t  // issue #3136, in this migration we need a \"latest seq\" as well\n\t  // as the \"winning seq\" in the doc store\n\t  function runMigration7(tx, callback) {\n\t    var sql = 'ALTER TABLE ' + DOC_STORE$1 +\n\t      ' ADD COLUMN max_seq INTEGER';\n\t    tx.executeSql(sql, [], function (tx) {\n\t      var sql = 'UPDATE ' + DOC_STORE$1 + ' SET max_seq=(SELECT MAX(seq) FROM ' +\n\t        BY_SEQ_STORE$1 + ' WHERE doc_id=id)';\n\t      tx.executeSql(sql, [], function (tx) {\n\t        // add unique index after filling, else we'll get a constraint\n\t        // error when we do the ALTER TABLE\n\t        var sql =\n\t          'CREATE UNIQUE INDEX IF NOT EXISTS \\'doc-max-seq-idx\\' ON ' +\n\t          DOC_STORE$1 + ' (max_seq)';\n\t        tx.executeSql(sql, [], callback);\n\t      });\n\t    });\n\t  }\n\t\n\t  function checkEncoding(tx, cb) {\n\t    // UTF-8 on chrome/android, UTF-16 on safari < 7.1\n\t    tx.executeSql('SELECT HEX(\"a\") AS hex', [], function (tx, res) {\n\t        var hex = res.rows.item(0).hex;\n\t        encoding = hex.length === 2 ? 'UTF-8' : 'UTF-16';\n\t        cb();\n\t      }\n\t    );\n\t  }\n\t\n\t  function onGetInstanceId() {\n\t    while (idRequests.length > 0) {\n\t      var idCallback = idRequests.pop();\n\t      idCallback(null, instanceId);\n\t    }\n\t  }\n\t\n\t  function onGetVersion(tx, dbVersion) {\n\t    if (dbVersion === 0) {\n\t      // initial schema\n\t\n\t      var meta = 'CREATE TABLE IF NOT EXISTS ' + META_STORE$1 +\n\t        ' (dbid, db_version INTEGER)';\n\t      var attach = 'CREATE TABLE IF NOT EXISTS ' + ATTACH_STORE$1 +\n\t        ' (digest UNIQUE, escaped TINYINT(1), body BLOB)';\n\t      var attachAndRev = 'CREATE TABLE IF NOT EXISTS ' +\n\t        ATTACH_AND_SEQ_STORE$1 + ' (digest, seq INTEGER)';\n\t      // TODO: migrate winningseq to INTEGER\n\t      var doc = 'CREATE TABLE IF NOT EXISTS ' + DOC_STORE$1 +\n\t        ' (id unique, json, winningseq, max_seq INTEGER UNIQUE)';\n\t      var seq = 'CREATE TABLE IF NOT EXISTS ' + BY_SEQ_STORE$1 +\n\t        ' (seq INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT, ' +\n\t        'json, deleted TINYINT(1), doc_id, rev)';\n\t      var local = 'CREATE TABLE IF NOT EXISTS ' + LOCAL_STORE$1 +\n\t        ' (id UNIQUE, rev, json)';\n\t\n\t      // creates\n\t      tx.executeSql(attach);\n\t      tx.executeSql(local);\n\t      tx.executeSql(attachAndRev, [], function () {\n\t        tx.executeSql(ATTACH_AND_SEQ_STORE_SEQ_INDEX_SQL);\n\t        tx.executeSql(ATTACH_AND_SEQ_STORE_ATTACH_INDEX_SQL);\n\t      });\n\t      tx.executeSql(doc, [], function () {\n\t        tx.executeSql(DOC_STORE_WINNINGSEQ_INDEX_SQL);\n\t        tx.executeSql(seq, [], function () {\n\t          tx.executeSql(BY_SEQ_STORE_DELETED_INDEX_SQL);\n\t          tx.executeSql(BY_SEQ_STORE_DOC_ID_REV_INDEX_SQL);\n\t          tx.executeSql(meta, [], function () {\n\t            // mark the db version, and new dbid\n\t            var initSeq = 'INSERT INTO ' + META_STORE$1 +\n\t              ' (db_version, dbid) VALUES (?,?)';\n\t            instanceId = uuid();\n\t            var initSeqArgs = [ADAPTER_VERSION$1, instanceId];\n\t            tx.executeSql(initSeq, initSeqArgs, function () {\n\t              onGetInstanceId();\n\t            });\n\t          });\n\t        });\n\t      });\n\t    } else { // version > 0\n\t\n\t      var setupDone = function () {\n\t        var migrated = dbVersion < ADAPTER_VERSION$1;\n\t        if (migrated) {\n\t          // update the db version within this transaction\n\t          tx.executeSql('UPDATE ' + META_STORE$1 + ' SET db_version = ' +\n\t            ADAPTER_VERSION$1);\n\t        }\n\t        // notify db.id() callers\n\t        var sql = 'SELECT dbid FROM ' + META_STORE$1;\n\t        tx.executeSql(sql, [], function (tx, result) {\n\t          instanceId = result.rows.item(0).dbid;\n\t          onGetInstanceId();\n\t        });\n\t      };\n\t\n\t      // would love to use promises here, but then websql\n\t      // ends the transaction early\n\t      var tasks = [\n\t        runMigration2,\n\t        runMigration3,\n\t        runMigration4,\n\t        runMigration5,\n\t        runMigration6,\n\t        runMigration7,\n\t        setupDone\n\t      ];\n\t\n\t      // run each migration sequentially\n\t      var i = dbVersion;\n\t      var nextMigration = function (tx) {\n\t        tasks[i - 1](tx, nextMigration);\n\t        i++;\n\t      };\n\t      nextMigration(tx);\n\t    }\n\t  }\n\t\n\t  function setup() {\n\t    db.transaction(function (tx) {\n\t      // first check the encoding\n\t      checkEncoding(tx, function () {\n\t        // then get the version\n\t        fetchVersion(tx);\n\t      });\n\t    }, websqlError(callback), dbCreated);\n\t  }\n\t\n\t  function fetchVersion(tx) {\n\t    var sql = 'SELECT sql FROM sqlite_master WHERE tbl_name = ' + META_STORE$1;\n\t    tx.executeSql(sql, [], function (tx, result) {\n\t      if (!result.rows.length) {\n\t        // database hasn't even been created yet (version 0)\n\t        onGetVersion(tx, 0);\n\t      } else if (!/db_version/.test(result.rows.item(0).sql)) {\n\t        // table was created, but without the new db_version column,\n\t        // so add it.\n\t        tx.executeSql('ALTER TABLE ' + META_STORE$1 +\n\t          ' ADD COLUMN db_version INTEGER', [], function () {\n\t          // before version 2, this column didn't even exist\n\t          onGetVersion(tx, 1);\n\t        });\n\t      } else { // column exists, we can safely get it\n\t        tx.executeSql('SELECT db_version FROM ' + META_STORE$1,\n\t          [], function (tx, result) {\n\t          var dbVersion = result.rows.item(0).db_version;\n\t          onGetVersion(tx, dbVersion);\n\t        });\n\t      }\n\t    });\n\t  }\n\t\n\t  setup();\n\t\n\t  api.type = function () {\n\t    return 'websql';\n\t  };\n\t\n\t  api._id = toPromise(function (callback) {\n\t    callback(null, instanceId);\n\t  });\n\t\n\t  api._info = function (callback) {\n\t    db.readTransaction(function (tx) {\n\t      countDocs(tx, function (docCount) {\n\t        var sql = 'SELECT MAX(seq) AS seq FROM ' + BY_SEQ_STORE$1;\n\t        tx.executeSql(sql, [], function (tx, res) {\n\t          var updateSeq = res.rows.item(0).seq || 0;\n\t          callback(null, {\n\t            doc_count: docCount,\n\t            update_seq: updateSeq,\n\t            // for debugging\n\t            sqlite_plugin: db._sqlitePlugin,\n\t            websql_encoding: encoding\n\t          });\n\t        });\n\t      });\n\t    }, websqlError(callback));\n\t  };\n\t\n\t  api._bulkDocs = function (req, reqOpts, callback) {\n\t    websqlBulkDocs(opts, req, reqOpts, api, db, websqlChanges, callback);\n\t  };\n\t\n\t  api._get = function (id, opts, callback) {\n\t    var doc;\n\t    var metadata;\n\t    var err;\n\t    var tx = opts.ctx;\n\t    if (!tx) {\n\t      return db.readTransaction(function (txn) {\n\t        api._get(id, jsExtend.extend({ctx: txn}, opts), callback);\n\t      });\n\t    }\n\t\n\t    function finish() {\n\t      callback(err, {doc: doc, metadata: metadata, ctx: tx});\n\t    }\n\t\n\t    var sql;\n\t    var sqlArgs;\n\t    if (opts.rev) {\n\t      sql = select(\n\t        SELECT_DOCS,\n\t        [DOC_STORE$1, BY_SEQ_STORE$1],\n\t        DOC_STORE$1 + '.id=' + BY_SEQ_STORE$1 + '.doc_id',\n\t        [BY_SEQ_STORE$1 + '.doc_id=?', BY_SEQ_STORE$1 + '.rev=?']);\n\t      sqlArgs = [id, opts.rev];\n\t    } else {\n\t      sql = select(\n\t        SELECT_DOCS,\n\t        [DOC_STORE$1, BY_SEQ_STORE$1],\n\t        DOC_STORE_AND_BY_SEQ_JOINER,\n\t        DOC_STORE$1 + '.id=?');\n\t      sqlArgs = [id];\n\t    }\n\t    tx.executeSql(sql, sqlArgs, function (a, results) {\n\t      if (!results.rows.length) {\n\t        err = createError(MISSING_DOC, 'missing');\n\t        return finish();\n\t      }\n\t      var item = results.rows.item(0);\n\t      metadata = safeJsonParse(item.metadata);\n\t      if (item.deleted && !opts.rev) {\n\t        err = createError(MISSING_DOC, 'deleted');\n\t        return finish();\n\t      }\n\t      doc = unstringifyDoc(item.data, metadata.id, item.rev);\n\t      finish();\n\t    });\n\t  };\n\t\n\t  function countDocs(tx, callback) {\n\t\n\t    if (api._docCount !== -1) {\n\t      return callback(api._docCount);\n\t    }\n\t\n\t    // count the total rows\n\t    var sql = select(\n\t      'COUNT(' + DOC_STORE$1 + '.id) AS \\'num\\'',\n\t      [DOC_STORE$1, BY_SEQ_STORE$1],\n\t      DOC_STORE_AND_BY_SEQ_JOINER,\n\t      BY_SEQ_STORE$1 + '.deleted=0');\n\t\n\t    tx.executeSql(sql, [], function (tx, result) {\n\t      api._docCount = result.rows.item(0).num;\n\t      callback(api._docCount);\n\t    });\n\t  }\n\t\n\t  api._allDocs = function (opts, callback) {\n\t    var results = [];\n\t    var totalRows;\n\t\n\t    var start = 'startkey' in opts ? opts.startkey : false;\n\t    var end = 'endkey' in opts ? opts.endkey : false;\n\t    var key = 'key' in opts ? opts.key : false;\n\t    var descending = 'descending' in opts ? opts.descending : false;\n\t    var limit = 'limit' in opts ? opts.limit : -1;\n\t    var offset = 'skip' in opts ? opts.skip : 0;\n\t    var inclusiveEnd = opts.inclusive_end !== false;\n\t\n\t    var sqlArgs = [];\n\t    var criteria = [];\n\t\n\t    if (key !== false) {\n\t      criteria.push(DOC_STORE$1 + '.id = ?');\n\t      sqlArgs.push(key);\n\t    } else if (start !== false || end !== false) {\n\t      if (start !== false) {\n\t        criteria.push(DOC_STORE$1 + '.id ' + (descending ? '<=' : '>=') + ' ?');\n\t        sqlArgs.push(start);\n\t      }\n\t      if (end !== false) {\n\t        var comparator = descending ? '>' : '<';\n\t        if (inclusiveEnd) {\n\t          comparator += '=';\n\t        }\n\t        criteria.push(DOC_STORE$1 + '.id ' + comparator + ' ?');\n\t        sqlArgs.push(end);\n\t      }\n\t      if (key !== false) {\n\t        criteria.push(DOC_STORE$1 + '.id = ?');\n\t        sqlArgs.push(key);\n\t      }\n\t    }\n\t\n\t    if (opts.deleted !== 'ok') {\n\t      // report deleted if keys are specified\n\t      criteria.push(BY_SEQ_STORE$1 + '.deleted = 0');\n\t    }\n\t\n\t    db.readTransaction(function (tx) {\n\t\n\t      // first count up the total rows\n\t      countDocs(tx, function (count) {\n\t        totalRows = count;\n\t\n\t        if (limit === 0) {\n\t          return;\n\t        }\n\t\n\t        // then actually fetch the documents\n\t        var sql = select(\n\t          SELECT_DOCS,\n\t          [DOC_STORE$1, BY_SEQ_STORE$1],\n\t          DOC_STORE_AND_BY_SEQ_JOINER,\n\t          criteria,\n\t          DOC_STORE$1 + '.id ' + (descending ? 'DESC' : 'ASC')\n\t          );\n\t        sql += ' LIMIT ' + limit + ' OFFSET ' + offset;\n\t\n\t        tx.executeSql(sql, sqlArgs, function (tx, result) {\n\t          for (var i = 0, l = result.rows.length; i < l; i++) {\n\t            var item = result.rows.item(i);\n\t            var metadata = safeJsonParse(item.metadata);\n\t            var id = metadata.id;\n\t            var data = unstringifyDoc(item.data, id, item.rev);\n\t            var winningRev = data._rev;\n\t            var doc = {\n\t              id: id,\n\t              key: id,\n\t              value: {rev: winningRev}\n\t            };\n\t            if (opts.include_docs) {\n\t              doc.doc = data;\n\t              doc.doc._rev = winningRev;\n\t              if (opts.conflicts) {\n\t                doc.doc._conflicts = collectConflicts(metadata);\n\t              }\n\t              fetchAttachmentsIfNecessary$1(doc.doc, opts, api, tx);\n\t            }\n\t            if (item.deleted) {\n\t              if (opts.deleted === 'ok') {\n\t                doc.value.deleted = true;\n\t                doc.doc = null;\n\t              } else {\n\t                continue;\n\t              }\n\t            }\n\t            results.push(doc);\n\t          }\n\t        });\n\t      });\n\t    }, websqlError(callback), function () {\n\t      callback(null, {\n\t        total_rows: totalRows,\n\t        offset: opts.skip,\n\t        rows: results\n\t      });\n\t    });\n\t  };\n\t\n\t  api._changes = function (opts) {\n\t    opts = clone(opts);\n\t\n\t    if (opts.continuous) {\n\t      var id = api._name + ':' + uuid();\n\t      websqlChanges.addListener(api._name, id, api, opts);\n\t      websqlChanges.notify(api._name);\n\t      return {\n\t        cancel: function () {\n\t          websqlChanges.removeListener(api._name, id);\n\t        }\n\t      };\n\t    }\n\t\n\t    var descending = opts.descending;\n\t\n\t    // Ignore the `since` parameter when `descending` is true\n\t    opts.since = opts.since && !descending ? opts.since : 0;\n\t\n\t    var limit = 'limit' in opts ? opts.limit : -1;\n\t    if (limit === 0) {\n\t      limit = 1; // per CouchDB _changes spec\n\t    }\n\t\n\t    var returnDocs;\n\t    if ('return_docs' in opts) {\n\t      returnDocs = opts.return_docs;\n\t    } else if ('returnDocs' in opts) {\n\t      // TODO: Remove 'returnDocs' in favor of 'return_docs' in a future release\n\t      returnDocs = opts.returnDocs;\n\t    } else {\n\t      returnDocs = true;\n\t    }\n\t    var results = [];\n\t    var numResults = 0;\n\t\n\t    function fetchChanges() {\n\t\n\t      var selectStmt =\n\t        DOC_STORE$1 + '.json AS metadata, ' +\n\t        DOC_STORE$1 + '.max_seq AS maxSeq, ' +\n\t        BY_SEQ_STORE$1 + '.json AS winningDoc, ' +\n\t        BY_SEQ_STORE$1 + '.rev AS winningRev ';\n\t\n\t      var from = DOC_STORE$1 + ' JOIN ' + BY_SEQ_STORE$1;\n\t\n\t      var joiner = DOC_STORE$1 + '.id=' + BY_SEQ_STORE$1 + '.doc_id' +\n\t        ' AND ' + DOC_STORE$1 + '.winningseq=' + BY_SEQ_STORE$1 + '.seq';\n\t\n\t      var criteria = ['maxSeq > ?'];\n\t      var sqlArgs = [opts.since];\n\t\n\t      if (opts.doc_ids) {\n\t        criteria.push(DOC_STORE$1 + '.id IN ' + qMarks(opts.doc_ids.length));\n\t        sqlArgs = sqlArgs.concat(opts.doc_ids);\n\t      }\n\t\n\t      var orderBy = 'maxSeq ' + (descending ? 'DESC' : 'ASC');\n\t\n\t      var sql = select(selectStmt, from, joiner, criteria, orderBy);\n\t\n\t      var filter = filterChange(opts);\n\t      if (!opts.view && !opts.filter) {\n\t        // we can just limit in the query\n\t        sql += ' LIMIT ' + limit;\n\t      }\n\t\n\t      var lastSeq = opts.since || 0;\n\t      db.readTransaction(function (tx) {\n\t        tx.executeSql(sql, sqlArgs, function (tx, result) {\n\t          function reportChange(change) {\n\t            return function () {\n\t              opts.onChange(change);\n\t            };\n\t          }\n\t          for (var i = 0, l = result.rows.length; i < l; i++) {\n\t            var item = result.rows.item(i);\n\t            var metadata = safeJsonParse(item.metadata);\n\t            lastSeq = item.maxSeq;\n\t\n\t            var doc = unstringifyDoc(item.winningDoc, metadata.id,\n\t              item.winningRev);\n\t            var change = opts.processChange(doc, metadata, opts);\n\t            change.seq = item.maxSeq;\n\t\n\t            var filtered = filter(change);\n\t            if (typeof filtered === 'object') {\n\t              return opts.complete(filtered);\n\t            }\n\t\n\t            if (filtered) {\n\t              numResults++;\n\t              if (returnDocs) {\n\t                results.push(change);\n\t              }\n\t              // process the attachment immediately\n\t              // for the benefit of live listeners\n\t              if (opts.attachments && opts.include_docs) {\n\t                fetchAttachmentsIfNecessary$1(doc, opts, api, tx,\n\t                  reportChange(change));\n\t              } else {\n\t                reportChange(change)();\n\t              }\n\t            }\n\t            if (numResults === limit) {\n\t              break;\n\t            }\n\t          }\n\t        });\n\t      }, websqlError(opts.complete), function () {\n\t        if (!opts.continuous) {\n\t          opts.complete(null, {\n\t            results: results,\n\t            last_seq: lastSeq\n\t          });\n\t        }\n\t      });\n\t    }\n\t\n\t    fetchChanges();\n\t  };\n\t\n\t  api._close = function (callback) {\n\t    //WebSQL databases do not need to be closed\n\t    callback();\n\t  };\n\t\n\t  api._getAttachment = function (attachment, opts, callback) {\n\t    var res;\n\t    var tx = opts.ctx;\n\t    var digest = attachment.digest;\n\t    var type = attachment.content_type;\n\t    var sql = 'SELECT escaped, ' +\n\t      'CASE WHEN escaped = 1 THEN body ELSE HEX(body) END AS body FROM ' +\n\t      ATTACH_STORE$1 + ' WHERE digest=?';\n\t    tx.executeSql(sql, [digest], function (tx, result) {\n\t      // websql has a bug where \\u0000 causes early truncation in strings\n\t      // and blobs. to work around this, we used to use the hex() function,\n\t      // but that's not performant. after migration 6, we remove \\u0000\n\t      // and add it back in afterwards\n\t      var item = result.rows.item(0);\n\t      var data = item.escaped ? unescapeBlob(item.body) :\n\t        parseHexString(item.body, encoding);\n\t      if (opts.binary) {\n\t        res = binStringToBluffer(data, type);\n\t      } else {\n\t        res = btoa$1(data);\n\t      }\n\t      callback(null, res);\n\t    });\n\t  };\n\t\n\t  api._getRevisionTree = function (docId, callback) {\n\t    db.readTransaction(function (tx) {\n\t      var sql = 'SELECT json AS metadata FROM ' + DOC_STORE$1 + ' WHERE id = ?';\n\t      tx.executeSql(sql, [docId], function (tx, result) {\n\t        if (!result.rows.length) {\n\t          callback(createError(MISSING_DOC));\n\t        } else {\n\t          var data = safeJsonParse(result.rows.item(0).metadata);\n\t          callback(null, data.rev_tree);\n\t        }\n\t      });\n\t    });\n\t  };\n\t\n\t  api._doCompaction = function (docId, revs, callback) {\n\t    if (!revs.length) {\n\t      return callback();\n\t    }\n\t    db.transaction(function (tx) {\n\t\n\t      // update doc store\n\t      var sql = 'SELECT json AS metadata FROM ' + DOC_STORE$1 + ' WHERE id = ?';\n\t      tx.executeSql(sql, [docId], function (tx, result) {\n\t        var metadata = safeJsonParse(result.rows.item(0).metadata);\n\t        traverseRevTree(metadata.rev_tree, function (isLeaf, pos,\n\t                                                           revHash, ctx, opts) {\n\t          var rev = pos + '-' + revHash;\n\t          if (revs.indexOf(rev) !== -1) {\n\t            opts.status = 'missing';\n\t          }\n\t        });\n\t\n\t        var sql = 'UPDATE ' + DOC_STORE$1 + ' SET json = ? WHERE id = ?';\n\t        tx.executeSql(sql, [safeJsonStringify(metadata), docId]);\n\t      });\n\t\n\t      compactRevs$1(revs, docId, tx);\n\t    }, websqlError(callback), function () {\n\t      callback();\n\t    });\n\t  };\n\t\n\t  api._getLocal = function (id, callback) {\n\t    db.readTransaction(function (tx) {\n\t      var sql = 'SELECT json, rev FROM ' + LOCAL_STORE$1 + ' WHERE id=?';\n\t      tx.executeSql(sql, [id], function (tx, res) {\n\t        if (res.rows.length) {\n\t          var item = res.rows.item(0);\n\t          var doc = unstringifyDoc(item.json, id, item.rev);\n\t          callback(null, doc);\n\t        } else {\n\t          callback(createError(MISSING_DOC));\n\t        }\n\t      });\n\t    });\n\t  };\n\t\n\t  api._putLocal = function (doc, opts, callback) {\n\t    if (typeof opts === 'function') {\n\t      callback = opts;\n\t      opts = {};\n\t    }\n\t    delete doc._revisions; // ignore this, trust the rev\n\t    var oldRev = doc._rev;\n\t    var id = doc._id;\n\t    var newRev;\n\t    if (!oldRev) {\n\t      newRev = doc._rev = '0-1';\n\t    } else {\n\t      newRev = doc._rev = '0-' + (parseInt(oldRev.split('-')[1], 10) + 1);\n\t    }\n\t    var json = stringifyDoc(doc);\n\t\n\t    var ret;\n\t    function putLocal(tx) {\n\t      var sql;\n\t      var values;\n\t      if (oldRev) {\n\t        sql = 'UPDATE ' + LOCAL_STORE$1 + ' SET rev=?, json=? ' +\n\t          'WHERE id=? AND rev=?';\n\t        values = [newRev, json, id, oldRev];\n\t      } else {\n\t        sql = 'INSERT INTO ' + LOCAL_STORE$1 + ' (id, rev, json) VALUES (?,?,?)';\n\t        values = [id, newRev, json];\n\t      }\n\t      tx.executeSql(sql, values, function (tx, res) {\n\t        if (res.rowsAffected) {\n\t          ret = {ok: true, id: id, rev: newRev};\n\t          if (opts.ctx) { // return immediately\n\t            callback(null, ret);\n\t          }\n\t        } else {\n\t          callback(createError(REV_CONFLICT));\n\t        }\n\t      }, function () {\n\t        callback(createError(REV_CONFLICT));\n\t        return false; // ack that we handled the error\n\t      });\n\t    }\n\t\n\t    if (opts.ctx) {\n\t      putLocal(opts.ctx);\n\t    } else {\n\t      db.transaction(putLocal, websqlError(callback), function () {\n\t        if (ret) {\n\t          callback(null, ret);\n\t        }\n\t      });\n\t    }\n\t  };\n\t\n\t  api._removeLocal = function (doc, opts, callback) {\n\t    if (typeof opts === 'function') {\n\t      callback = opts;\n\t      opts = {};\n\t    }\n\t    var ret;\n\t\n\t    function removeLocal(tx) {\n\t      var sql = 'DELETE FROM ' + LOCAL_STORE$1 + ' WHERE id=? AND rev=?';\n\t      var params = [doc._id, doc._rev];\n\t      tx.executeSql(sql, params, function (tx, res) {\n\t        if (!res.rowsAffected) {\n\t          return callback(createError(MISSING_DOC));\n\t        }\n\t        ret = {ok: true, id: doc._id, rev: '0-0'};\n\t        if (opts.ctx) { // return immediately\n\t          callback(null, ret);\n\t        }\n\t      });\n\t    }\n\t\n\t    if (opts.ctx) {\n\t      removeLocal(opts.ctx);\n\t    } else {\n\t      db.transaction(removeLocal, websqlError(callback), function () {\n\t        if (ret) {\n\t          callback(null, ret);\n\t        }\n\t      });\n\t    }\n\t  };\n\t\n\t  api._destroy = function (opts, callback) {\n\t    websqlChanges.removeAllListeners(api._name);\n\t    db.transaction(function (tx) {\n\t      var stores = [DOC_STORE$1, BY_SEQ_STORE$1, ATTACH_STORE$1, META_STORE$1,\n\t        LOCAL_STORE$1, ATTACH_AND_SEQ_STORE$1];\n\t      stores.forEach(function (store) {\n\t        tx.executeSql('DROP TABLE IF EXISTS ' + store, []);\n\t      });\n\t    }, websqlError(callback), function () {\n\t      if (hasLocalStorage()) {\n\t        delete window.localStorage['_pouch__websqldb_' + api._name];\n\t        delete window.localStorage[api._name];\n\t      }\n\t      callback(null, {'ok': true});\n\t    });\n\t  };\n\t}\n\t\n\t// in the browser, use a prefix. in Node, don't bother having one\n\tWebSqlPouch.use_prefix = !!(typeof process === 'undefined' || process.browser);\n\t\n\tWebSqlPouch.valid = valid;\n\t\n\tvar adapters = {\n\t  idb: IdbPouch,\n\t  websql: WebSqlPouch\n\t};\n\t\n\tPouchDB.ajax = ajax;\n\tPouchDB.utils = utils;\n\tPouchDB.Errors = allErrors;\n\tPouchDB.replicate = replication.replicate;\n\tPouchDB.sync = sync;\n\tPouchDB.version = '5.3.1'; // will be automatically supplied by build.sh\n\tPouchDB.adapter('http', HttpPouch);\n\tPouchDB.adapter('https', HttpPouch);\n\t\n\tPouchDB.plugin(mapreduce);\n\t\n\tObject.keys(adapters).forEach(function (adapterName) {\n\t  PouchDB.adapter(adapterName, adapters[adapterName], true);\n\t});\n\t\n\tmodule.exports = PouchDB;\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(2), (function() { return this; }())))\n\n/***/ },\n/* 26 */\n/***/ function(module, exports) {\n\n\t// Generated by CoffeeScript 1.9.2\n\t(function() {\n\t  var hasProp = {}.hasOwnProperty,\n\t    slice = [].slice;\n\t\n\t  module.exports = function(source, scope) {\n\t    var key, keys, value, values;\n\t    keys = [];\n\t    values = [];\n\t    for (key in scope) {\n\t      if (!hasProp.call(scope, key)) continue;\n\t      value = scope[key];\n\t      if (key === 'this') {\n\t        continue;\n\t      }\n\t      keys.push(key);\n\t      values.push(value);\n\t    }\n\t    return Function.apply(null, slice.call(keys).concat([source])).apply(scope[\"this\"], values);\n\t  };\n\t\n\t}).call(this);\n\n\n/***/ },\n/* 27 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t(function (factory) {\n\t    if (true) {\n\t        // Node/CommonJS\n\t        module.exports = factory();\n\t    } else if (typeof define === 'function' && define.amd) {\n\t        // AMD\n\t        define(factory);\n\t    } else {\n\t        // Browser globals (with support for web workers)\n\t        var glob;\n\t\n\t        try {\n\t            glob = window;\n\t        } catch (e) {\n\t            glob = self;\n\t        }\n\t\n\t        glob.SparkMD5 = factory();\n\t    }\n\t}(function (undefined) {\n\t\n\t    'use strict';\n\t\n\t    /*\n\t     * Fastest md5 implementation around (JKM md5).\n\t     * Credits: Joseph Myers\n\t     *\n\t     * @see http://www.myersdaily.org/joseph/javascript/md5-text.html\n\t     * @see http://jsperf.com/md5-shootout/7\n\t     */\n\t\n\t    /* this function is much faster,\n\t      so if possible we use it. Some IEs\n\t      are the only ones I know of that\n\t      need the idiotic second function,\n\t      generated by an if clause.  */\n\t    var add32 = function (a, b) {\n\t        return (a + b) & 0xFFFFFFFF;\n\t    },\n\t        hex_chr = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'];\n\t\n\t\n\t    function cmn(q, a, b, x, s, t) {\n\t        a = add32(add32(a, q), add32(x, t));\n\t        return add32((a << s) | (a >>> (32 - s)), b);\n\t    }\n\t\n\t    function ff(a, b, c, d, x, s, t) {\n\t        return cmn((b & c) | ((~b) & d), a, b, x, s, t);\n\t    }\n\t\n\t    function gg(a, b, c, d, x, s, t) {\n\t        return cmn((b & d) | (c & (~d)), a, b, x, s, t);\n\t    }\n\t\n\t    function hh(a, b, c, d, x, s, t) {\n\t        return cmn(b ^ c ^ d, a, b, x, s, t);\n\t    }\n\t\n\t    function ii(a, b, c, d, x, s, t) {\n\t        return cmn(c ^ (b | (~d)), a, b, x, s, t);\n\t    }\n\t\n\t    function md5cycle(x, k) {\n\t        var a = x[0],\n\t            b = x[1],\n\t            c = x[2],\n\t            d = x[3];\n\t\n\t        a = ff(a, b, c, d, k[0], 7, -680876936);\n\t        d = ff(d, a, b, c, k[1], 12, -389564586);\n\t        c = ff(c, d, a, b, k[2], 17, 606105819);\n\t        b = ff(b, c, d, a, k[3], 22, -1044525330);\n\t        a = ff(a, b, c, d, k[4], 7, -176418897);\n\t        d = ff(d, a, b, c, k[5], 12, 1200080426);\n\t        c = ff(c, d, a, b, k[6], 17, -1473231341);\n\t        b = ff(b, c, d, a, k[7], 22, -45705983);\n\t        a = ff(a, b, c, d, k[8], 7, 1770035416);\n\t        d = ff(d, a, b, c, k[9], 12, -1958414417);\n\t        c = ff(c, d, a, b, k[10], 17, -42063);\n\t        b = ff(b, c, d, a, k[11], 22, -1990404162);\n\t        a = ff(a, b, c, d, k[12], 7, 1804603682);\n\t        d = ff(d, a, b, c, k[13], 12, -40341101);\n\t        c = ff(c, d, a, b, k[14], 17, -1502002290);\n\t        b = ff(b, c, d, a, k[15], 22, 1236535329);\n\t\n\t        a = gg(a, b, c, d, k[1], 5, -165796510);\n\t        d = gg(d, a, b, c, k[6], 9, -1069501632);\n\t        c = gg(c, d, a, b, k[11], 14, 643717713);\n\t        b = gg(b, c, d, a, k[0], 20, -373897302);\n\t        a = gg(a, b, c, d, k[5], 5, -701558691);\n\t        d = gg(d, a, b, c, k[10], 9, 38016083);\n\t        c = gg(c, d, a, b, k[15], 14, -660478335);\n\t        b = gg(b, c, d, a, k[4], 20, -405537848);\n\t        a = gg(a, b, c, d, k[9], 5, 568446438);\n\t        d = gg(d, a, b, c, k[14], 9, -1019803690);\n\t        c = gg(c, d, a, b, k[3], 14, -187363961);\n\t        b = gg(b, c, d, a, k[8], 20, 1163531501);\n\t        a = gg(a, b, c, d, k[13], 5, -1444681467);\n\t        d = gg(d, a, b, c, k[2], 9, -51403784);\n\t        c = gg(c, d, a, b, k[7], 14, 1735328473);\n\t        b = gg(b, c, d, a, k[12], 20, -1926607734);\n\t\n\t        a = hh(a, b, c, d, k[5], 4, -378558);\n\t        d = hh(d, a, b, c, k[8], 11, -2022574463);\n\t        c = hh(c, d, a, b, k[11], 16, 1839030562);\n\t        b = hh(b, c, d, a, k[14], 23, -35309556);\n\t        a = hh(a, b, c, d, k[1], 4, -1530992060);\n\t        d = hh(d, a, b, c, k[4], 11, 1272893353);\n\t        c = hh(c, d, a, b, k[7], 16, -155497632);\n\t        b = hh(b, c, d, a, k[10], 23, -1094730640);\n\t        a = hh(a, b, c, d, k[13], 4, 681279174);\n\t        d = hh(d, a, b, c, k[0], 11, -358537222);\n\t        c = hh(c, d, a, b, k[3], 16, -722521979);\n\t        b = hh(b, c, d, a, k[6], 23, 76029189);\n\t        a = hh(a, b, c, d, k[9], 4, -640364487);\n\t        d = hh(d, a, b, c, k[12], 11, -421815835);\n\t        c = hh(c, d, a, b, k[15], 16, 530742520);\n\t        b = hh(b, c, d, a, k[2], 23, -995338651);\n\t\n\t        a = ii(a, b, c, d, k[0], 6, -198630844);\n\t        d = ii(d, a, b, c, k[7], 10, 1126891415);\n\t        c = ii(c, d, a, b, k[14], 15, -1416354905);\n\t        b = ii(b, c, d, a, k[5], 21, -57434055);\n\t        a = ii(a, b, c, d, k[12], 6, 1700485571);\n\t        d = ii(d, a, b, c, k[3], 10, -1894986606);\n\t        c = ii(c, d, a, b, k[10], 15, -1051523);\n\t        b = ii(b, c, d, a, k[1], 21, -2054922799);\n\t        a = ii(a, b, c, d, k[8], 6, 1873313359);\n\t        d = ii(d, a, b, c, k[15], 10, -30611744);\n\t        c = ii(c, d, a, b, k[6], 15, -1560198380);\n\t        b = ii(b, c, d, a, k[13], 21, 1309151649);\n\t        a = ii(a, b, c, d, k[4], 6, -145523070);\n\t        d = ii(d, a, b, c, k[11], 10, -1120210379);\n\t        c = ii(c, d, a, b, k[2], 15, 718787259);\n\t        b = ii(b, c, d, a, k[9], 21, -343485551);\n\t\n\t        x[0] = add32(a, x[0]);\n\t        x[1] = add32(b, x[1]);\n\t        x[2] = add32(c, x[2]);\n\t        x[3] = add32(d, x[3]);\n\t    }\n\t\n\t    function md5blk(s) {\n\t        var md5blks = [],\n\t            i; /* Andy King said do it this way. */\n\t\n\t        for (i = 0; i < 64; i += 4) {\n\t            md5blks[i >> 2] = s.charCodeAt(i) + (s.charCodeAt(i + 1) << 8) + (s.charCodeAt(i + 2) << 16) + (s.charCodeAt(i + 3) << 24);\n\t        }\n\t        return md5blks;\n\t    }\n\t\n\t    function md5blk_array(a) {\n\t        var md5blks = [],\n\t            i; /* Andy King said do it this way. */\n\t\n\t        for (i = 0; i < 64; i += 4) {\n\t            md5blks[i >> 2] = a[i] + (a[i + 1] << 8) + (a[i + 2] << 16) + (a[i + 3] << 24);\n\t        }\n\t        return md5blks;\n\t    }\n\t\n\t    function md51(s) {\n\t        var n = s.length,\n\t            state = [1732584193, -271733879, -1732584194, 271733878],\n\t            i,\n\t            length,\n\t            tail,\n\t            tmp,\n\t            lo,\n\t            hi;\n\t\n\t        for (i = 64; i <= n; i += 64) {\n\t            md5cycle(state, md5blk(s.substring(i - 64, i)));\n\t        }\n\t        s = s.substring(i - 64);\n\t        length = s.length;\n\t        tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n\t        for (i = 0; i < length; i += 1) {\n\t            tail[i >> 2] |= s.charCodeAt(i) << ((i % 4) << 3);\n\t        }\n\t        tail[i >> 2] |= 0x80 << ((i % 4) << 3);\n\t        if (i > 55) {\n\t            md5cycle(state, tail);\n\t            for (i = 0; i < 16; i += 1) {\n\t                tail[i] = 0;\n\t            }\n\t        }\n\t\n\t        // Beware that the final length might not fit in 32 bits so we take care of that\n\t        tmp = n * 8;\n\t        tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);\n\t        lo = parseInt(tmp[2], 16);\n\t        hi = parseInt(tmp[1], 16) || 0;\n\t\n\t        tail[14] = lo;\n\t        tail[15] = hi;\n\t\n\t        md5cycle(state, tail);\n\t        return state;\n\t    }\n\t\n\t    function md51_array(a) {\n\t        var n = a.length,\n\t            state = [1732584193, -271733879, -1732584194, 271733878],\n\t            i,\n\t            length,\n\t            tail,\n\t            tmp,\n\t            lo,\n\t            hi;\n\t\n\t        for (i = 64; i <= n; i += 64) {\n\t            md5cycle(state, md5blk_array(a.subarray(i - 64, i)));\n\t        }\n\t\n\t        // Not sure if it is a bug, however IE10 will always produce a sub array of length 1\n\t        // containing the last element of the parent array if the sub array specified starts\n\t        // beyond the length of the parent array - weird.\n\t        // https://connect.microsoft.com/IE/feedback/details/771452/typed-array-subarray-issue\n\t        a = (i - 64) < n ? a.subarray(i - 64) : new Uint8Array(0);\n\t\n\t        length = a.length;\n\t        tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n\t        for (i = 0; i < length; i += 1) {\n\t            tail[i >> 2] |= a[i] << ((i % 4) << 3);\n\t        }\n\t\n\t        tail[i >> 2] |= 0x80 << ((i % 4) << 3);\n\t        if (i > 55) {\n\t            md5cycle(state, tail);\n\t            for (i = 0; i < 16; i += 1) {\n\t                tail[i] = 0;\n\t            }\n\t        }\n\t\n\t        // Beware that the final length might not fit in 32 bits so we take care of that\n\t        tmp = n * 8;\n\t        tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);\n\t        lo = parseInt(tmp[2], 16);\n\t        hi = parseInt(tmp[1], 16) || 0;\n\t\n\t        tail[14] = lo;\n\t        tail[15] = hi;\n\t\n\t        md5cycle(state, tail);\n\t\n\t        return state;\n\t    }\n\t\n\t    function rhex(n) {\n\t        var s = '',\n\t            j;\n\t        for (j = 0; j < 4; j += 1) {\n\t            s += hex_chr[(n >> (j * 8 + 4)) & 0x0F] + hex_chr[(n >> (j * 8)) & 0x0F];\n\t        }\n\t        return s;\n\t    }\n\t\n\t    function hex(x) {\n\t        var i;\n\t        for (i = 0; i < x.length; i += 1) {\n\t            x[i] = rhex(x[i]);\n\t        }\n\t        return x.join('');\n\t    }\n\t\n\t    // In some cases the fast add32 function cannot be used..\n\t    if (hex(md51('hello')) !== '5d41402abc4b2a76b9719d911017c592') {\n\t        add32 = function (x, y) {\n\t            var lsw = (x & 0xFFFF) + (y & 0xFFFF),\n\t                msw = (x >> 16) + (y >> 16) + (lsw >> 16);\n\t            return (msw << 16) | (lsw & 0xFFFF);\n\t        };\n\t    }\n\t\n\t    // ---------------------------------------------------\n\t\n\t    /**\n\t     * ArrayBuffer slice polyfill.\n\t     *\n\t     * @see https://github.com/ttaubert/node-arraybuffer-slice\n\t     */\n\t\n\t    if (typeof ArrayBuffer !== 'undefined' && !ArrayBuffer.prototype.slice) {\n\t        (function () {\n\t            function clamp(val, length) {\n\t                val = (val | 0) || 0;\n\t\n\t                if (val < 0) {\n\t                    return Math.max(val + length, 0);\n\t                }\n\t\n\t                return Math.min(val, length);\n\t            }\n\t\n\t            ArrayBuffer.prototype.slice = function (from, to) {\n\t                var length = this.byteLength,\n\t                    begin = clamp(from, length),\n\t                    end = length,\n\t                    num,\n\t                    target,\n\t                    targetArray,\n\t                    sourceArray;\n\t\n\t                if (to !== undefined) {\n\t                    end = clamp(to, length);\n\t                }\n\t\n\t                if (begin > end) {\n\t                    return new ArrayBuffer(0);\n\t                }\n\t\n\t                num = end - begin;\n\t                target = new ArrayBuffer(num);\n\t                targetArray = new Uint8Array(target);\n\t\n\t                sourceArray = new Uint8Array(this, begin, num);\n\t                targetArray.set(sourceArray);\n\t\n\t                return target;\n\t            };\n\t        })();\n\t    }\n\t\n\t    // ---------------------------------------------------\n\t\n\t    /**\n\t     * Helpers.\n\t     */\n\t\n\t    function toUtf8(str) {\n\t        if (/[\\u0080-\\uFFFF]/.test(str)) {\n\t            str = unescape(encodeURIComponent(str));\n\t        }\n\t\n\t        return str;\n\t    }\n\t\n\t    function utf8Str2ArrayBuffer(str, returnUInt8Array) {\n\t        var length = str.length,\n\t           buff = new ArrayBuffer(length),\n\t           arr = new Uint8Array(buff),\n\t           i;\n\t\n\t        for (i = 0; i < length; i += 1) {\n\t            arr[i] = str.charCodeAt(i);\n\t        }\n\t\n\t        return returnUInt8Array ? arr : buff;\n\t    }\n\t\n\t    function arrayBuffer2Utf8Str(buff) {\n\t        return String.fromCharCode.apply(null, new Uint8Array(buff));\n\t    }\n\t\n\t    function concatenateArrayBuffers(first, second, returnUInt8Array) {\n\t        var result = new Uint8Array(first.byteLength + second.byteLength);\n\t\n\t        result.set(new Uint8Array(first));\n\t        result.set(new Uint8Array(second), first.byteLength);\n\t\n\t        return returnUInt8Array ? result : result.buffer;\n\t    }\n\t\n\t    function hexToBinaryString(hex) {\n\t        var bytes = [],\n\t            length = hex.length,\n\t            x;\n\t\n\t        for (x = 0; x < length - 1; x += 2) {\n\t            bytes.push(parseInt(hex.substr(x, 2), 16));\n\t        }\n\t\n\t        return String.fromCharCode.apply(String, bytes);\n\t    }\n\t\n\t    // ---------------------------------------------------\n\t\n\t    /**\n\t     * SparkMD5 OOP implementation.\n\t     *\n\t     * Use this class to perform an incremental md5, otherwise use the\n\t     * static methods instead.\n\t     */\n\t\n\t    function SparkMD5() {\n\t        // call reset to init the instance\n\t        this.reset();\n\t    }\n\t\n\t    /**\n\t     * Appends a string.\n\t     * A conversion will be applied if an utf8 string is detected.\n\t     *\n\t     * @param {String} str The string to be appended\n\t     *\n\t     * @return {SparkMD5} The instance itself\n\t     */\n\t    SparkMD5.prototype.append = function (str) {\n\t        // Converts the string to utf8 bytes if necessary\n\t        // Then append as binary\n\t        this.appendBinary(toUtf8(str));\n\t\n\t        return this;\n\t    };\n\t\n\t    /**\n\t     * Appends a binary string.\n\t     *\n\t     * @param {String} contents The binary string to be appended\n\t     *\n\t     * @return {SparkMD5} The instance itself\n\t     */\n\t    SparkMD5.prototype.appendBinary = function (contents) {\n\t        this._buff += contents;\n\t        this._length += contents.length;\n\t\n\t        var length = this._buff.length,\n\t            i;\n\t\n\t        for (i = 64; i <= length; i += 64) {\n\t            md5cycle(this._hash, md5blk(this._buff.substring(i - 64, i)));\n\t        }\n\t\n\t        this._buff = this._buff.substring(i - 64);\n\t\n\t        return this;\n\t    };\n\t\n\t    /**\n\t     * Finishes the incremental computation, reseting the internal state and\n\t     * returning the result.\n\t     *\n\t     * @param {Boolean} raw True to get the raw string, false to get the hex string\n\t     *\n\t     * @return {String} The result\n\t     */\n\t    SparkMD5.prototype.end = function (raw) {\n\t        var buff = this._buff,\n\t            length = buff.length,\n\t            i,\n\t            tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n\t            ret;\n\t\n\t        for (i = 0; i < length; i += 1) {\n\t            tail[i >> 2] |= buff.charCodeAt(i) << ((i % 4) << 3);\n\t        }\n\t\n\t        this._finish(tail, length);\n\t        ret = hex(this._hash);\n\t\n\t        if (raw) {\n\t            ret = hexToBinaryString(ret);\n\t        }\n\t\n\t        this.reset();\n\t\n\t        return ret;\n\t    };\n\t\n\t    /**\n\t     * Resets the internal state of the computation.\n\t     *\n\t     * @return {SparkMD5} The instance itself\n\t     */\n\t    SparkMD5.prototype.reset = function () {\n\t        this._buff = '';\n\t        this._length = 0;\n\t        this._hash = [1732584193, -271733879, -1732584194, 271733878];\n\t\n\t        return this;\n\t    };\n\t\n\t    /**\n\t     * Gets the internal state of the computation.\n\t     *\n\t     * @return {Object} The state\n\t     */\n\t    SparkMD5.prototype.getState = function () {\n\t        return {\n\t            buff: this._buff,\n\t            length: this._length,\n\t            hash: this._hash\n\t        };\n\t    };\n\t\n\t    /**\n\t     * Gets the internal state of the computation.\n\t     *\n\t     * @param {Object} state The state\n\t     *\n\t     * @return {SparkMD5} The instance itself\n\t     */\n\t    SparkMD5.prototype.setState = function (state) {\n\t        this._buff = state.buff;\n\t        this._length = state.length;\n\t        this._hash = state.hash;\n\t\n\t        return this;\n\t    };\n\t\n\t    /**\n\t     * Releases memory used by the incremental buffer and other additional\n\t     * resources. If you plan to use the instance again, use reset instead.\n\t     */\n\t    SparkMD5.prototype.destroy = function () {\n\t        delete this._hash;\n\t        delete this._buff;\n\t        delete this._length;\n\t    };\n\t\n\t    /**\n\t     * Finish the final calculation based on the tail.\n\t     *\n\t     * @param {Array}  tail   The tail (will be modified)\n\t     * @param {Number} length The length of the remaining buffer\n\t     */\n\t    SparkMD5.prototype._finish = function (tail, length) {\n\t        var i = length,\n\t            tmp,\n\t            lo,\n\t            hi;\n\t\n\t        tail[i >> 2] |= 0x80 << ((i % 4) << 3);\n\t        if (i > 55) {\n\t            md5cycle(this._hash, tail);\n\t            for (i = 0; i < 16; i += 1) {\n\t                tail[i] = 0;\n\t            }\n\t        }\n\t\n\t        // Do the final computation based on the tail and length\n\t        // Beware that the final length may not fit in 32 bits so we take care of that\n\t        tmp = this._length * 8;\n\t        tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);\n\t        lo = parseInt(tmp[2], 16);\n\t        hi = parseInt(tmp[1], 16) || 0;\n\t\n\t        tail[14] = lo;\n\t        tail[15] = hi;\n\t        md5cycle(this._hash, tail);\n\t    };\n\t\n\t    /**\n\t     * Performs the md5 hash on a string.\n\t     * A conversion will be applied if utf8 string is detected.\n\t     *\n\t     * @param {String}  str The string\n\t     * @param {Boolean} raw True to get the raw string, false to get the hex string\n\t     *\n\t     * @return {String} The result\n\t     */\n\t    SparkMD5.hash = function (str, raw) {\n\t        // Converts the string to utf8 bytes if necessary\n\t        // Then compute it using the binary function\n\t        return SparkMD5.hashBinary(toUtf8(str), raw);\n\t    };\n\t\n\t    /**\n\t     * Performs the md5 hash on a binary string.\n\t     *\n\t     * @param {String}  content The binary string\n\t     * @param {Boolean} raw     True to get the raw string, false to get the hex string\n\t     *\n\t     * @return {String} The result\n\t     */\n\t    SparkMD5.hashBinary = function (content, raw) {\n\t        var hash = md51(content),\n\t            ret = hex(hash);\n\t\n\t        return raw ? hexToBinaryString(ret) : ret;\n\t    };\n\t\n\t    // ---------------------------------------------------\n\t\n\t    /**\n\t     * SparkMD5 OOP implementation for array buffers.\n\t     *\n\t     * Use this class to perform an incremental md5 ONLY for array buffers.\n\t     */\n\t    SparkMD5.ArrayBuffer = function () {\n\t        // call reset to init the instance\n\t        this.reset();\n\t    };\n\t\n\t    /**\n\t     * Appends an array buffer.\n\t     *\n\t     * @param {ArrayBuffer} arr The array to be appended\n\t     *\n\t     * @return {SparkMD5.ArrayBuffer} The instance itself\n\t     */\n\t    SparkMD5.ArrayBuffer.prototype.append = function (arr) {\n\t        var buff = concatenateArrayBuffers(this._buff.buffer, arr, true),\n\t            length = buff.length,\n\t            i;\n\t\n\t        this._length += arr.byteLength;\n\t\n\t        for (i = 64; i <= length; i += 64) {\n\t            md5cycle(this._hash, md5blk_array(buff.subarray(i - 64, i)));\n\t        }\n\t\n\t        this._buff = (i - 64) < length ? new Uint8Array(buff.buffer.slice(i - 64)) : new Uint8Array(0);\n\t\n\t        return this;\n\t    };\n\t\n\t    /**\n\t     * Finishes the incremental computation, reseting the internal state and\n\t     * returning the result.\n\t     *\n\t     * @param {Boolean} raw True to get the raw string, false to get the hex string\n\t     *\n\t     * @return {String} The result\n\t     */\n\t    SparkMD5.ArrayBuffer.prototype.end = function (raw) {\n\t        var buff = this._buff,\n\t            length = buff.length,\n\t            tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n\t            i,\n\t            ret;\n\t\n\t        for (i = 0; i < length; i += 1) {\n\t            tail[i >> 2] |= buff[i] << ((i % 4) << 3);\n\t        }\n\t\n\t        this._finish(tail, length);\n\t        ret = hex(this._hash);\n\t\n\t        if (raw) {\n\t            ret = hexToBinaryString(ret);\n\t        }\n\t\n\t        this.reset();\n\t\n\t        return ret;\n\t    };\n\t\n\t    /**\n\t     * Resets the internal state of the computation.\n\t     *\n\t     * @return {SparkMD5.ArrayBuffer} The instance itself\n\t     */\n\t    SparkMD5.ArrayBuffer.prototype.reset = function () {\n\t        this._buff = new Uint8Array(0);\n\t        this._length = 0;\n\t        this._hash = [1732584193, -271733879, -1732584194, 271733878];\n\t\n\t        return this;\n\t    };\n\t\n\t    /**\n\t     * Gets the internal state of the computation.\n\t     *\n\t     * @return {Object} The state\n\t     */\n\t    SparkMD5.ArrayBuffer.prototype.getState = function () {\n\t        var state = SparkMD5.prototype.getState.call(this);\n\t\n\t        // Convert buffer to a string\n\t        state.buff = arrayBuffer2Utf8Str(state.buff);\n\t\n\t        return state;\n\t    };\n\t\n\t    /**\n\t     * Gets the internal state of the computation.\n\t     *\n\t     * @param {Object} state The state\n\t     *\n\t     * @return {SparkMD5.ArrayBuffer} The instance itself\n\t     */\n\t    SparkMD5.ArrayBuffer.prototype.setState = function (state) {\n\t        // Convert string to buffer\n\t        state.buff = utf8Str2ArrayBuffer(state.buff, true);\n\t\n\t        return SparkMD5.prototype.setState.call(this, state);\n\t    };\n\t\n\t    SparkMD5.ArrayBuffer.prototype.destroy = SparkMD5.prototype.destroy;\n\t\n\t    SparkMD5.ArrayBuffer.prototype._finish = SparkMD5.prototype._finish;\n\t\n\t    /**\n\t     * Performs the md5 hash on an array buffer.\n\t     *\n\t     * @param {ArrayBuffer} arr The array buffer\n\t     * @param {Boolean}     raw True to get the raw string, false to get the hex one\n\t     *\n\t     * @return {String} The result\n\t     */\n\t    SparkMD5.ArrayBuffer.hash = function (arr, raw) {\n\t        var hash = md51_array(new Uint8Array(arr)),\n\t            ret = hex(hash);\n\t\n\t        return raw ? hexToBinaryString(ret) : ret;\n\t    };\n\t\n\t    return SparkMD5;\n\t}));\n\n\n/***/ },\n/* 28 */\n/***/ function(module, exports) {\n\n\t/* global _ */\n\t(function () {\n\t\t'use strict';\n\t\n\t\t/* jshint ignore:start */\n\t\t// Underscore's Template Module\n\t\t// Courtesy of underscorejs.org\n\t\tvar _ = (function (_) {\n\t\t\t_.defaults = function (object) {\n\t\t\t\tif (!object) {\n\t\t\t\t\treturn object;\n\t\t\t\t}\n\t\t\t\tfor (var argsIndex = 1, argsLength = arguments.length; argsIndex < argsLength; argsIndex++) {\n\t\t\t\t\tvar iterable = arguments[argsIndex];\n\t\t\t\t\tif (iterable) {\n\t\t\t\t\t\tfor (var key in iterable) {\n\t\t\t\t\t\t\tif (object[key] == null) {\n\t\t\t\t\t\t\t\tobject[key] = iterable[key];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn object;\n\t\t\t}\n\t\n\t\t\t// By default, Underscore uses ERB-style template delimiters, change the\n\t\t\t// following template settings to use alternative delimiters.\n\t\t\t_.templateSettings = {\n\t\t\t\tevaluate    : /<%([\\s\\S]+?)%>/g,\n\t\t\t\tinterpolate : /<%=([\\s\\S]+?)%>/g,\n\t\t\t\tescape      : /<%-([\\s\\S]+?)%>/g\n\t\t\t};\n\t\n\t\t\t// When customizing `templateSettings`, if you don't want to define an\n\t\t\t// interpolation, evaluation or escaping regex, we need one that is\n\t\t\t// guaranteed not to match.\n\t\t\tvar noMatch = /(.)^/;\n\t\n\t\t\t// Certain characters need to be escaped so that they can be put into a\n\t\t\t// string literal.\n\t\t\tvar escapes = {\n\t\t\t\t\"'\":      \"'\",\n\t\t\t\t'\\\\':     '\\\\',\n\t\t\t\t'\\r':     'r',\n\t\t\t\t'\\n':     'n',\n\t\t\t\t'\\t':     't',\n\t\t\t\t'\\u2028': 'u2028',\n\t\t\t\t'\\u2029': 'u2029'\n\t\t\t};\n\t\n\t\t\tvar escaper = /\\\\|'|\\r|\\n|\\t|\\u2028|\\u2029/g;\n\t\n\t\t\t// JavaScript micro-templating, similar to John Resig's implementation.\n\t\t\t// Underscore templating handles arbitrary delimiters, preserves whitespace,\n\t\t\t// and correctly escapes quotes within interpolated code.\n\t\t\t_.template = function(text, data, settings) {\n\t\t\t\tvar render;\n\t\t\t\tsettings = _.defaults({}, settings, _.templateSettings);\n\t\n\t\t\t\t// Combine delimiters into one regular expression via alternation.\n\t\t\t\tvar matcher = new RegExp([\n\t\t\t\t\t(settings.escape || noMatch).source,\n\t\t\t\t\t(settings.interpolate || noMatch).source,\n\t\t\t\t\t(settings.evaluate || noMatch).source\n\t\t\t\t].join('|') + '|$', 'g');\n\t\n\t\t\t\t// Compile the template source, escaping string literals appropriately.\n\t\t\t\tvar index = 0;\n\t\t\t\tvar source = \"__p+='\";\n\t\t\t\ttext.replace(matcher, function(match, escape, interpolate, evaluate, offset) {\n\t\t\t\t\tsource += text.slice(index, offset)\n\t\t\t\t\t\t.replace(escaper, function(match) { return '\\\\' + escapes[match]; });\n\t\n\t\t\t\t\tif (escape) {\n\t\t\t\t\t\tsource += \"'+\\n((__t=(\" + escape + \"))==null?'':_.escape(__t))+\\n'\";\n\t\t\t\t\t}\n\t\t\t\t\tif (interpolate) {\n\t\t\t\t\t\tsource += \"'+\\n((__t=(\" + interpolate + \"))==null?'':__t)+\\n'\";\n\t\t\t\t\t}\n\t\t\t\t\tif (evaluate) {\n\t\t\t\t\t\tsource += \"';\\n\" + evaluate + \"\\n__p+='\";\n\t\t\t\t\t}\n\t\t\t\t\tindex = offset + match.length;\n\t\t\t\t\treturn match;\n\t\t\t\t});\n\t\t\t\tsource += \"';\\n\";\n\t\n\t\t\t\t// If a variable is not specified, place data values in local scope.\n\t\t\t\tif (!settings.variable) source = 'with(obj||{}){\\n' + source + '}\\n';\n\t\n\t\t\t\tsource = \"var __t,__p='',__j=Array.prototype.join,\" +\n\t\t\t\t\t\"print=function(){__p+=__j.call(arguments,'');};\\n\" +\n\t\t\t\t\tsource + \"return __p;\\n\";\n\t\n\t\t\t\ttry {\n\t\t\t\t\trender = new Function(settings.variable || 'obj', '_', source);\n\t\t\t\t} catch (e) {\n\t\t\t\t\te.source = source;\n\t\t\t\t\tthrow e;\n\t\t\t\t}\n\t\n\t\t\t\tif (data) return render(data, _);\n\t\t\t\tvar template = function(data) {\n\t\t\t\t\treturn render.call(this, data, _);\n\t\t\t\t};\n\t\n\t\t\t\t// Provide the compiled function source as a convenience for precompilation.\n\t\t\t\ttemplate.source = 'function(' + (settings.variable || 'obj') + '){\\n' + source + '}';\n\t\n\t\t\t\treturn template;\n\t\t\t};\n\t\n\t\t\treturn _;\n\t\t})({});\n\t\n\t\tif (location.hostname === 'todomvc.com') {\n\t\t\t(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){\n\t\t\t(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),\n\t\t\tm=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)\n\t\t\t})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');\n\t\t\tga('create', 'UA-31081062-1', 'auto');\n\t\t\tga('send', 'pageview');\n\t\t}\n\t\t/* jshint ignore:end */\n\t\n\t\tfunction redirect() {\n\t\t\tif (location.hostname === 'tastejs.github.io') {\n\t\t\t\tlocation.href = location.href.replace('tastejs.github.io/todomvc', 'todomvc.com');\n\t\t\t}\n\t\t}\n\t\n\t\tfunction findRoot() {\n\t\t\tvar base = location.href.indexOf('examples/');\n\t\t\treturn location.href.substr(0, base);\n\t\t}\n\t\n\t\tfunction getFile(file, callback) {\n\t\t\tif (!location.host) {\n\t\t\t\treturn console.info('Miss the info bar? Run TodoMVC from a server to avoid a cross-origin error.');\n\t\t\t}\n\t\n\t\t\tvar xhr = new XMLHttpRequest();\n\t\n\t\t\txhr.open('GET', findRoot() + file, true);\n\t\t\txhr.send();\n\t\n\t\t\txhr.onload = function () {\n\t\t\t\tif (xhr.status === 200 && callback) {\n\t\t\t\t\tcallback(xhr.responseText);\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t\n\t\tfunction Learn(learnJSON, config) {\n\t\t\tif (!(this instanceof Learn)) {\n\t\t\t\treturn new Learn(learnJSON, config);\n\t\t\t}\n\t\n\t\t\tvar template, framework;\n\t\n\t\t\tif (typeof learnJSON !== 'object') {\n\t\t\t\ttry {\n\t\t\t\t\tlearnJSON = JSON.parse(learnJSON);\n\t\t\t\t} catch (e) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tif (config) {\n\t\t\t\ttemplate = config.template;\n\t\t\t\tframework = config.framework;\n\t\t\t}\n\t\n\t\t\tif (!template && learnJSON.templates) {\n\t\t\t\ttemplate = learnJSON.templates.todomvc;\n\t\t\t}\n\t\n\t\t\tif (!framework && document.querySelector('[data-framework]')) {\n\t\t\t\tframework = document.querySelector('[data-framework]').dataset.framework;\n\t\t\t}\n\t\n\t\t\tthis.template = template;\n\t\n\t\t\tif (learnJSON.backend) {\n\t\t\t\tthis.frameworkJSON = learnJSON.backend;\n\t\t\t\tthis.frameworkJSON.issueLabel = framework;\n\t\t\t\tthis.append({\n\t\t\t\t\tbackend: true\n\t\t\t\t});\n\t\t\t} else if (learnJSON[framework]) {\n\t\t\t\tthis.frameworkJSON = learnJSON[framework];\n\t\t\t\tthis.frameworkJSON.issueLabel = framework;\n\t\t\t\tthis.append();\n\t\t\t}\n\t\n\t\t\tthis.fetchIssueCount();\n\t\t}\n\t\n\t\tLearn.prototype.append = function (opts) {\n\t\t\tvar aside = document.createElement('aside');\n\t\t\taside.innerHTML = _.template(this.template, this.frameworkJSON);\n\t\t\taside.className = 'learn';\n\t\n\t\t\tif (opts && opts.backend) {\n\t\t\t\t// Remove demo link\n\t\t\t\tvar sourceLinks = aside.querySelector('.source-links');\n\t\t\t\tvar heading = sourceLinks.firstElementChild;\n\t\t\t\tvar sourceLink = sourceLinks.lastElementChild;\n\t\t\t\t// Correct link path\n\t\t\t\tvar href = sourceLink.getAttribute('href');\n\t\t\t\tsourceLink.setAttribute('href', href.substr(href.lastIndexOf('http')));\n\t\t\t\tsourceLinks.innerHTML = heading.outerHTML + sourceLink.outerHTML;\n\t\t\t} else {\n\t\t\t\t// Localize demo links\n\t\t\t\tvar demoLinks = aside.querySelectorAll('.demo-link');\n\t\t\t\tArray.prototype.forEach.call(demoLinks, function (demoLink) {\n\t\t\t\t\tif (demoLink.getAttribute('href').substr(0, 4) !== 'http') {\n\t\t\t\t\t\tdemoLink.setAttribute('href', findRoot() + demoLink.getAttribute('href'));\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\n\t\t\tdocument.body.className = (document.body.className + ' learn-bar').trim();\n\t\t\tdocument.body.insertAdjacentHTML('afterBegin', aside.outerHTML);\n\t\t};\n\t\n\t\tLearn.prototype.fetchIssueCount = function () {\n\t\t\tvar issueLink = document.getElementById('issue-count-link');\n\t\t\tif (issueLink) {\n\t\t\t\tvar url = issueLink.href.replace('https://github.com', 'https://api.github.com/repos');\n\t\t\t\tvar xhr = new XMLHttpRequest();\n\t\t\t\txhr.open('GET', url, true);\n\t\t\t\txhr.onload = function (e) {\n\t\t\t\t\tvar parsedResponse = JSON.parse(e.target.responseText);\n\t\t\t\t\tif (parsedResponse instanceof Array) {\n\t\t\t\t\t\tvar count = parsedResponse.length;\n\t\t\t\t\t\tif (count !== 0) {\n\t\t\t\t\t\t\tissueLink.innerHTML = 'This app has ' + count + ' open issues';\n\t\t\t\t\t\t\tdocument.getElementById('issue-count').style.display = 'inline';\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\txhr.send();\n\t\t\t}\n\t\t};\n\t\n\t\tredirect();\n\t\tgetFile('learn.json', Learn);\n\t})();\n\n\n/***/ },\n/* 29 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\t/**\n\t * Stringify/parse functions that don't operate\n\t * recursively, so they avoid call stack exceeded\n\t * errors.\n\t */\n\texports.stringify = function stringify(input) {\n\t  var queue = [];\n\t  queue.push({obj: input});\n\t\n\t  var res = '';\n\t  var next, obj, prefix, val, i, arrayPrefix, keys, k, key, value, objPrefix;\n\t  while ((next = queue.pop())) {\n\t    obj = next.obj;\n\t    prefix = next.prefix || '';\n\t    val = next.val || '';\n\t    res += prefix;\n\t    if (val) {\n\t      res += val;\n\t    } else if (typeof obj !== 'object') {\n\t      res += typeof obj === 'undefined' ? null : JSON.stringify(obj);\n\t    } else if (obj === null) {\n\t      res += 'null';\n\t    } else if (Array.isArray(obj)) {\n\t      queue.push({val: ']'});\n\t      for (i = obj.length - 1; i >= 0; i--) {\n\t        arrayPrefix = i === 0 ? '' : ',';\n\t        queue.push({obj: obj[i], prefix: arrayPrefix});\n\t      }\n\t      queue.push({val: '['});\n\t    } else { // object\n\t      keys = [];\n\t      for (k in obj) {\n\t        if (obj.hasOwnProperty(k)) {\n\t          keys.push(k);\n\t        }\n\t      }\n\t      queue.push({val: '}'});\n\t      for (i = keys.length - 1; i >= 0; i--) {\n\t        key = keys[i];\n\t        value = obj[key];\n\t        objPrefix = (i > 0 ? ',' : '');\n\t        objPrefix += JSON.stringify(key) + ':';\n\t        queue.push({obj: value, prefix: objPrefix});\n\t      }\n\t      queue.push({val: '{'});\n\t    }\n\t  }\n\t  return res;\n\t};\n\t\n\t// Convenience function for the parse function.\n\t// This pop function is basically copied from\n\t// pouchCollate.parseIndexableString\n\tfunction pop(obj, stack, metaStack) {\n\t  var lastMetaElement = metaStack[metaStack.length - 1];\n\t  if (obj === lastMetaElement.element) {\n\t    // popping a meta-element, e.g. an object whose value is another object\n\t    metaStack.pop();\n\t    lastMetaElement = metaStack[metaStack.length - 1];\n\t  }\n\t  var element = lastMetaElement.element;\n\t  var lastElementIndex = lastMetaElement.index;\n\t  if (Array.isArray(element)) {\n\t    element.push(obj);\n\t  } else if (lastElementIndex === stack.length - 2) { // obj with key+value\n\t    var key = stack.pop();\n\t    element[key] = obj;\n\t  } else {\n\t    stack.push(obj); // obj with key only\n\t  }\n\t}\n\t\n\texports.parse = function (str) {\n\t  var stack = [];\n\t  var metaStack = []; // stack for arrays and objects\n\t  var i = 0;\n\t  var collationIndex,parsedNum,numChar;\n\t  var parsedString,lastCh,numConsecutiveSlashes,ch;\n\t  var arrayElement, objElement;\n\t  while (true) {\n\t    collationIndex = str[i++];\n\t    if (collationIndex === '}' ||\n\t        collationIndex === ']' ||\n\t        typeof collationIndex === 'undefined') {\n\t      if (stack.length === 1) {\n\t        return stack.pop();\n\t      } else {\n\t        pop(stack.pop(), stack, metaStack);\n\t        continue;\n\t      }\n\t    }\n\t    switch (collationIndex) {\n\t      case ' ':\n\t      case '\\t':\n\t      case '\\n':\n\t      case ':':\n\t      case ',':\n\t        break;\n\t      case 'n':\n\t        i += 3; // 'ull'\n\t        pop(null, stack, metaStack);\n\t        break;\n\t      case 't':\n\t        i += 3; // 'rue'\n\t        pop(true, stack, metaStack);\n\t        break;\n\t      case 'f':\n\t        i += 4; // 'alse'\n\t        pop(false, stack, metaStack);\n\t        break;\n\t      case '0':\n\t      case '1':\n\t      case '2':\n\t      case '3':\n\t      case '4':\n\t      case '5':\n\t      case '6':\n\t      case '7':\n\t      case '8':\n\t      case '9':\n\t      case '-':\n\t        parsedNum = '';\n\t        i--;\n\t        while (true) {\n\t          numChar = str[i++];\n\t          if (/[\\d\\.\\-e\\+]/.test(numChar)) {\n\t            parsedNum += numChar;\n\t          } else {\n\t            i--;\n\t            break;\n\t          }\n\t        }\n\t        pop(parseFloat(parsedNum), stack, metaStack);\n\t        break;\n\t      case '\"':\n\t        parsedString = '';\n\t        lastCh = void 0;\n\t        numConsecutiveSlashes = 0;\n\t        while (true) {\n\t          ch = str[i++];\n\t          if (ch !== '\"' || (lastCh === '\\\\' &&\n\t              numConsecutiveSlashes % 2 === 1)) {\n\t            parsedString += ch;\n\t            lastCh = ch;\n\t            if (lastCh === '\\\\') {\n\t              numConsecutiveSlashes++;\n\t            } else {\n\t              numConsecutiveSlashes = 0;\n\t            }\n\t          } else {\n\t            break;\n\t          }\n\t        }\n\t        pop(JSON.parse('\"' + parsedString + '\"'), stack, metaStack);\n\t        break;\n\t      case '[':\n\t        arrayElement = { element: [], index: stack.length };\n\t        stack.push(arrayElement.element);\n\t        metaStack.push(arrayElement);\n\t        break;\n\t      case '{':\n\t        objElement = { element: {}, index: stack.length };\n\t        stack.push(objElement.element);\n\t        metaStack.push(objElement);\n\t        break;\n\t      default:\n\t        throw new Error(\n\t          'unexpectedly reached end of input: ' + collationIndex);\n\t    }\n\t  }\n\t};\n\n\n/***/ }\n/******/ ]);\n\n\n/** WEBPACK FOOTER **\n ** index.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap dc842e0959297ac9a8b2\n **/","import { h, render } from 'preact';\nimport App from './app';\nimport 'todomvc-common';\nimport 'todomvc-common/base.css';\nimport 'todomvc-app-css/index.css';\n\nrender(<App />, document.querySelector('.todoapp'));\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/index.js\n **/","!function(global, factory) {\n    'object' == typeof exports && 'undefined' != typeof module ? module.exports = factory() : 'function' == typeof define && define.amd ? define(factory) : global.preact = factory();\n}(this, function() {\n    'use strict';\n    function VNode(nodeName, attributes, children) {\n        this.nodeName = nodeName;\n        this.attributes = attributes;\n        this.children = children;\n    }\n    function extend(obj, props) {\n        for (var i in props) if (hasOwnProperty.call(props, i)) obj[i] = props[i];\n        return obj;\n    }\n    function clone(obj) {\n        var out = {};\n        for (var i in obj) out[i] = obj[i];\n        return out;\n    }\n    function memoize(fn, mem) {\n        mem = mem || {};\n        return function(k) {\n            return hasOwnProperty.call(mem, k) ? mem[k] : mem[k] = fn(k);\n        };\n    }\n    function delve(obj, key) {\n        for (var p = key.split('.'), i = 0; i < p.length && obj; i++) obj = obj[p];\n        return obj;\n    }\n    function toArray(obj) {\n        var arr = [], i = obj.length;\n        for (;i--; ) arr[i] = obj[i];\n        return arr;\n    }\n    function styleObjToCss(s) {\n        var str = '';\n        for (var prop in s) if (hasOwnProperty.call(s, prop)) {\n            var val = s[prop];\n            if (!empty(val)) {\n                str += jsToCss(prop);\n                str += ': ';\n                str += val;\n                if ('number' == typeof val && !NON_DIMENSION_PROPS[prop]) str += 'px';\n                str += '; ';\n            }\n        }\n        return str;\n    }\n    function hashToClassName(c) {\n        var str = '';\n        for (var prop in c) if (c[prop]) {\n            if (str) str += ' ';\n            str += prop;\n        }\n        return str;\n    }\n    function normalize(obj, prop, fn) {\n        var v = obj[prop];\n        if (v && !isString(v)) obj[prop] = fn(v);\n    }\n    function optionsHook(name, a, b) {\n        return hook(options, name, a, b);\n    }\n    function hook(obj, name, a, b, c) {\n        if (obj[name]) return obj[name](a, b, c); else ;\n    }\n    function deepHook(obj, type) {\n        do hook(obj, type); while (obj = obj._component);\n    }\n    function h(nodeName, attributes) {\n        var len = arguments.length, children = void 0, arr = void 0, lastSimple = void 0;\n        if (len > 2) {\n            children = [];\n            for (var i = 2; len > i; i++) {\n                var _p = arguments[i];\n                if (!falsey(_p)) {\n                    if (_p.join) arr = _p; else {\n                        arr = SHARED_TEMP_ARRAY;\n                        arr[0] = _p;\n                    }\n                    for (var j = 0; j < arr.length; j++) {\n                        var child = arr[j], simple = !(falsey(child) || child instanceof VNode);\n                        if (simple) child = String(child);\n                        if (simple && lastSimple) children[children.length - 1] += child; else if (!falsey(child)) children.push(child);\n                        lastSimple = simple;\n                    }\n                } else ;\n            }\n        }\n        if (attributes && attributes.children) delete attributes.children;\n        var p = new VNode(nodeName, attributes || void 0, children || void 0);\n        optionsHook('vnode', p);\n        return p;\n    }\n    function createLinkedState(component, key, eventPath) {\n        var path = key.split('.'), p0 = path[0], len = path.length;\n        return function(e) {\n            var _component$setState;\n            var t = this, s = component.state, obj = s, v = void 0, i = void 0;\n            if (isString(eventPath)) {\n                v = delve(e, eventPath);\n                if (empty(v) && (t = t._component)) v = delve(t, eventPath);\n            } else v = (t.nodeName + t.type).match(/^input(checkbox|radio)$/i) ? t.checked : t.value;\n            if (isFunction(v)) v = v.call(t);\n            if (len > 1) {\n                for (i = 0; len - 1 > i; i++) obj = obj[path[i]] || (obj[path[i]] = {});\n                obj[path[i]] = v;\n                v = s[p0];\n            }\n            component.setState((_component$setState = {}, _component$setState[p0] = v, _component$setState));\n        };\n    }\n    function enqueueRender(component) {\n        if (1 === items.push(component)) (options.debounceRendering || setImmediate)(rerender);\n    }\n    function rerender() {\n        if (items.length) {\n            var currentItems = items, p = void 0;\n            items = itemsOffline;\n            itemsOffline = currentItems;\n            for (;p = currentItems.pop(); ) if (p._dirty) renderComponent(p);\n        }\n    }\n    function isFunctionalComponent(_ref) {\n        var nodeName = _ref.nodeName;\n        return isFunction(nodeName) && !nodeName.prototype.render;\n    }\n    function buildFunctionalComponent(vnode, context) {\n        return vnode.nodeName(getNodeProps(vnode), context || EMPTY) || EMPTY_BASE;\n    }\n    function ensureNodeData(node) {\n        return node[ATTR_KEY] || (node[ATTR_KEY] = {});\n    }\n    function getNodeType(node) {\n        return node.nodeType;\n    }\n    function appendChildren(parent, children) {\n        var len = children.length, many = len > 2, into = many ? document.createDocumentFragment() : parent;\n        for (var i = 0; len > i; i++) into.appendChild(children[i]);\n        if (many) parent.appendChild(into);\n    }\n    function getAccessor(node, name, value, cache) {\n        if ('type' !== name && 'style' !== name && name in node) return node[name];\n        var attrs = node[ATTR_KEY];\n        if (cache !== !1 && attrs && hasOwnProperty.call(attrs, name)) return attrs[name];\n        if ('class' === name) return node.className;\n        if ('style' === name) return node.style.cssText; else return value;\n    }\n    function setAccessor(node, name, value) {\n        if ('class' === name) node.className = value || ''; else if ('style' === name) node.style.cssText = value || ''; else if ('dangerouslySetInnerHTML' === name) {\n            if (value && value.__html) node.innerHTML = value.__html;\n        } else if ('key' === name || name in node && 'type' !== name) {\n            node[name] = value;\n            if (falsey(value)) node.removeAttribute(name);\n        } else setComplexAccessor(node, name, value);\n        ensureNodeData(node)[name] = value;\n    }\n    function setComplexAccessor(node, name, value) {\n        if ('on' !== name.substring(0, 2)) {\n            var type = typeof value;\n            if (falsey(value)) node.removeAttribute(name); else if ('function' !== type && 'object' !== type) node.setAttribute(name, value);\n        } else {\n            var _type = normalizeEventName(name), l = node._listeners || (node._listeners = {}), fn = !l[_type] ? 'add' : !value ? 'remove' : null;\n            if (fn) node[fn + 'EventListener'](_type, eventProxy);\n            l[_type] = value;\n        }\n    }\n    function eventProxy(e) {\n        var fn = this._listeners[normalizeEventName(e.type)];\n        if (fn) return fn.call(this, optionsHook('event', e) || e); else ;\n    }\n    function getNodeAttributes(node) {\n        return node[ATTR_KEY] || getRawNodeAttributes(node) || EMPTY;\n    }\n    function getRawNodeAttributes(node) {\n        var list = node.attributes;\n        if (!list || !list.getNamedItem) return list; else return getAttributesAsObject(list);\n    }\n    function getAttributesAsObject(list) {\n        var attrs = void 0;\n        for (var i = list.length; i--; ) {\n            var item = list[i];\n            if (!attrs) attrs = {};\n            attrs[item.name] = item.value;\n        }\n        return attrs;\n    }\n    function isSameNodeType(node, vnode) {\n        if (isFunctionalComponent(vnode)) return !0;\n        var nodeName = vnode.nodeName;\n        if (isFunction(nodeName)) return node._componentConstructor === nodeName;\n        if (3 === getNodeType(node)) return isString(vnode); else return toLowerCase(node.nodeName) === nodeName;\n    }\n    function getNodeProps(vnode) {\n        var props = clone(vnode.attributes), c = vnode.children;\n        if (c) props.children = c;\n        var defaultProps = vnode.nodeName.defaultProps;\n        if (defaultProps) for (var i in defaultProps) if (hasOwnProperty.call(defaultProps, i) && !(i in props)) props[i] = defaultProps[i];\n        return props;\n    }\n    function collectNode(node) {\n        cleanNode(node);\n        var name = normalizeName(node.nodeName), list = nodes[name];\n        if (list) list.push(node); else nodes[name] = [ node ];\n    }\n    function createNode(nodeName) {\n        var name = normalizeName(nodeName), list = nodes[name], node = list && list.pop() || document.createElement(nodeName);\n        ensureNodeData(node);\n        return node;\n    }\n    function cleanNode(node) {\n        var p = node.parentNode;\n        if (p) p.removeChild(node);\n        if (3 !== getNodeType(node)) {\n            if (!node[ATTR_KEY]) node[ATTR_KEY] = getRawNodeAttributes(node);\n            node._component = node._componentConstructor = null;\n        }\n    }\n    function diff(dom, vnode, context) {\n        var originalAttributes = vnode.attributes;\n        for (;isFunctionalComponent(vnode); ) vnode = buildFunctionalComponent(vnode, context);\n        if (isFunction(vnode.nodeName)) return buildComponentFromVNode(dom, vnode, context);\n        if (isString(vnode)) {\n            if (dom) {\n                var type = getNodeType(dom);\n                if (3 === type) {\n                    dom[TEXT_CONTENT] = vnode;\n                    return dom;\n                } else if (1 === type) collectNode(dom);\n            }\n            return document.createTextNode(vnode);\n        }\n        var out = dom, nodeName = vnode.nodeName || UNDEFINED_ELEMENT;\n        if (!dom) out = createNode(nodeName); else if (toLowerCase(dom.nodeName) !== nodeName) {\n            out = createNode(nodeName);\n            appendChildren(out, toArray(dom.childNodes));\n            recollectNodeTree(dom);\n        }\n        innerDiffNode(out, vnode, context);\n        diffAttributes(out, vnode);\n        if (originalAttributes && originalAttributes.ref) (out[ATTR_KEY].ref = originalAttributes.ref)(out);\n        return out;\n    }\n    function innerDiffNode(dom, vnode, context) {\n        var children = void 0, keyed = void 0, keyedLen = 0, len = dom.childNodes.length, childrenLen = 0;\n        if (len) {\n            children = [];\n            for (var i = 0; len > i; i++) {\n                var child = dom.childNodes[i], props = child._component && child._component.props, key = props ? props.key : getAccessor(child, 'key');\n                if (!empty(key)) {\n                    if (!keyed) keyed = {};\n                    keyed[key] = child;\n                    keyedLen++;\n                } else children[childrenLen++] = child;\n            }\n        }\n        var vchildren = vnode.children, vlen = vchildren && vchildren.length, min = 0;\n        if (vlen) for (var i = 0; vlen > i; i++) {\n            var vchild = vchildren[i], child = void 0;\n            if (keyedLen) {\n                var attrs = vchild.attributes, key = attrs && attrs.key;\n                if (!empty(key) && hasOwnProperty.call(keyed, key)) {\n                    child = keyed[key];\n                    keyed[key] = null;\n                    keyedLen--;\n                }\n            }\n            if (!child && childrenLen > min) for (var j = min; childrenLen > j; j++) {\n                var c = children[j];\n                if (c && isSameNodeType(c, vchild)) {\n                    child = c;\n                    children[j] = null;\n                    if (j === childrenLen - 1) childrenLen--;\n                    if (j === min) min++;\n                    break;\n                }\n            }\n            child = diff(child, vchild, context);\n            if (dom.childNodes[i] !== child) {\n                var c = child.parentNode !== dom && child._component, next = dom.childNodes[i + 1];\n                if (c) deepHook(c, 'componentWillMount');\n                if (next) dom.insertBefore(child, next); else dom.appendChild(child);\n                if (c) deepHook(c, 'componentDidMount');\n            }\n        }\n        if (keyedLen) for (var i in keyed) if (hasOwnProperty.call(keyed, i) && keyed[i]) children[min = childrenLen++] = keyed[i];\n        if (childrenLen > min) removeOrphanedChildren(children);\n    }\n    function removeOrphanedChildren(children, unmountOnly) {\n        for (var i = children.length; i--; ) {\n            var child = children[i];\n            if (child) recollectNodeTree(child, unmountOnly);\n        }\n    }\n    function recollectNodeTree(node, unmountOnly) {\n        var attrs = node[ATTR_KEY];\n        if (attrs) hook(attrs, 'ref', null);\n        var component = node._component;\n        if (component) unmountComponent(node, component, !unmountOnly); else {\n            if (!unmountOnly) {\n                if (1 !== getNodeType(node)) {\n                    var p = node.parentNode;\n                    if (p) p.removeChild(node);\n                    return;\n                }\n                collectNode(node);\n            }\n            var c = node.childNodes;\n            if (c && c.length) removeOrphanedChildren(c, unmountOnly);\n        }\n    }\n    function diffAttributes(dom, vnode) {\n        var old = getNodeAttributes(dom) || EMPTY, attrs = vnode.attributes || EMPTY, name = void 0, value = void 0;\n        for (name in old) if (empty(attrs[name])) setAccessor(dom, name, null);\n        if (attrs !== EMPTY) for (name in attrs) if (hasOwnProperty.call(attrs, name)) {\n            value = attrs[name];\n            if (!empty(value) && value != getAccessor(dom, name)) setAccessor(dom, name, value);\n        }\n    }\n    function collectComponent(component) {\n        var name = component.constructor.name, list = components[name];\n        if (list) list.push(component); else components[name] = [ component ];\n    }\n    function createComponent(ctor, props, context) {\n        var list = components[ctor.name], len = list && list.length, c = void 0;\n        for (var i = 0; len > i; i++) {\n            c = list[i];\n            if (c.constructor === ctor) {\n                list.splice(i, 1);\n                return c;\n            }\n        }\n        return new ctor(props, context);\n    }\n    function triggerComponentRender(component) {\n        if (!component._dirty) {\n            component._dirty = !0;\n            enqueueRender(component);\n        }\n    }\n    function setComponentProps(component, props, opts, context) {\n        var d = component._disableRendering;\n        component._ref = props.ref;\n        delete props.ref;\n        delete props.key;\n        component._disableRendering = !0;\n        if (context) {\n            if (!component.prevContext) component.prevContext = component.context;\n            component.context = context;\n        }\n        if (component.base) hook(component, 'componentWillReceiveProps', props, component.context);\n        if (!component.prevProps) component.prevProps = component.props;\n        component.props = props;\n        component._disableRendering = d;\n        if (!opts || opts.render !== !1) if (opts && opts.renderSync || options.syncComponentUpdates !== !1) renderComponent(component); else triggerComponentRender(component);\n        hook(component, '_ref', component);\n    }\n    function renderComponent(component, opts) {\n        if (!component._disableRendering) {\n            var skip = void 0, rendered = void 0, props = component.props, state = component.state, context = component.context, previousProps = component.prevProps || props, previousState = component.prevState || state, previousContext = component.prevContext || context, isUpdate = component.base;\n            if (isUpdate) {\n                component.props = previousProps;\n                component.state = previousState;\n                component.context = previousContext;\n                if (hook(component, 'shouldComponentUpdate', props, state, context) === !1) skip = !0; else hook(component, 'componentWillUpdate', props, state, context);\n                component.props = props;\n                component.state = state;\n                component.context = context;\n            }\n            component.prevProps = component.prevState = component.prevContext = null;\n            component._dirty = !1;\n            if (!skip) {\n                rendered = hook(component, 'render', props, state, context);\n                var childComponent = rendered && rendered.nodeName, childContext = component.getChildContext ? component.getChildContext() : context, toUnmount = void 0, base = void 0;\n                if (isFunction(childComponent) && childComponent.prototype.render) {\n                    var inst = component._component;\n                    if (inst && inst.constructor !== childComponent) {\n                        toUnmount = inst;\n                        inst = null;\n                    }\n                    var childProps = getNodeProps(rendered);\n                    if (inst) setComponentProps(inst, childProps, SYNC_RENDER, childContext); else {\n                        inst = createComponent(childComponent, childProps, childContext);\n                        inst._parentComponent = component;\n                        component._component = inst;\n                        if (component.base) deepHook(inst, 'componentWillMount');\n                        setComponentProps(inst, childProps, NO_RENDER, childContext);\n                        renderComponent(inst, DOM_RENDER);\n                        if (component.base) deepHook(inst, 'componentDidMount');\n                    }\n                    base = inst.base;\n                } else {\n                    var cbase = component.base;\n                    toUnmount = component._component;\n                    if (toUnmount) cbase = component._component = null;\n                    if (component.base || opts && opts.build) base = diff(cbase, rendered || EMPTY_BASE, childContext);\n                }\n                if (component.base && base !== component.base) {\n                    var p = component.base.parentNode;\n                    if (p) p.replaceChild(base, component.base);\n                }\n                if (toUnmount) unmountComponent(toUnmount.base, toUnmount, !0);\n                component.base = base;\n                if (base) {\n                    var componentRef = component, t = component;\n                    for (;t = t._parentComponent; ) componentRef = t;\n                    base._component = componentRef;\n                    base._componentConstructor = componentRef.constructor;\n                }\n                if (isUpdate) hook(component, 'componentDidUpdate', previousProps, previousState, previousContext);\n            }\n            var cb = component._renderCallbacks, fn = void 0;\n            if (cb) for (;fn = cb.pop(); ) fn.call(component);\n            return rendered;\n        }\n    }\n    function buildComponentFromVNode(dom, vnode, context) {\n        var c = dom && dom._component, oldDom = dom;\n        var isOwner = c && dom._componentConstructor === vnode.nodeName;\n        for (;c && !isOwner && (c = c._parentComponent); ) isOwner = c.constructor === vnode.nodeName;\n        if (isOwner) {\n            setComponentProps(c, getNodeProps(vnode), SYNC_RENDER, context);\n            dom = c.base;\n        } else {\n            if (c) {\n                unmountComponent(dom, c, !0);\n                dom = oldDom = null;\n            }\n            dom = createComponentFromVNode(vnode, dom, context);\n            if (oldDom && dom !== oldDom) recollectNodeTree(oldDom);\n        }\n        return dom;\n    }\n    function createComponentFromVNode(vnode, dom, context) {\n        var props = getNodeProps(vnode);\n        var component = createComponent(vnode.nodeName, props, context);\n        if (dom && !component.base) component.base = dom;\n        setComponentProps(component, props, NO_RENDER, context);\n        renderComponent(component, DOM_RENDER);\n        return component.base;\n    }\n    function unmountComponent(dom, component, remove) {\n        hook(component, '_ref', null);\n        hook(component, 'componentWillUnmount');\n        var inner = component._component;\n        if (inner) unmountComponent(dom, inner);\n        var base = component.base;\n        if (base) {\n            if (remove !== !1) {\n                var p = base.parentNode;\n                if (p) p.removeChild(base);\n            }\n            removeOrphanedChildren(base.childNodes, !0);\n        }\n        if (remove) {\n            component._parentComponent = null;\n            collectComponent(component);\n        }\n        hook(component, 'componentDidUnmount');\n    }\n    function Component(props, context) {\n        this._dirty = this._disableRendering = !1;\n        this._linkedStates = {};\n        this._renderCallbacks = [];\n        this.prevState = this.prevProps = this.prevContext = this.base = this._parentComponent = this._component = this._ref = null;\n        this.context = context || {};\n        this.props = props || {};\n        this.state = hook(this, 'getInitialState') || {};\n    }\n    function render(vnode, parent, merge) {\n        var existing = merge && merge._component && merge._componentConstructor === vnode.nodeName, built = diff(merge, vnode), c = !existing && built._component;\n        if (c) deepHook(c, 'componentWillMount');\n        if (built.parentNode !== parent) parent.appendChild(built);\n        if (c) deepHook(c, 'componentDidMount');\n        return built;\n    }\n    var NO_RENDER = {\n        render: !1\n    };\n    var SYNC_RENDER = {\n        renderSync: !0\n    };\n    var DOM_RENDER = {\n        build: !0\n    };\n    var EMPTY = {};\n    var EMPTY_BASE = '';\n    var HAS_DOM = 'undefined' != typeof document;\n    var TEXT_CONTENT = !HAS_DOM || 'textContent' in document ? 'textContent' : 'nodeValue';\n    var ATTR_KEY = 'undefined' != typeof Symbol ? Symbol('preactattr') : '__preactattr_';\n    var UNDEFINED_ELEMENT = 'undefined';\n    var NON_DIMENSION_PROPS = {\n        boxFlex: 1,\n        boxFlexGroup: 1,\n        columnCount: 1,\n        fillOpacity: 1,\n        flex: 1,\n        flexGrow: 1,\n        flexPositive: 1,\n        flexShrink: 1,\n        flexNegative: 1,\n        fontWeight: 1,\n        lineClamp: 1,\n        lineHeight: 1,\n        opacity: 1,\n        order: 1,\n        orphans: 1,\n        strokeOpacity: 1,\n        widows: 1,\n        zIndex: 1,\n        zoom: 1\n    };\n    var isFunction = function(obj) {\n        return 'function' == typeof obj;\n    };\n    var isString = function(obj) {\n        return 'string' == typeof obj;\n    };\n    var hasOwnProperty = {}.hasOwnProperty;\n    var empty = function(x) {\n        return null == x;\n    };\n    var falsey = function(value) {\n        return value === !1 || null == value;\n    };\n    var jsToCss = memoize(function(s) {\n        return s.replace(/([A-Z])/g, '-$1').toLowerCase();\n    });\n    var toLowerCase = memoize(function(s) {\n        return s.toLowerCase();\n    });\n    var ch = void 0;\n    try {\n        ch = new MessageChannel();\n    } catch (e) {}\n    var setImmediate = ch ? function(f) {\n        ch.port1.onmessage = f;\n        ch.port2.postMessage('');\n    } : setTimeout;\n    var options = {\n        vnode: function(n) {\n            var attrs = n.attributes;\n            if (attrs && !isFunction(n.nodeName)) {\n                var p = attrs.className;\n                if (p) {\n                    attrs['class'] = p;\n                    delete attrs.className;\n                }\n                if (attrs['class']) normalize(attrs, 'class', hashToClassName);\n                if (attrs.style) normalize(attrs, 'style', styleObjToCss);\n            }\n        }\n    };\n    var SHARED_TEMP_ARRAY = [];\n    var items = [];\n    var itemsOffline = [];\n    var normalizeEventName = memoize(function(t) {\n        return t.replace(/^on/i, '').toLowerCase();\n    });\n    var nodes = {};\n    var normalizeName = memoize(function(name) {\n        return name.toUpperCase();\n    });\n    var components = {};\n    extend(Component.prototype, {\n        linkState: function(key, eventPath) {\n            var c = this._linkedStates, cacheKey = key + '|' + (eventPath || '');\n            return c[cacheKey] || (c[cacheKey] = createLinkedState(this, key, eventPath));\n        },\n        setState: function(state, callback) {\n            var s = this.state;\n            if (!this.prevState) this.prevState = clone(s);\n            extend(s, isFunction(state) ? state(s, this.props) : state);\n            if (callback) this._renderCallbacks.push(callback);\n            triggerComponentRender(this);\n        },\n        forceUpdate: function() {\n            renderComponent(this);\n        },\n        render: function() {\n            return null;\n        }\n    });\n    var preact = {\n        h: h,\n        Component: Component,\n        render: render,\n        rerender: rerender,\n        options: options,\n        hooks: options\n    };\n    return preact;\n});\n//# sourceMappingURL=preact.js.map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/preact/dist/preact.js\n ** module id = 1\n ** module chunks = 0\n **/","// shim for using process in browser\n\nvar process = module.exports = {};\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = setTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    clearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        setTimeout(drainQueue, 0);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/process/browser.js\n ** module id = 2\n ** module chunks = 0\n **/","var nextTick = require('process/browser.js').nextTick;\nvar apply = Function.prototype.apply;\nvar slice = Array.prototype.slice;\nvar immediateIds = {};\nvar nextImmediateId = 0;\n\n// DOM APIs, for completeness\n\nexports.setTimeout = function() {\n  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);\n};\nexports.setInterval = function() {\n  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);\n};\nexports.clearTimeout =\nexports.clearInterval = function(timeout) { timeout.close(); };\n\nfunction Timeout(id, clearFn) {\n  this._id = id;\n  this._clearFn = clearFn;\n}\nTimeout.prototype.unref = Timeout.prototype.ref = function() {};\nTimeout.prototype.close = function() {\n  this._clearFn.call(window, this._id);\n};\n\n// Does not start the time, just sets up the members needed.\nexports.enroll = function(item, msecs) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = msecs;\n};\n\nexports.unenroll = function(item) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = -1;\n};\n\nexports._unrefActive = exports.active = function(item) {\n  clearTimeout(item._idleTimeoutId);\n\n  var msecs = item._idleTimeout;\n  if (msecs >= 0) {\n    item._idleTimeoutId = setTimeout(function onTimeout() {\n      if (item._onTimeout)\n        item._onTimeout();\n    }, msecs);\n  }\n};\n\n// That's not how node.js implements it but the exposed api is the same.\nexports.setImmediate = typeof setImmediate === \"function\" ? setImmediate : function(fn) {\n  var id = nextImmediateId++;\n  var args = arguments.length < 2 ? false : slice.call(arguments, 1);\n\n  immediateIds[id] = true;\n\n  nextTick(function onNextTick() {\n    if (immediateIds[id]) {\n      // fn.call() is faster so we optimize for the common use-case\n      // @see http://jsperf.com/call-apply-segu\n      if (args) {\n        fn.apply(null, args);\n      } else {\n        fn.call(null);\n      }\n      // Prevent ids from leaking\n      exports.clearImmediate(id);\n    }\n  });\n\n  return id;\n};\n\nexports.clearImmediate = typeof clearImmediate === \"function\" ? clearImmediate : function(id) {\n  delete immediateIds[id];\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/timers-browserify/main.js\n ** module id = 3\n ** module chunks = 0\n **/","export function uuid() {\n\tlet uuid = '';\n\tfor (let i=0; i<32; i++) {\n\t\tlet random = Math.random() * 16 | 0;\n\t\tif (i === 8 || i === 12 || i === 16 || i === 20) {\n\t\t\tuuid += '-';\n\t\t}\n\t\tuuid += (i === 12 ? 4 : (i === 16 ? (random & 3 | 8) : random)).toString(16);\n\t}\n\treturn uuid;\n}\n\nexport function pluralize(count, word) {\n\treturn count === 1 ? word : word + 's';\n}\n\nexport function store(namespace, data) {\n\tif (data) {\n\t\treturn localStorage.setItem(namespace, JSON.stringify(data));\n\t}\n\n\tlet store = localStorage.getItem(namespace);\n\treturn (store && JSON.parse(store)) || [];\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/app/util.js\n **/","(function(global,factory){if(typeof define === 'function' && define.amd){define(['exports'],factory);}else if(typeof exports !== 'undefined'){factory(exports);}else {var mod={exports:{}};factory(mod.exports);global.decko = mod.exports;}})(this,function(exports){'use strict';exports.__esModule = true;var EMPTY={};var HOP=Object.prototype.hasOwnProperty;var fns={memoize:function memoize(fn){var opt=arguments.length <= 1 || arguments[1] === undefined?EMPTY:arguments[1];var cache=opt.cache || {};return function(){for(var _len=arguments.length,a=Array(_len),_key=0;_key < _len;_key++) {a[_key] = arguments[_key];}var k=String(a[0]);if(opt.caseSensitive === false)k = k.toLowerCase();return HOP.call(cache,k)?cache[k]:cache[k] = fn.apply(this,a);};},debounce:function debounce(fn,opts){if(typeof opts === 'function'){var p=fn;fn = opts;opts = p;}var delay=opts && opts.delay || opts || 0,args=undefined,context=undefined,timer=undefined;return function(){for(var _len2=arguments.length,a=Array(_len2),_key2=0;_key2 < _len2;_key2++) {a[_key2] = arguments[_key2];}args = a;context = this;if(!timer)timer = setTimeout(function(){fn.apply(context,args);args = context = timer = null;},delay);};},bind:function bind(target,key,_ref){var fn=_ref.value;return {configurable:true,get:function get(){var value=fn.bind(this);Object.defineProperty(this,key,{value:value,configurable:true,writable:true});return value;}};}};var memoize=multiMethod(fns.memoize),debounce=multiMethod(fns.debounce),bind=multiMethod(function(f,c){return f.bind(c);},function(){return fns.bind;});exports.memoize = memoize;exports.debounce = debounce;exports.bind = bind;exports['default'] = {memoize:memoize,debounce:debounce,bind:bind};function multiMethod(inner,deco){deco = deco || inner.decorate || decorator(inner);var d=deco();return function(){for(var _len3=arguments.length,args=Array(_len3),_key3=0;_key3 < _len3;_key3++) {args[_key3] = arguments[_key3];}var l=args.length;return (l < 2?deco:l > 2?d:inner).apply(undefined,args);};}function decorator(fn){return function(opt){return typeof opt === 'function'?fn(opt):function(target,key,desc){desc.value = fn(desc.value,opt,target,key,desc);};};}});\n\n//# sourceMappingURL=decko.js.map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/decko/decko.js\n ** module id = 5\n ** module chunks = 0\n **/","(function (global, factory) {\n\ttypeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory(require('preact')) :\n\ttypeof define === 'function' && define.amd ? define(['preact'], factory) :\n\t(global.preactRouter = factory(global.preact));\n}(this, function (preact) { 'use strict';\n\n\tvar babelHelpers = {};\n\n\tbabelHelpers.inherits = function (subClass, superClass) {\n\t  if (typeof superClass !== \"function\" && superClass !== null) {\n\t    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n\t  }\n\n\t  subClass.prototype = Object.create(superClass && superClass.prototype, {\n\t    constructor: {\n\t      value: subClass,\n\t      enumerable: false,\n\t      writable: true,\n\t      configurable: true\n\t    }\n\t  });\n\t  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n\t};\n\n\tbabelHelpers.objectWithoutProperties = function (obj, keys) {\n\t  var target = {};\n\n\t  for (var i in obj) {\n\t    if (keys.indexOf(i) >= 0) continue;\n\t    if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;\n\t    target[i] = obj[i];\n\t  }\n\n\t  return target;\n\t};\n\n\tbabelHelpers._extends = Object.assign || function (target) {\n\t  for (var i = 1; i < arguments.length; i++) {\n\t    var source = arguments[i];\n\n\t    for (var key in source) {\n\t      if (Object.prototype.hasOwnProperty.call(source, key)) {\n\t        target[key] = source[key];\n\t      }\n\t    }\n\t  }\n\n\t  return target;\n\t};\n\n\tbabelHelpers.classCallCheck = function (instance, Constructor) {\n\t  if (!(instance instanceof Constructor)) {\n\t    throw new TypeError(\"Cannot call a class as a function\");\n\t  }\n\t};\n\tvar EMPTY$1 = {};\n\n\tfunction exec(url, route) {\n\t\tvar opts = arguments.length <= 2 || arguments[2] === undefined ? EMPTY$1 : arguments[2];\n\n\t\tvar reg = /(?:\\?([^#]*))?(#.*)?$/,\n\t\t    c = url.match(reg),\n\t\t    matches = {},\n\t\t    ret = undefined;\n\t\tif (c && c[1]) {\n\t\t\tvar p = c[1].split('&');\n\t\t\tfor (var i = 0; i < p.length; i++) {\n\t\t\t\tvar r = p[i].split('=');\n\t\t\t\tmatches[decodeURIComponent(r[0])] = decodeURIComponent(r.slice(1).join('='));\n\t\t\t}\n\t\t}\n\t\turl = segmentize(url.replace(reg, ''));\n\t\troute = segmentize(route || '');\n\t\tvar max = Math.max(url.length, route.length);\n\t\tfor (var i = 0; i < max; i++) {\n\t\t\tif (route[i] && route[i].charAt(0) === ':') {\n\t\t\t\tvar param = route[i].replace(/(^\\:|[+*?]+$)/g, ''),\n\t\t\t\t    flags = (route[i].match(/[+*?]+$/) || EMPTY$1)[0] || '',\n\t\t\t\t    plus = ~flags.indexOf('+'),\n\t\t\t\t    star = ~flags.indexOf('*'),\n\t\t\t\t    val = url[i] || '';\n\t\t\t\tif (!val && !star && (flags.indexOf('?') < 0 || plus)) {\n\t\t\t\t\tret = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tmatches[param] = decodeURIComponent(val);\n\t\t\t\tif (plus || star) {\n\t\t\t\t\tmatches[param] = url.slice(i).map(decodeURIComponent).join('/');\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (route[i] !== url[i]) {\n\t\t\t\t\tret = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (opts['default'] !== true && ret === false) return false;\n\t\treturn matches;\n\t}\n\n\tfunction pathRankSort(a, b) {\n\t\tvar aAttr = a.attributes || EMPTY$1,\n\t\t    bAttr = b.attributes || EMPTY$1;\n\t\tif (aAttr['default']) return 1;\n\t\tif (bAttr['default']) return -1;\n\t\tvar diff = rank(aAttr.path) - rank(bAttr.path);\n\t\treturn diff || aAttr.path.length - bAttr.path.length;\n\t}\n\n\tfunction segmentize(url) {\n\t\treturn strip(url).split('/');\n\t}\n\n\tfunction rank(url) {\n\t\treturn (strip(url).match(/\\/+/g) || '').length;\n\t}\n\n\tfunction strip(url) {\n\t\treturn url.replace(/(^\\/+|\\/+$)/g, '');\n\t}\n\n\tvar routers = [];\n\n\tvar EMPTY = {};\n\n\tfunction route(url) {\n\t\tvar replace = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];\n\n\t\tif (typeof url !== 'string' && url.url) {\n\t\t\treplace = url.replace;\n\t\t\turl = url.url;\n\t\t}\n\t\tif (history) {\n\t\t\tif (replace === true) {\n\t\t\t\thistory.replaceState(null, null, url);\n\t\t\t} else {\n\t\t\t\thistory.pushState(null, null, url);\n\t\t\t}\n\t\t}\n\t\trouteTo(url);\n\t}\n\n\tfunction routeTo(url) {\n\t\trouters.forEach(function (router) {\n\t\t\treturn router.routeTo(url);\n\t\t});\n\t}\n\n\tfunction getCurrentUrl() {\n\t\tvar url = typeof location !== 'undefined' ? location : EMPTY;\n\t\treturn '' + (url.pathname || '') + (url.search || '');\n\t}\n\n\tif (typeof addEventListener === 'function') {\n\t\taddEventListener('popstate', function () {\n\t\t\treturn routeTo(getCurrentUrl());\n\t\t});\n\t}\n\n\tfunction handleLinkClick(e) {\n\t\troute(this.getAttribute('href'));\n\t\tif (e.stopImmediatePropagation) e.stopImmediatePropagation();\n\t\te.stopPropagation();\n\t\te.preventDefault();\n\t\treturn false;\n\t}\n\n\tvar Link = function Link(_ref) {\n\t\tvar children = _ref.children;\n\t\tvar props = babelHelpers.objectWithoutProperties(_ref, ['children']);\n\t\treturn preact.h(\n\t\t\t'a',\n\t\t\tbabelHelpers._extends({}, props, { onClick: handleLinkClick }),\n\t\t\tchildren\n\t\t);\n\t};\n\n\tvar Router = (function (_Component) {\n\t\tbabelHelpers.inherits(Router, _Component);\n\n\t\tfunction Router() {\n\t\t\tbabelHelpers.classCallCheck(this, Router);\n\n\t\t\t_Component.apply(this, arguments);\n\t\t}\n\n\t\tRouter.prototype.getInitialState = function getInitialState() {\n\t\t\treturn { url: getCurrentUrl() };\n\t\t};\n\n\t\tRouter.prototype.routeTo = function routeTo(url) {\n\t\t\tthis.setState({ url: url });\n\t\t};\n\n\t\tRouter.prototype.componentWillMount = function componentWillMount() {\n\t\t\trouters.push(this);\n\t\t};\n\n\t\tRouter.prototype.componentWillUnmount = function componentWillUnmount() {\n\t\t\trouters.splice(routers.indexOf(this), 1);\n\t\t};\n\n\t\tRouter.prototype.render = function render(_ref2, _ref3) {\n\t\t\tvar children = _ref2.children;\n\t\t\tvar onChange = _ref2.onChange;\n\t\t\tvar url = _ref3.url;\n\n\t\t\tvar active = children.slice().sort(pathRankSort).filter(function (_ref4) {\n\t\t\t\tvar attributes = _ref4.attributes;\n\n\t\t\t\tvar path = attributes.path,\n\t\t\t\t    matches = exec(url, path, attributes);\n\t\t\t\tif (matches) {\n\t\t\t\t\tattributes.url = url;\n\t\t\t\t\tattributes.matches = matches;\n\t\t\t\t\t// copy matches onto props\n\t\t\t\t\tfor (var i in matches) {\n\t\t\t\t\t\tif (matches.hasOwnProperty(i)) {\n\t\t\t\t\t\t\tattributes[i] = matches[i];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t});\n\t\t\tvar previous = this.previousUrl;\n\t\t\tif (url !== previous) {\n\t\t\t\tthis.previousUrl = url;\n\t\t\t\tif (typeof onChange === 'function') {\n\t\t\t\t\tonChange({\n\t\t\t\t\t\trouter: this,\n\t\t\t\t\t\turl: url,\n\t\t\t\t\t\tprevious: previous,\n\t\t\t\t\t\tactive: active,\n\t\t\t\t\t\tcurrent: active[0]\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn active[0] || null;\n\t\t};\n\n\t\treturn Router;\n\t})(preact.Component);\n\n\tvar Route = function Route(_ref5) {\n\t\tvar RoutedComponent = _ref5.component;\n\t\tvar url = _ref5.url;\n\t\tvar matches = _ref5.matches;\n\t\treturn preact.h(RoutedComponent, { url: url, matches: matches });\n\t};\n\n\tRouter.route = route;\n\tRouter.Router = Router;\n\tRouter.Route = Route;\n\tRouter.Link = Link;\n\n\treturn Router;\n\n}));\n//# sourceMappingURL=preact-router.js.map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/preact-router/dist/preact-router.js\n ** module id = 6\n ** module chunks = 0\n **/","'use strict';\n\nmodule.exports = argsArray;\n\nfunction argsArray(fun) {\n  return function () {\n    var len = arguments.length;\n    if (len) {\n      var args = [];\n      var i = -1;\n      while (++i < len) {\n        args[i] = arguments[i];\n      }\n      return fun.call(this, args);\n    } else {\n      return fun.call(this, []);\n    }\n  };\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/argsarray/index.js\n ** module id = 7\n ** module chunks = 0\n **/","import { h, Component } from 'preact';\nimport { Link } from 'preact-router';\nimport { pluralize } from './util';\n\nconst ALL_TODOS = 'all';\nconst ACTIVE_TODOS = 'active';\nconst COMPLETED_TODOS = 'completed';\n\nexport default class TodoFooter extends Component {\n\trender({ nowShowing, count, completedCount, onClearCompleted }) {\n\t\treturn (\n\t\t\t<footer class=\"footer\">\n\t\t\t\t<span class=\"todo-count\">\n\t\t\t\t\t<strong>{count}</strong> {pluralize(count, 'item')} left\n\t\t\t\t</span>\n\t\t\t\t<ul class=\"filters\">\n\t\t\t\t\t<li>\n\t\t\t\t\t\t<Link href=\"/\" class={{ selected: nowShowing===ALL_TODOS }}>All</Link>\n\t\t\t\t\t</li>\n\t\t\t\t\t&nbsp;\n\t\t\t\t\t<li>\n\t\t\t\t\t\t<Link href=\"/active\" class={{ selected: nowShowing===ACTIVE_TODOS }}>Active</Link>\n\t\t\t\t\t</li>\n\t\t\t\t\t&nbsp;\n\t\t\t\t\t<li>\n\t\t\t\t\t\t<Link href=\"/completed\" class={{ selected: nowShowing===COMPLETED_TODOS }}>Completed</Link>\n\t\t\t\t\t</li>\n\t\t\t\t</ul>\n\t\t\t\t{ completedCount > 0 ? (\n\t\t\t\t\t<button class=\"clear-completed\" onClick={onClearCompleted}>\n\t\t\t\t\t\tClear completed\n\t\t\t\t\t</button>\n\t\t\t\t) : null }\n\t\t\t</footer>\n\t\t);\n\t}\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/app/footer.js\n **/","import { h, render, Component } from 'preact';\nimport { Router } from 'preact-router';\nimport { bind } from 'decko';\nimport TodoModel from './model';\nimport TodoFooter from './footer';\nimport TodoItem from './item';\n\n// You'll need couchdb or pouchdb-server running.\n// see : https://pouchdb.com/guides/setup-couchdb.html#installing-couchdb\nconst REMOTE_DB_URL = 'http://localhost:5984/todos';\n\nconst ENTER_KEY = 13;\n\nconst ALL_TODOS = 'all';\nconst ACTIVE_TODOS = 'active';\nconst COMPLETED_TODOS = 'completed';\n\nconst FILTERS = {\n\t[ALL_TODOS]: todo => true,\n\t[ACTIVE_TODOS]: todo => !todo.completed,\n\t[COMPLETED_TODOS]: todo => todo.completed\n};\n\nexport default class App extends Component {\n\tstate = { nowShowing: ALL_TODOS };\n\n\tconstructor() {\n\t\tsuper();\n\t\tthis.model = new TodoModel(REMOTE_DB_URL);\n\t\tthis.model.subscribe( () => this.setState({}) );\n\t}\n\n\t@bind\n\thandleRoute({ url }) {\n\t\tlet nowShowing = url.replace(/\\/$/,'').split('/').pop();\n\t\tif (!FILTERS[nowShowing]) {\n\t\t\tnowShowing = ALL_TODOS;\n\t\t}\n\t\tthis.setState({ nowShowing });\n\t}\n\n\t@bind\n\thandleNewTodoKeyDown(e) {\n\t\tif (e.keyCode!==ENTER_KEY) return;\n\t\te.preventDefault();\n\n\t\tlet val = this.state.newTodo.trim();\n\t\tif (val) {\n\t\t\tthis.model.addTodo(val);\n\t\t\tthis.setState({ newTodo: '' });\n\t\t}\n\t}\n\n\t@bind\n\ttoggleAll(event) {\n\t\tlet checked = event.target.checked;\n\t\tthis.model.toggleAll(checked);\n\t}\n\n\t@bind\n\ttoggle(todoToToggle) {\n\t\tthis.model.toggle(todoToToggle);\n\t}\n\n\t@bind\n\tdestroy(todo) {\n\t\tthis.model.destroy(todo);\n\t}\n\n\t@bind\n\tedit(todo) {\n\t\tthis.setState({ editing: todo._id });\n\t}\n\n\t@bind\n\tsave(todoToSave, text) {\n\t\tthis.model.save(todoToSave, text);\n\t\tthis.setState({ editing: null });\n\t}\n\n\t@bind\n\tcancel() {\n\t\tthis.setState({ editing: null });\n\t}\n\n\t@bind\n\tclearCompleted() {\n\t\tthis.model.clearCompleted();\n\t}\n\n\trender({ }, { nowShowing=ALL_TODOS, newTodo, editing }) {\n\t\tlet { todos } = this.model,\n\t\t\tshownTodos = todos.filter( FILTERS[nowShowing] ),\n\t\t\tactiveTodoCount = todos.reduce( (a, todo) => a + (todo.completed ? 0 : 1), 0),\n\t\t\tcompletedCount = todos.length - activeTodoCount;\n\n\t\treturn (\n\t\t\t<div>\n\t\t\t\t<Router onChange={this.handleRoute}><Noop path=\"/\" /></Router>\n\n\t\t\t\t<header class=\"header\">\n\t\t\t\t\t<h1>todos</h1>\n\t\t\t\t\t<input\n\t\t\t\t\t\tclass=\"new-todo\"\n\t\t\t\t\t\tplaceholder=\"What needs to be done?\"\n\t\t\t\t\t\tvalue={newTodo}\n\t\t\t\t\t\tonKeyDown={this.handleNewTodoKeyDown}\n\t\t\t\t\t\tonInput={this.linkState('newTodo')}\n\t\t\t\t\t\tautoFocus={true}\n\t\t\t\t\t/>\n\t\t\t\t</header>\n\n\t\t\t\t{ todos.length ? (\n\t\t\t\t\t<section class=\"main\">\n\t\t\t\t\t\t<input\n\t\t\t\t\t\t\tclass=\"toggle-all\"\n\t\t\t\t\t\t\ttype=\"checkbox\"\n\t\t\t\t\t\t\tonChange={this.toggleAll}\n\t\t\t\t\t\t\tchecked={activeTodoCount === 0}\n\t\t\t\t\t\t/>\n\t\t\t\t\t\t<ul class=\"todo-list\">\n\t\t\t\t\t\t\t{ shownTodos.map( todo => (\n\t\t\t\t\t\t\t\t<TodoItem\n\t\t\t\t\t\t\t\t\ttodo={todo}\n\t\t\t\t\t\t\t\t\tonToggle={this.toggle.bind(this, todo)}\n\t\t\t\t\t\t\t\t\tonDestroy={this.destroy.bind(this, todo)}\n\t\t\t\t\t\t\t\t\tonEdit={this.edit.bind(this, todo)}\n\t\t\t\t\t\t\t\t\tediting={editing === todo._id}\n\t\t\t\t\t\t\t\t\tonSave={this.save.bind(this, todo)}\n\t\t\t\t\t\t\t\t\tonCancel={this.cancel}\n\t\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t\t)) }\n\t\t\t\t\t\t</ul>\n\t\t\t\t\t</section>\n\t\t\t\t) : null }\n\n\t\t\t\t{ (activeTodoCount || completedCount) ? (\n\t\t\t\t\t<TodoFooter\n\t\t\t\t\t\tcount={activeTodoCount}\n\t\t\t\t\t\tcompletedCount={completedCount}\n\t\t\t\t\t\tnowShowing={nowShowing}\n\t\t\t\t\t\tonClearCompleted={this.clearCompleted}\n\t\t\t\t\t/>\n\t\t\t\t) : null }\n\t\t\t</div>\n\t\t);\n\t}\n}\n\n\n// just a fake component we can feed to router. yay.\nclass Noop extends Component {\n\trender() {\n\t\treturn null;\n\t}\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/app/index.js\n **/","import { h, Component } from 'preact';\nimport { bind } from 'decko';\n\nconst ESCAPE_KEY = 27;\nconst ENTER_KEY = 13;\n\nexport default class TodoItem extends Component {\n\t@bind\n\thandleSubmit() {\n\t\tlet val = this.state.editText.trim();\n\t\tif (val) {\n\t\t\tthis.props.onSave(val);\n\t\t\tthis.setState({ editText: val });\n\t\t}\n\t\telse {\n\t\t\tthis.props.onDestroy();\n\t\t}\n\t}\n\n\t@bind\n\thandleEdit() {\n\t\tthis.props.onEdit();\n\t\tthis.setState({ editText: this.props.todo.title });\n\t}\n\n\t@bind\n\ttoggle(e) {\n\t\tthis.props.onToggle();\n\t\te.preventDefault();\n\t}\n\n\t@bind\n\thandleKeyDown(e) {\n\t\tif (e.which===ESCAPE_KEY) {\n\t\t\tthis.setState({ editText: this.props.todo.title });\n\t\t\tthis.props.onCancel(e);\n\t\t}\n\t\telse if (e.which===ENTER_KEY) {\n\t\t\tthis.handleSubmit(e);\n\t\t}\n\t}\n\n\t// shouldComponentUpdate({ todo, editing, editText }) {\n\t// \treturn (\n\t// \t\ttodo !== this.props.todo ||\n\t// \t\tediting !== this.props.editing ||\n\t// \t\teditText !== this.state.editText\n\t// \t);\n\t// }\n\n\tcomponentDidUpdate({ editing }) {\n\t\tlet node = this.base && this.base.querySelector('.edit');\n\t\tif (node) node.focus();\n\t}\n\n\trender({ todo:{ title, completed }, onToggle, onDestroy, editing }, { editText }) {\n\t\treturn (\n\t\t\t<li class={{ completed, editing }}>\n\t\t\t\t<div class=\"view\">\n\t\t\t\t\t<input\n\t\t\t\t\t\tclass=\"toggle\"\n\t\t\t\t\t\ttype=\"checkbox\"\n\t\t\t\t\t\tchecked={completed || 0}\n\t\t\t\t\t\tonClick={this.toggle}\n\t\t\t\t\t/>\n\t\t\t\t\t<label onDblClick={this.handleEdit}>{title}</label>\n\t\t\t\t\t<button class=\"destroy\" onClick={onDestroy} />\n\t\t\t\t</div>\n\t\t\t\t<input\n\t\t\t\t\tclass=\"edit\"\n\t\t\t\t\tvalue={editing && editText || title}\n\t\t\t\t\tonBlur={this.handleSubmit}\n\t\t\t\t\tonChange={this.linkState('editText')}\n\t\t\t\t\tonKeyDown={this.handleKeyDown}\n\t\t\t\t/>\n\t\t\t</li>\n\t\t);\n\t}\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/app/item.js\n **/","import { uuid, store } from './util';\nimport PouchDB from 'pouchdb';\n\nexport default class TodoModel {\n  constructor(remoteDBURL) {\n    var self = this;\n\n    this.remoteDBURL = remoteDBURL;\n    this.todos = [];\n    this.onChanges = [];\n    \n    // init\n    this.localDB = new PouchDB('todos');\n    this.localDB.changes({\n      since: 'now',\n      live: true\n    }).on('change', function () {\n      // something change\n      console.log('localDB.change');\n      self.draw();\n      self.syncAndDraw();\n    }).on('error', function (err) {\n      // totally unhandled error (shouldn't happen)\n      console.log('localDB.error : ', err);\n    });\n    \n    // draw with localDB\n    this.draw();\n    \n    // then sync with remoteDB\n    this.remoteDB = new PouchDB(this.remoteDBURL);\n    this.syncAndDraw();\n  }\n\n  draw() {\n    var self = this;\n    this.localDB.allDocs({ include_docs: true, descending: true }, function (err, doc) {\n      var next_todos = doc.rows.map(todo => todo.doc);\n      // TODO : dirty check\n      self.todos = next_todos;\n      self.publish();\n    });\n  }\n\n  subscribe(fn) {\n    this.onChanges.push(fn);\n  }\n\n  publish() {\n    this.onChanges.forEach(cb => cb());\n  }\n  \n  syncAndDraw() {\n    var self = this;\n    // sync with remote\n    this.localDB.sync(this.remoteDB).on('change', function () {\n      // something change\n      console.log('remoteDB.change');\n      self.draw();\n    }).on('remoteDB.paused', function (info) {\n      // replication was paused, usually because of a lost connection\n      console.log('remoteDB.paused : ', info);\n    }).on('active', function (info) {\n      // replication was resumed\n      console.log('remoteDB.active : ', info);\n    }).on('error', function (err) {\n      // totally unhandled error (shouldn't happen)\n      console.log('remoteDB.error : ', err);\n    });\n  }\n\n  addTodo(title) {\n    var todo = {\n      \"_id\": new Date().toISOString(),\n      \"title\": title,\n      \"completed\": false\n    };\n\n    this.localDB.put(todo, function callback(err, result) {\n      if (!err) {\n        console.log('Successfully posted a todo!');\n      }\n    });\n  }\n\n  toggleAll(completed) {\n    this.todos = this.todos.map(\n      todo => ({ ...todo, completed })\n\t\t);\n\t\tthis.publish();\n\t}\n\n  toggle(todoToToggle) {\n    todoToToggle.completed = !todoToToggle.completed;\n    this.localDB.put(todoToToggle);\n  }\n\n  destroy(todo) {\n    this.localDB.remove(todo);\n  }\n\n  save(todoToSave, title) {\n    this.localDB.put(todoToSave);\n  }\n\n  clearCompleted() {\n    this.completed_todos = this.todos.filter(todo => {\n      todo.completed ? todo._deleted = true : false;\n      return todo.completed;\n    });\n    this.localDB.bulkDocs(this.completed_todos);\n  }\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/app/model.js\n **/","\n/**\n * This is the web browser implementation of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = require('./debug');\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = 'undefined' != typeof chrome\n               && 'undefined' != typeof chrome.storage\n                  ? chrome.storage.local\n                  : localstorage();\n\n/**\n * Colors.\n */\n\nexports.colors = [\n  'lightseagreen',\n  'forestgreen',\n  'goldenrod',\n  'dodgerblue',\n  'darkorchid',\n  'crimson'\n];\n\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n\nfunction useColors() {\n  // is webkit? http://stackoverflow.com/a/16459606/376773\n  return ('WebkitAppearance' in document.documentElement.style) ||\n    // is firebug? http://stackoverflow.com/a/398120/376773\n    (window.console && (console.firebug || (console.exception && console.table))) ||\n    // is firefox >= v31?\n    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n    (navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31);\n}\n\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */\n\nexports.formatters.j = function(v) {\n  return JSON.stringify(v);\n};\n\n\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */\n\nfunction formatArgs() {\n  var args = arguments;\n  var useColors = this.useColors;\n\n  args[0] = (useColors ? '%c' : '')\n    + this.namespace\n    + (useColors ? ' %c' : ' ')\n    + args[0]\n    + (useColors ? '%c ' : ' ')\n    + '+' + exports.humanize(this.diff);\n\n  if (!useColors) return args;\n\n  var c = 'color: ' + this.color;\n  args = [args[0], c, 'color: inherit'].concat(Array.prototype.slice.call(args, 1));\n\n  // the final \"%c\" is somewhat tricky, because there could be other\n  // arguments passed either before or after the %c, so we need to\n  // figure out the correct index to insert the CSS into\n  var index = 0;\n  var lastC = 0;\n  args[0].replace(/%[a-z%]/g, function(match) {\n    if ('%%' === match) return;\n    index++;\n    if ('%c' === match) {\n      // we only are interested in the *last* %c\n      // (the user may have provided their own)\n      lastC = index;\n    }\n  });\n\n  args.splice(lastC, 0, c);\n  return args;\n}\n\n/**\n * Invokes `console.log()` when available.\n * No-op when `console.log` is not a \"function\".\n *\n * @api public\n */\n\nfunction log() {\n  // this hackery is required for IE8/9, where\n  // the `console.log` function doesn't have 'apply'\n  return 'object' === typeof console\n    && console.log\n    && Function.prototype.apply.call(console.log, console, arguments);\n}\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\n\nfunction save(namespaces) {\n  try {\n    if (null == namespaces) {\n      exports.storage.removeItem('debug');\n    } else {\n      exports.storage.debug = namespaces;\n    }\n  } catch(e) {}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\n\nfunction load() {\n  var r;\n  try {\n    r = exports.storage.debug;\n  } catch(e) {}\n  return r;\n}\n\n/**\n * Enable namespaces listed in `localStorage.debug` initially.\n */\n\nexports.enable(load());\n\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */\n\nfunction localstorage(){\n  try {\n    return window.localStorage;\n  } catch (e) {}\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/debug/browser.js\n ** module id = 12\n ** module chunks = 0\n **/","\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = debug;\nexports.coerce = coerce;\nexports.disable = disable;\nexports.enable = enable;\nexports.enabled = enabled;\nexports.humanize = require('ms');\n\n/**\n * The currently active debug mode names, and names to skip.\n */\n\nexports.names = [];\nexports.skips = [];\n\n/**\n * Map of special \"%n\" handling functions, for the debug \"format\" argument.\n *\n * Valid key names are a single, lowercased letter, i.e. \"n\".\n */\n\nexports.formatters = {};\n\n/**\n * Previously assigned color.\n */\n\nvar prevColor = 0;\n\n/**\n * Previous log timestamp.\n */\n\nvar prevTime;\n\n/**\n * Select a color.\n *\n * @return {Number}\n * @api private\n */\n\nfunction selectColor() {\n  return exports.colors[prevColor++ % exports.colors.length];\n}\n\n/**\n * Create a debugger with the given `namespace`.\n *\n * @param {String} namespace\n * @return {Function}\n * @api public\n */\n\nfunction debug(namespace) {\n\n  // define the `disabled` version\n  function disabled() {\n  }\n  disabled.enabled = false;\n\n  // define the `enabled` version\n  function enabled() {\n\n    var self = enabled;\n\n    // set `diff` timestamp\n    var curr = +new Date();\n    var ms = curr - (prevTime || curr);\n    self.diff = ms;\n    self.prev = prevTime;\n    self.curr = curr;\n    prevTime = curr;\n\n    // add the `color` if not set\n    if (null == self.useColors) self.useColors = exports.useColors();\n    if (null == self.color && self.useColors) self.color = selectColor();\n\n    var args = Array.prototype.slice.call(arguments);\n\n    args[0] = exports.coerce(args[0]);\n\n    if ('string' !== typeof args[0]) {\n      // anything else let's inspect with %o\n      args = ['%o'].concat(args);\n    }\n\n    // apply any `formatters` transformations\n    var index = 0;\n    args[0] = args[0].replace(/%([a-z%])/g, function(match, format) {\n      // if we encounter an escaped % then don't increase the array index\n      if (match === '%%') return match;\n      index++;\n      var formatter = exports.formatters[format];\n      if ('function' === typeof formatter) {\n        var val = args[index];\n        match = formatter.call(self, val);\n\n        // now we need to remove `args[index]` since it's inlined in the `format`\n        args.splice(index, 1);\n        index--;\n      }\n      return match;\n    });\n\n    if ('function' === typeof exports.formatArgs) {\n      args = exports.formatArgs.apply(self, args);\n    }\n    var logFn = enabled.log || exports.log || console.log.bind(console);\n    logFn.apply(self, args);\n  }\n  enabled.enabled = true;\n\n  var fn = exports.enabled(namespace) ? enabled : disabled;\n\n  fn.namespace = namespace;\n\n  return fn;\n}\n\n/**\n * Enables a debug mode by namespaces. This can include modes\n * separated by a colon and wildcards.\n *\n * @param {String} namespaces\n * @api public\n */\n\nfunction enable(namespaces) {\n  exports.save(namespaces);\n\n  var split = (namespaces || '').split(/[\\s,]+/);\n  var len = split.length;\n\n  for (var i = 0; i < len; i++) {\n    if (!split[i]) continue; // ignore empty strings\n    namespaces = split[i].replace(/\\*/g, '.*?');\n    if (namespaces[0] === '-') {\n      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));\n    } else {\n      exports.names.push(new RegExp('^' + namespaces + '$'));\n    }\n  }\n}\n\n/**\n * Disable debug output.\n *\n * @api public\n */\n\nfunction disable() {\n  exports.enable('');\n}\n\n/**\n * Returns true if the given mode name is enabled, false otherwise.\n *\n * @param {String} name\n * @return {Boolean}\n * @api public\n */\n\nfunction enabled(name) {\n  var i, len;\n  for (i = 0, len = exports.skips.length; i < len; i++) {\n    if (exports.skips[i].test(name)) {\n      return false;\n    }\n  }\n  for (i = 0, len = exports.names.length; i < len; i++) {\n    if (exports.names[i].test(name)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Coerce `val`.\n *\n * @param {Mixed} val\n * @return {Mixed}\n * @api private\n */\n\nfunction coerce(val) {\n  if (val instanceof Error) return val.stack || val.message;\n  return val;\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/debug/debug.js\n ** module id = 13\n ** module chunks = 0\n **/","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nfunction EventEmitter() {\n  this._events = this._events || {};\n  this._maxListeners = this._maxListeners || undefined;\n}\nmodule.exports = EventEmitter;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nEventEmitter.defaultMaxListeners = 10;\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function(n) {\n  if (!isNumber(n) || n < 0 || isNaN(n))\n    throw TypeError('n must be a positive number');\n  this._maxListeners = n;\n  return this;\n};\n\nEventEmitter.prototype.emit = function(type) {\n  var er, handler, len, args, i, listeners;\n\n  if (!this._events)\n    this._events = {};\n\n  // If there is no 'error' event listener then throw.\n  if (type === 'error') {\n    if (!this._events.error ||\n        (isObject(this._events.error) && !this._events.error.length)) {\n      er = arguments[1];\n      if (er instanceof Error) {\n        throw er; // Unhandled 'error' event\n      }\n      throw TypeError('Uncaught, unspecified \"error\" event.');\n    }\n  }\n\n  handler = this._events[type];\n\n  if (isUndefined(handler))\n    return false;\n\n  if (isFunction(handler)) {\n    switch (arguments.length) {\n      // fast cases\n      case 1:\n        handler.call(this);\n        break;\n      case 2:\n        handler.call(this, arguments[1]);\n        break;\n      case 3:\n        handler.call(this, arguments[1], arguments[2]);\n        break;\n      // slower\n      default:\n        args = Array.prototype.slice.call(arguments, 1);\n        handler.apply(this, args);\n    }\n  } else if (isObject(handler)) {\n    args = Array.prototype.slice.call(arguments, 1);\n    listeners = handler.slice();\n    len = listeners.length;\n    for (i = 0; i < len; i++)\n      listeners[i].apply(this, args);\n  }\n\n  return true;\n};\n\nEventEmitter.prototype.addListener = function(type, listener) {\n  var m;\n\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events)\n    this._events = {};\n\n  // To avoid recursion in the case that type === \"newListener\"! Before\n  // adding it to the listeners, first emit \"newListener\".\n  if (this._events.newListener)\n    this.emit('newListener', type,\n              isFunction(listener.listener) ?\n              listener.listener : listener);\n\n  if (!this._events[type])\n    // Optimize the case of one listener. Don't need the extra array object.\n    this._events[type] = listener;\n  else if (isObject(this._events[type]))\n    // If we've already got an array, just append.\n    this._events[type].push(listener);\n  else\n    // Adding the second element, need to change to array.\n    this._events[type] = [this._events[type], listener];\n\n  // Check for listener leak\n  if (isObject(this._events[type]) && !this._events[type].warned) {\n    if (!isUndefined(this._maxListeners)) {\n      m = this._maxListeners;\n    } else {\n      m = EventEmitter.defaultMaxListeners;\n    }\n\n    if (m && m > 0 && this._events[type].length > m) {\n      this._events[type].warned = true;\n      console.error('(node) warning: possible EventEmitter memory ' +\n                    'leak detected. %d listeners added. ' +\n                    'Use emitter.setMaxListeners() to increase limit.',\n                    this._events[type].length);\n      if (typeof console.trace === 'function') {\n        // not supported in IE 10\n        console.trace();\n      }\n    }\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.once = function(type, listener) {\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  var fired = false;\n\n  function g() {\n    this.removeListener(type, g);\n\n    if (!fired) {\n      fired = true;\n      listener.apply(this, arguments);\n    }\n  }\n\n  g.listener = listener;\n  this.on(type, g);\n\n  return this;\n};\n\n// emits a 'removeListener' event iff the listener was removed\nEventEmitter.prototype.removeListener = function(type, listener) {\n  var list, position, length, i;\n\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events || !this._events[type])\n    return this;\n\n  list = this._events[type];\n  length = list.length;\n  position = -1;\n\n  if (list === listener ||\n      (isFunction(list.listener) && list.listener === listener)) {\n    delete this._events[type];\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n\n  } else if (isObject(list)) {\n    for (i = length; i-- > 0;) {\n      if (list[i] === listener ||\n          (list[i].listener && list[i].listener === listener)) {\n        position = i;\n        break;\n      }\n    }\n\n    if (position < 0)\n      return this;\n\n    if (list.length === 1) {\n      list.length = 0;\n      delete this._events[type];\n    } else {\n      list.splice(position, 1);\n    }\n\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.removeAllListeners = function(type) {\n  var key, listeners;\n\n  if (!this._events)\n    return this;\n\n  // not listening for removeListener, no need to emit\n  if (!this._events.removeListener) {\n    if (arguments.length === 0)\n      this._events = {};\n    else if (this._events[type])\n      delete this._events[type];\n    return this;\n  }\n\n  // emit removeListener for all listeners on all events\n  if (arguments.length === 0) {\n    for (key in this._events) {\n      if (key === 'removeListener') continue;\n      this.removeAllListeners(key);\n    }\n    this.removeAllListeners('removeListener');\n    this._events = {};\n    return this;\n  }\n\n  listeners = this._events[type];\n\n  if (isFunction(listeners)) {\n    this.removeListener(type, listeners);\n  } else if (listeners) {\n    // LIFO order\n    while (listeners.length)\n      this.removeListener(type, listeners[listeners.length - 1]);\n  }\n  delete this._events[type];\n\n  return this;\n};\n\nEventEmitter.prototype.listeners = function(type) {\n  var ret;\n  if (!this._events || !this._events[type])\n    ret = [];\n  else if (isFunction(this._events[type]))\n    ret = [this._events[type]];\n  else\n    ret = this._events[type].slice();\n  return ret;\n};\n\nEventEmitter.prototype.listenerCount = function(type) {\n  if (this._events) {\n    var evlistener = this._events[type];\n\n    if (isFunction(evlistener))\n      return 1;\n    else if (evlistener)\n      return evlistener.length;\n  }\n  return 0;\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  return emitter.listenerCount(type);\n};\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/events/events.js\n ** module id = 14\n ** module chunks = 0\n **/","'use strict';\nvar Mutation = global.MutationObserver || global.WebKitMutationObserver;\n\nvar scheduleDrain;\n\nif (process.browser) {\n  if (Mutation) {\n    var called = 0;\n    var observer = new Mutation(nextTick);\n    var element = global.document.createTextNode('');\n    observer.observe(element, {\n      characterData: true\n    });\n    scheduleDrain = function () {\n      element.data = (called = ++called % 2);\n    };\n  } else if (!global.setImmediate && typeof global.MessageChannel !== 'undefined') {\n    var channel = new global.MessageChannel();\n    channel.port1.onmessage = nextTick;\n    scheduleDrain = function () {\n      channel.port2.postMessage(0);\n    };\n  } else if ('document' in global && 'onreadystatechange' in global.document.createElement('script')) {\n    scheduleDrain = function () {\n\n      // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n      // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.\n      var scriptEl = global.document.createElement('script');\n      scriptEl.onreadystatechange = function () {\n        nextTick();\n\n        scriptEl.onreadystatechange = null;\n        scriptEl.parentNode.removeChild(scriptEl);\n        scriptEl = null;\n      };\n      global.document.documentElement.appendChild(scriptEl);\n    };\n  } else {\n    scheduleDrain = function () {\n      setTimeout(nextTick, 0);\n    };\n  }\n} else {\n  scheduleDrain = function () {\n    process.nextTick(nextTick);\n  };\n}\n\nvar draining;\nvar queue = [];\n//named nextTick for less confusing stack traces\nfunction nextTick() {\n  draining = true;\n  var i, oldQueue;\n  var len = queue.length;\n  while (len) {\n    oldQueue = queue;\n    queue = [];\n    i = -1;\n    while (++i < len) {\n      oldQueue[i]();\n    }\n    len = queue.length;\n  }\n  draining = false;\n}\n\nmodule.exports = immediate;\nfunction immediate(task) {\n  if (queue.push(task) === 1 && !draining) {\n    scheduleDrain();\n  }\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/immediate/lib/index.js\n ** module id = 17\n ** module chunks = 0\n **/","if (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    ctor.prototype = Object.create(superCtor.prototype, {\n      constructor: {\n        value: ctor,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    var TempCtor = function () {}\n    TempCtor.prototype = superCtor.prototype\n    ctor.prototype = new TempCtor()\n    ctor.prototype.constructor = ctor\n  }\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/inherits/inherits_browser.js\n ** module id = 18\n ** module chunks = 0\n **/","(function(factory) {\n  if(typeof exports === 'object') {\n    factory(exports);\n  } else {\n    factory(this);\n  }\n}).call(this, function(root) { \n\n  var slice   = Array.prototype.slice,\n      each    = Array.prototype.forEach;\n\n  var extend = function(obj) {\n    if(typeof obj !== 'object') throw obj + ' is not an object' ;\n\n    var sources = slice.call(arguments, 1); \n\n    each.call(sources, function(source) {\n      if(source) {\n        for(var prop in source) {\n          if(typeof source[prop] === 'object' && obj[prop]) {\n            extend.call(obj, obj[prop], source[prop]);\n          } else {\n            obj[prop] = source[prop];\n          }\n        } \n      }\n    });\n\n    return obj;\n  }\n\n  root.extend = extend;\n});\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/js-extend/extend.js\n ** module id = 19\n ** module chunks = 0\n **/","'use strict';\nvar immediate = require('immediate');\n\n/* istanbul ignore next */\nfunction INTERNAL() {}\n\nvar handlers = {};\n\nvar REJECTED = ['REJECTED'];\nvar FULFILLED = ['FULFILLED'];\nvar PENDING = ['PENDING'];\n/* istanbul ignore else */\nif (!process.browser) {\n  // in which we actually take advantage of JS scoping\n  var UNHANDLED = ['UNHANDLED'];\n}\n\nmodule.exports = exports = Promise;\n\nfunction Promise(resolver) {\n  if (typeof resolver !== 'function') {\n    throw new TypeError('resolver must be a function');\n  }\n  this.state = PENDING;\n  this.queue = [];\n  this.outcome = void 0;\n  /* istanbul ignore else */\n  if (!process.browser) {\n    this.handled = UNHANDLED;\n  }\n  if (resolver !== INTERNAL) {\n    safelyResolveThenable(this, resolver);\n  }\n}\n\nPromise.prototype.catch = function (onRejected) {\n  return this.then(null, onRejected);\n};\nPromise.prototype.then = function (onFulfilled, onRejected) {\n  if (typeof onFulfilled !== 'function' && this.state === FULFILLED ||\n    typeof onRejected !== 'function' && this.state === REJECTED) {\n    return this;\n  }\n  var promise = new this.constructor(INTERNAL);\n  /* istanbul ignore else */\n  if (!process.browser) {\n    if (this.handled === UNHANDLED) {\n      this.handled = null;\n    }\n  }\n  if (this.state !== PENDING) {\n    var resolver = this.state === FULFILLED ? onFulfilled : onRejected;\n    unwrap(promise, resolver, this.outcome);\n  } else {\n    this.queue.push(new QueueItem(promise, onFulfilled, onRejected));\n  }\n\n  return promise;\n};\nfunction QueueItem(promise, onFulfilled, onRejected) {\n  this.promise = promise;\n  if (typeof onFulfilled === 'function') {\n    this.onFulfilled = onFulfilled;\n    this.callFulfilled = this.otherCallFulfilled;\n  }\n  if (typeof onRejected === 'function') {\n    this.onRejected = onRejected;\n    this.callRejected = this.otherCallRejected;\n  }\n}\nQueueItem.prototype.callFulfilled = function (value) {\n  handlers.resolve(this.promise, value);\n};\nQueueItem.prototype.otherCallFulfilled = function (value) {\n  unwrap(this.promise, this.onFulfilled, value);\n};\nQueueItem.prototype.callRejected = function (value) {\n  handlers.reject(this.promise, value);\n};\nQueueItem.prototype.otherCallRejected = function (value) {\n  unwrap(this.promise, this.onRejected, value);\n};\n\nfunction unwrap(promise, func, value) {\n  immediate(function () {\n    var returnValue;\n    try {\n      returnValue = func(value);\n    } catch (e) {\n      return handlers.reject(promise, e);\n    }\n    if (returnValue === promise) {\n      handlers.reject(promise, new TypeError('Cannot resolve promise with itself'));\n    } else {\n      handlers.resolve(promise, returnValue);\n    }\n  });\n}\n\nhandlers.resolve = function (self, value) {\n  var result = tryCatch(getThen, value);\n  if (result.status === 'error') {\n    return handlers.reject(self, result.value);\n  }\n  var thenable = result.value;\n\n  if (thenable) {\n    safelyResolveThenable(self, thenable);\n  } else {\n    self.state = FULFILLED;\n    self.outcome = value;\n    var i = -1;\n    var len = self.queue.length;\n    while (++i < len) {\n      self.queue[i].callFulfilled(value);\n    }\n  }\n  return self;\n};\nhandlers.reject = function (self, error) {\n  self.state = REJECTED;\n  self.outcome = error;\n  /* istanbul ignore else */\n  if (!process.browser) {\n    if (self.handled === UNHANDLED) {\n      immediate(function () {\n        if (self.handled === UNHANDLED) {\n          process.emit('unhandledRejection', error, self);\n        }\n      });\n    }\n  }\n  var i = -1;\n  var len = self.queue.length;\n  while (++i < len) {\n    self.queue[i].callRejected(error);\n  }\n  return self;\n};\n\nfunction getThen(obj) {\n  // Make sure we only access the accessor once as required by the spec\n  var then = obj && obj.then;\n  if (obj && typeof obj === 'object' && typeof then === 'function') {\n    return function appyThen() {\n      then.apply(obj, arguments);\n    };\n  }\n}\n\nfunction safelyResolveThenable(self, thenable) {\n  // Either fulfill, reject or reject with error\n  var called = false;\n  function onError(value) {\n    if (called) {\n      return;\n    }\n    called = true;\n    handlers.reject(self, value);\n  }\n\n  function onSuccess(value) {\n    if (called) {\n      return;\n    }\n    called = true;\n    handlers.resolve(self, value);\n  }\n\n  function tryToUnwrap() {\n    thenable(onSuccess, onError);\n  }\n\n  var result = tryCatch(tryToUnwrap);\n  if (result.status === 'error') {\n    onError(result.value);\n  }\n}\n\nfunction tryCatch(func, value) {\n  var out = {};\n  try {\n    out.value = func(value);\n    out.status = 'success';\n  } catch (e) {\n    out.status = 'error';\n    out.value = e;\n  }\n  return out;\n}\n\nexports.resolve = resolve;\nfunction resolve(value) {\n  if (value instanceof this) {\n    return value;\n  }\n  return handlers.resolve(new this(INTERNAL), value);\n}\n\nexports.reject = reject;\nfunction reject(reason) {\n  var promise = new this(INTERNAL);\n  return handlers.reject(promise, reason);\n}\n\nexports.all = all;\nfunction all(iterable) {\n  var self = this;\n  if (Object.prototype.toString.call(iterable) !== '[object Array]') {\n    return this.reject(new TypeError('must be an array'));\n  }\n\n  var len = iterable.length;\n  var called = false;\n  if (!len) {\n    return this.resolve([]);\n  }\n\n  var values = new Array(len);\n  var resolved = 0;\n  var i = -1;\n  var promise = new this(INTERNAL);\n\n  while (++i < len) {\n    allResolver(iterable[i], i);\n  }\n  return promise;\n  function allResolver(value, i) {\n    self.resolve(value).then(resolveFromAll, function (error) {\n      if (!called) {\n        called = true;\n        handlers.reject(promise, error);\n      }\n    });\n    function resolveFromAll(outValue) {\n      values[i] = outValue;\n      if (++resolved === len && !called) {\n        called = true;\n        handlers.resolve(promise, values);\n      }\n    }\n  }\n}\n\nexports.race = race;\nfunction race(iterable) {\n  var self = this;\n  if (Object.prototype.toString.call(iterable) !== '[object Array]') {\n    return this.reject(new TypeError('must be an array'));\n  }\n\n  var len = iterable.length;\n  var called = false;\n  if (!len) {\n    return this.resolve([]);\n  }\n\n  var i = -1;\n  var promise = new this(INTERNAL);\n\n  while (++i < len) {\n    resolver(iterable[i]);\n  }\n  return promise;\n  function resolver(value) {\n    self.resolve(value).then(function (response) {\n      if (!called) {\n        called = true;\n        handlers.resolve(promise, response);\n      }\n    }, function (error) {\n      if (!called) {\n        called = true;\n        handlers.reject(promise, error);\n      }\n    });\n  }\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/lie/lib/index.js\n ** module id = 20\n ** module chunks = 0\n **/","/**\n * Helpers.\n */\n\nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar y = d * 365.25;\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} options\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function(val, options){\n  options = options || {};\n  if ('string' == typeof val) return parse(val);\n  return options.long\n    ? long(val)\n    : short(val);\n};\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\nfunction parse(str) {\n  str = '' + str;\n  if (str.length > 10000) return;\n  var match = /^((?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);\n  if (!match) return;\n  var n = parseFloat(match[1]);\n  var type = (match[2] || 'ms').toLowerCase();\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'yrs':\n    case 'yr':\n    case 'y':\n      return n * y;\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d;\n    case 'hours':\n    case 'hour':\n    case 'hrs':\n    case 'hr':\n    case 'h':\n      return n * h;\n    case 'minutes':\n    case 'minute':\n    case 'mins':\n    case 'min':\n    case 'm':\n      return n * m;\n    case 'seconds':\n    case 'second':\n    case 'secs':\n    case 'sec':\n    case 's':\n      return n * s;\n    case 'milliseconds':\n    case 'millisecond':\n    case 'msecs':\n    case 'msec':\n    case 'ms':\n      return n;\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction short(ms) {\n  if (ms >= d) return Math.round(ms / d) + 'd';\n  if (ms >= h) return Math.round(ms / h) + 'h';\n  if (ms >= m) return Math.round(ms / m) + 'm';\n  if (ms >= s) return Math.round(ms / s) + 's';\n  return ms + 'ms';\n}\n\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction long(ms) {\n  return plural(ms, d, 'day')\n    || plural(ms, h, 'hour')\n    || plural(ms, m, 'minute')\n    || plural(ms, s, 'second')\n    || ms + ' ms';\n}\n\n/**\n * Pluralization helper.\n */\n\nfunction plural(ms, n, name) {\n  if (ms < n) return;\n  if (ms < n * 1.5) return Math.floor(ms / n) + ' ' + name;\n  return Math.ceil(ms / n) + ' ' + name + 's';\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/ms/index.js\n ** module id = 21\n ** module chunks = 0\n **/","'use strict';\n\nvar MIN_MAGNITUDE = -324; // verified by -Number.MIN_VALUE\nvar MAGNITUDE_DIGITS = 3; // ditto\nvar SEP = ''; // set to '_' for easier debugging \n\nvar utils = require('./utils');\n\nexports.collate = function (a, b) {\n\n  if (a === b) {\n    return 0;\n  }\n\n  a = exports.normalizeKey(a);\n  b = exports.normalizeKey(b);\n\n  var ai = collationIndex(a);\n  var bi = collationIndex(b);\n  if ((ai - bi) !== 0) {\n    return ai - bi;\n  }\n  if (a === null) {\n    return 0;\n  }\n  switch (typeof a) {\n    case 'number':\n      return a - b;\n    case 'boolean':\n      return a === b ? 0 : (a < b ? -1 : 1);\n    case 'string':\n      return stringCollate(a, b);\n  }\n  return Array.isArray(a) ? arrayCollate(a, b) : objectCollate(a, b);\n};\n\n// couch considers null/NaN/Infinity/-Infinity === undefined,\n// for the purposes of mapreduce indexes. also, dates get stringified.\nexports.normalizeKey = function (key) {\n  switch (typeof key) {\n    case 'undefined':\n      return null;\n    case 'number':\n      if (key === Infinity || key === -Infinity || isNaN(key)) {\n        return null;\n      }\n      return key;\n    case 'object':\n      var origKey = key;\n      if (Array.isArray(key)) {\n        var len = key.length;\n        key = new Array(len);\n        for (var i = 0; i < len; i++) {\n          key[i] = exports.normalizeKey(origKey[i]);\n        }\n      } else if (key instanceof Date) {\n        return key.toJSON();\n      } else if (key !== null) { // generic object\n        key = {};\n        for (var k in origKey) {\n          if (origKey.hasOwnProperty(k)) {\n            var val = origKey[k];\n            if (typeof val !== 'undefined') {\n              key[k] = exports.normalizeKey(val);\n            }\n          }\n        }\n      }\n  }\n  return key;\n};\n\nfunction indexify(key) {\n  if (key !== null) {\n    switch (typeof key) {\n      case 'boolean':\n        return key ? 1 : 0;\n      case 'number':\n        return numToIndexableString(key);\n      case 'string':\n        // We've to be sure that key does not contain \\u0000\n        // Do order-preserving replacements:\n        // 0 -> 1, 1\n        // 1 -> 1, 2\n        // 2 -> 2, 2\n        return key\n          .replace(/\\u0002/g, '\\u0002\\u0002')\n          .replace(/\\u0001/g, '\\u0001\\u0002')\n          .replace(/\\u0000/g, '\\u0001\\u0001');\n      case 'object':\n        var isArray = Array.isArray(key);\n        var arr = isArray ? key : Object.keys(key);\n        var i = -1;\n        var len = arr.length;\n        var result = '';\n        if (isArray) {\n          while (++i < len) {\n            result += exports.toIndexableString(arr[i]);\n          }\n        } else {\n          while (++i < len) {\n            var objKey = arr[i];\n            result += exports.toIndexableString(objKey) +\n                exports.toIndexableString(key[objKey]);\n          }\n        }\n        return result;\n    }\n  }\n  return '';\n}\n\n// convert the given key to a string that would be appropriate\n// for lexical sorting, e.g. within a database, where the\n// sorting is the same given by the collate() function.\nexports.toIndexableString = function (key) {\n  var zero = '\\u0000';\n  key = exports.normalizeKey(key);\n  return collationIndex(key) + SEP + indexify(key) + zero;\n};\n\nfunction parseNumber(str, i) {\n  var originalIdx = i;\n  var num;\n  var zero = str[i] === '1';\n  if (zero) {\n    num = 0;\n    i++;\n  } else {\n    var neg = str[i] === '0';\n    i++;\n    var numAsString = '';\n    var magAsString = str.substring(i, i + MAGNITUDE_DIGITS);\n    var magnitude = parseInt(magAsString, 10) + MIN_MAGNITUDE;\n    if (neg) {\n      magnitude = -magnitude;\n    }\n    i += MAGNITUDE_DIGITS;\n    while (true) {\n      var ch = str[i];\n      if (ch === '\\u0000') {\n        break;\n      } else {\n        numAsString += ch;\n      }\n      i++;\n    }\n    numAsString = numAsString.split('.');\n    if (numAsString.length === 1) {\n      num = parseInt(numAsString, 10);\n    } else {\n      num = parseFloat(numAsString[0] + '.' + numAsString[1]);\n    }\n    if (neg) {\n      num = num - 10;\n    }\n    if (magnitude !== 0) {\n      // parseFloat is more reliable than pow due to rounding errors\n      // e.g. Number.MAX_VALUE would return Infinity if we did\n      // num * Math.pow(10, magnitude);\n      num = parseFloat(num + 'e' + magnitude);\n    }\n  }\n  return {num: num, length : i - originalIdx};\n}\n\n// move up the stack while parsing\n// this function moved outside of parseIndexableString for performance\nfunction pop(stack, metaStack) {\n  var obj = stack.pop();\n\n  if (metaStack.length) {\n    var lastMetaElement = metaStack[metaStack.length - 1];\n    if (obj === lastMetaElement.element) {\n      // popping a meta-element, e.g. an object whose value is another object\n      metaStack.pop();\n      lastMetaElement = metaStack[metaStack.length - 1];\n    }\n    var element = lastMetaElement.element;\n    var lastElementIndex = lastMetaElement.index;\n    if (Array.isArray(element)) {\n      element.push(obj);\n    } else if (lastElementIndex === stack.length - 2) { // obj with key+value\n      var key = stack.pop();\n      element[key] = obj;\n    } else {\n      stack.push(obj); // obj with key only\n    }\n  }\n}\n\nexports.parseIndexableString = function (str) {\n  var stack = [];\n  var metaStack = []; // stack for arrays and objects\n  var i = 0;\n\n  while (true) {\n    var collationIndex = str[i++];\n    if (collationIndex === '\\u0000') {\n      if (stack.length === 1) {\n        return stack.pop();\n      } else {\n        pop(stack, metaStack);\n        continue;\n      }\n    }\n    switch (collationIndex) {\n      case '1':\n        stack.push(null);\n        break;\n      case '2':\n        stack.push(str[i] === '1');\n        i++;\n        break;\n      case '3':\n        var parsedNum = parseNumber(str, i);\n        stack.push(parsedNum.num);\n        i += parsedNum.length;\n        break;\n      case '4':\n        var parsedStr = '';\n        while (true) {\n          var ch = str[i];\n          if (ch === '\\u0000') {\n            break;\n          }\n          parsedStr += ch;\n          i++;\n        }\n        // perform the reverse of the order-preserving replacement\n        // algorithm (see above)\n        parsedStr = parsedStr.replace(/\\u0001\\u0001/g, '\\u0000')\n          .replace(/\\u0001\\u0002/g, '\\u0001')\n          .replace(/\\u0002\\u0002/g, '\\u0002');\n        stack.push(parsedStr);\n        break;\n      case '5':\n        var arrayElement = { element: [], index: stack.length };\n        stack.push(arrayElement.element);\n        metaStack.push(arrayElement);\n        break;\n      case '6':\n        var objElement = { element: {}, index: stack.length };\n        stack.push(objElement.element);\n        metaStack.push(objElement);\n        break;\n      default:\n        throw new Error(\n          'bad collationIndex or unexpectedly reached end of input: ' + collationIndex);\n    }\n  }\n};\n\nfunction arrayCollate(a, b) {\n  var len = Math.min(a.length, b.length);\n  for (var i = 0; i < len; i++) {\n    var sort = exports.collate(a[i], b[i]);\n    if (sort !== 0) {\n      return sort;\n    }\n  }\n  return (a.length === b.length) ? 0 :\n    (a.length > b.length) ? 1 : -1;\n}\nfunction stringCollate(a, b) {\n  // See: https://github.com/daleharvey/pouchdb/issues/40\n  // This is incompatible with the CouchDB implementation, but its the\n  // best we can do for now\n  return (a === b) ? 0 : ((a > b) ? 1 : -1);\n}\nfunction objectCollate(a, b) {\n  var ak = Object.keys(a), bk = Object.keys(b);\n  var len = Math.min(ak.length, bk.length);\n  for (var i = 0; i < len; i++) {\n    // First sort the keys\n    var sort = exports.collate(ak[i], bk[i]);\n    if (sort !== 0) {\n      return sort;\n    }\n    // if the keys are equal sort the values\n    sort = exports.collate(a[ak[i]], b[bk[i]]);\n    if (sort !== 0) {\n      return sort;\n    }\n\n  }\n  return (ak.length === bk.length) ? 0 :\n    (ak.length > bk.length) ? 1 : -1;\n}\n// The collation is defined by erlangs ordered terms\n// the atoms null, true, false come first, then numbers, strings,\n// arrays, then objects\n// null/undefined/NaN/Infinity/-Infinity are all considered null\nfunction collationIndex(x) {\n  var id = ['boolean', 'number', 'string', 'object'];\n  var idx = id.indexOf(typeof x);\n  //false if -1 otherwise true, but fast!!!!1\n  if (~idx) {\n    if (x === null) {\n      return 1;\n    }\n    if (Array.isArray(x)) {\n      return 5;\n    }\n    return idx < 3 ? (idx + 2) : (idx + 3);\n  }\n  if (Array.isArray(x)) {\n    return 5;\n  }\n}\n\n// conversion:\n// x yyy zz...zz\n// x = 0 for negative, 1 for 0, 2 for positive\n// y = exponent (for negative numbers negated) moved so that it's >= 0\n// z = mantisse\nfunction numToIndexableString(num) {\n\n  if (num === 0) {\n    return '1';\n  }\n\n  // convert number to exponential format for easier and\n  // more succinct string sorting\n  var expFormat = num.toExponential().split(/e\\+?/);\n  var magnitude = parseInt(expFormat[1], 10);\n\n  var neg = num < 0;\n\n  var result = neg ? '0' : '2';\n\n  // first sort by magnitude\n  // it's easier if all magnitudes are positive\n  var magForComparison = ((neg ? -magnitude : magnitude) - MIN_MAGNITUDE);\n  var magString = utils.padLeft((magForComparison).toString(), '0', MAGNITUDE_DIGITS);\n\n  result += SEP + magString;\n\n  // then sort by the factor\n  var factor = Math.abs(parseFloat(expFormat[0])); // [1..10)\n  if (neg) { // for negative reverse ordering\n    factor = 10 - factor;\n  }\n\n  var factorStr = factor.toFixed(20);\n\n  // strip zeros from the end\n  factorStr = factorStr.replace(/\\.?0+$/, '');\n\n  result += SEP + factorStr;\n\n  return result;\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/pouchdb-collate/lib/index.js\n ** module id = 22\n ** module chunks = 0\n **/","'use strict';\n\nfunction pad(str, padWith, upToLength) {\n  var padding = '';\n  var targetLength = upToLength - str.length;\n  while (padding.length < targetLength) {\n    padding += padWith;\n  }\n  return padding;\n}\n\nexports.padLeft = function (str, padWith, upToLength) {\n  var padding = pad(str, padWith, upToLength);\n  return padding + str;\n};\n\nexports.padRight = function (str, padWith, upToLength) {\n  var padding = pad(str, padWith, upToLength);\n  return str + padding;\n};\n\nexports.stringLexCompare = function (a, b) {\n\n  var aLen = a.length;\n  var bLen = b.length;\n\n  var i;\n  for (i = 0; i < aLen; i++) {\n    if (i === bLen) {\n      // b is shorter substring of a\n      return 1;\n    }\n    var aChar = a.charAt(i);\n    var bChar = b.charAt(i);\n    if (aChar !== bChar) {\n      return aChar < bChar ? -1 : 1;\n    }\n  }\n\n  if (aLen < bLen) {\n    // a is shorter substring of b\n    return -1;\n  }\n\n  return 0;\n};\n\n/*\n * returns the decimal form for the given integer, i.e. writes\n * out all the digits (in base-10) instead of using scientific notation\n */\nexports.intToDecimalForm = function (int) {\n\n  var isNeg = int < 0;\n  var result = '';\n\n  do {\n    var remainder = isNeg ? -Math.ceil(int % 10) : Math.floor(int % 10);\n\n    result = remainder + result;\n    int = isNeg ? Math.ceil(int / 10) : Math.floor(int / 10);\n  } while (int);\n\n\n  if (isNeg && result !== '0') {\n    result = '-' + result;\n  }\n\n  return result;\n};\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/pouchdb-collate/lib/utils.js\n ** module id = 23\n ** module chunks = 0\n **/","'use strict';\nexports.Map = LazyMap; // TODO: use ES6 map\nexports.Set = LazySet; // TODO: use ES6 set\n// based on https://github.com/montagejs/collections\nfunction LazyMap() {\n  this.store = {};\n}\nLazyMap.prototype.mangle = function (key) {\n  if (typeof key !== \"string\") {\n    throw new TypeError(\"key must be a string but Got \" + key);\n  }\n  return '$' + key;\n};\nLazyMap.prototype.unmangle = function (key) {\n  return key.substring(1);\n};\nLazyMap.prototype.get = function (key) {\n  var mangled = this.mangle(key);\n  if (mangled in this.store) {\n    return this.store[mangled];\n  }\n  return void 0;\n};\nLazyMap.prototype.set = function (key, value) {\n  var mangled = this.mangle(key);\n  this.store[mangled] = value;\n  return true;\n};\nLazyMap.prototype.has = function (key) {\n  var mangled = this.mangle(key);\n  return mangled in this.store;\n};\nLazyMap.prototype.delete = function (key) {\n  var mangled = this.mangle(key);\n  if (mangled in this.store) {\n    delete this.store[mangled];\n    return true;\n  }\n  return false;\n};\nLazyMap.prototype.forEach = function (cb) {\n  var keys = Object.keys(this.store);\n  for (var i = 0, len = keys.length; i < len; i++) {\n    var key = keys[i];\n    var value = this.store[key];\n    key = this.unmangle(key);\n    cb(value, key);\n  }\n};\n\nfunction LazySet(array) {\n  this.store = new LazyMap();\n\n  // init with an array\n  if (array && Array.isArray(array)) {\n    for (var i = 0, len = array.length; i < len; i++) {\n      this.add(array[i]);\n    }\n  }\n}\nLazySet.prototype.add = function (key) {\n  return this.store.set(key, true);\n};\nLazySet.prototype.has = function (key) {\n  return this.store.has(key);\n};\nLazySet.prototype.delete = function (key) {\n  return this.store.delete(key);\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/pouchdb-collections/index.js\n ** module id = 24\n ** module chunks = 0\n **/","'use strict';\n\nfunction _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }\n\nvar jsExtend = require('js-extend');\nvar jsExtend__default = _interopDefault(jsExtend);\nvar debug = _interopDefault(require('debug'));\nvar inherits = _interopDefault(require('inherits'));\nvar lie = _interopDefault(require('lie'));\nvar pouchdbCollections = require('pouchdb-collections');\nvar getArguments = _interopDefault(require('argsarray'));\nvar events = require('events');\nvar scopedEval = _interopDefault(require('scope-eval'));\nvar pouchCollate = require('pouchdb-collate');\nvar pouchCollate__default = _interopDefault(pouchCollate);\nvar Md5 = _interopDefault(require('spark-md5'));\nvar vuvuzela = _interopDefault(require('vuvuzela'));\n\n/* istanbul ignore next */\nvar PouchPromise = typeof Promise === 'function' ? Promise : lie;\n\n// like underscore/lodash _.pick()\nfunction pick(obj, arr) {\n  var res = {};\n  for (var i = 0, len = arr.length; i < len; i++) {\n    var prop = arr[i];\n    if (prop in obj) {\n      res[prop] = obj[prop];\n    }\n  }\n  return res;\n}\n\nfunction isBinaryObject(object) {\n  return object instanceof ArrayBuffer ||\n    (typeof Blob !== 'undefined' && object instanceof Blob);\n}\n\nfunction cloneArrayBuffer(buff) {\n  if (typeof buff.slice === 'function') {\n    return buff.slice(0);\n  }\n  // IE10-11 slice() polyfill\n  var target = new ArrayBuffer(buff.byteLength);\n  var targetArray = new Uint8Array(target);\n  var sourceArray = new Uint8Array(buff);\n  targetArray.set(sourceArray);\n  return target;\n}\n\nfunction cloneBinaryObject(object) {\n  if (object instanceof ArrayBuffer) {\n    return cloneArrayBuffer(object);\n  }\n  var size = object.size;\n  var type = object.type;\n  // Blob\n  if (typeof object.slice === 'function') {\n    return object.slice(0, size, type);\n  }\n  // PhantomJS slice() replacement\n  return object.webkitSlice(0, size, type);\n}\n\nfunction clone(object) {\n  var newObject;\n  var i;\n  var len;\n\n  if (!object || typeof object !== 'object') {\n    return object;\n  }\n\n  if (Array.isArray(object)) {\n    newObject = [];\n    for (i = 0, len = object.length; i < len; i++) {\n      newObject[i] = clone(object[i]);\n    }\n    return newObject;\n  }\n\n  // special case: to avoid inconsistencies between IndexedDB\n  // and other backends, we automatically stringify Dates\n  if (object instanceof Date) {\n    return object.toISOString();\n  }\n\n  if (isBinaryObject(object)) {\n    return cloneBinaryObject(object);\n  }\n\n  newObject = {};\n  for (i in object) {\n    if (Object.prototype.hasOwnProperty.call(object, i)) {\n      var value = clone(object[i]);\n      if (typeof value !== 'undefined') {\n        newObject[i] = value;\n      }\n    }\n  }\n  return newObject;\n}\n\nfunction once(fun) {\n  var called = false;\n  return getArguments(function (args) {\n    /* istanbul ignore if */\n    if (called) {\n      // this is a smoke test and should never actually happen\n      throw new Error('once called more than once');\n    } else {\n      called = true;\n      fun.apply(this, args);\n    }\n  });\n}\n\nfunction toPromise(func) {\n  //create the function we will be returning\n  return getArguments(function (args) {\n    // Clone arguments\n    args = clone(args);\n    var self = this;\n    var tempCB =\n      (typeof args[args.length - 1] === 'function') ? args.pop() : false;\n    // if the last argument is a function, assume its a callback\n    var usedCB;\n    if (tempCB) {\n      // if it was a callback, create a new callback which calls it,\n      // but do so async so we don't trap any errors\n      usedCB = function (err, resp) {\n        process.nextTick(function () {\n          tempCB(err, resp);\n        });\n      };\n    }\n    var promise = new PouchPromise(function (fulfill, reject) {\n      var resp;\n      try {\n        var callback = once(function (err, mesg) {\n          if (err) {\n            reject(err);\n          } else {\n            fulfill(mesg);\n          }\n        });\n        // create a callback for this invocation\n        // apply the function in the orig context\n        args.push(callback);\n        resp = func.apply(self, args);\n        if (resp && typeof resp.then === 'function') {\n          fulfill(resp);\n        }\n      } catch (e) {\n        reject(e);\n      }\n    });\n    // if there is a callback, call it back\n    if (usedCB) {\n      promise.then(function (result) {\n        usedCB(null, result);\n      }, usedCB);\n    }\n    return promise;\n  });\n}\n\nvar log = debug('pouchdb:api');\n\nfunction adapterFun(name, callback) {\n  function logApiCall(self, name, args) {\n    /* istanbul ignore if */\n    if (log.enabled) {\n      var logArgs = [self._db_name, name];\n      for (var i = 0; i < args.length - 1; i++) {\n        logArgs.push(args[i]);\n      }\n      log.apply(null, logArgs);\n\n      // override the callback itself to log the response\n      var origCallback = args[args.length - 1];\n      args[args.length - 1] = function (err, res) {\n        var responseArgs = [self._db_name, name];\n        responseArgs = responseArgs.concat(\n          err ? ['error', err] : ['success', res]\n        );\n        log.apply(null, responseArgs);\n        origCallback(err, res);\n      };\n    }\n  }\n\n  return toPromise(getArguments(function (args) {\n    if (this._closed) {\n      return PouchPromise.reject(new Error('database is closed'));\n    }\n    if (this._destroyed) {\n      return PouchPromise.reject(new Error('database is destroyed'));\n    }\n    var self = this;\n    logApiCall(self, name, args);\n    if (!this.taskqueue.isReady) {\n      return new PouchPromise(function (fulfill, reject) {\n        self.taskqueue.addTask(function (failed) {\n          if (failed) {\n            reject(failed);\n          } else {\n            fulfill(self[name].apply(self, args));\n          }\n        });\n      });\n    }\n    return callback.apply(this, args);\n  }));\n}\n\n// this is essentially the \"update sugar\" function from daleharvey/pouchdb#1388\n// the diffFun tells us what delta to apply to the doc.  it either returns\n// the doc, or false if it doesn't need to do an update after all\nfunction upsert(db, docId, diffFun) {\n  return new PouchPromise(function (fulfill, reject) {\n    db.get(docId, function (err, doc) {\n      if (err) {\n        /* istanbul ignore next */\n        if (err.status !== 404) {\n          return reject(err);\n        }\n        doc = {};\n      }\n\n      // the user might change the _rev, so save it for posterity\n      var docRev = doc._rev;\n      var newDoc = diffFun(doc);\n\n      if (!newDoc) {\n        // if the diffFun returns falsy, we short-circuit as\n        // an optimization\n        return fulfill({updated: false, rev: docRev});\n      }\n\n      // users aren't allowed to modify these values,\n      // so reset them here\n      newDoc._id = docId;\n      newDoc._rev = docRev;\n      fulfill(tryAndPut(db, newDoc, diffFun));\n    });\n  });\n}\n\nfunction tryAndPut(db, doc, diffFun) {\n  return db.put(doc).then(function (res) {\n    return {\n      updated: true,\n      rev: res.rev\n    };\n  }, function (err) {\n    /* istanbul ignore next */\n    if (err.status !== 409) {\n      throw err;\n    }\n    return upsert(db, doc._id, diffFun);\n  });\n}\n\n// We fetch all leafs of the revision tree, and sort them based on tree length\n// and whether they were deleted, undeleted documents with the longest revision\n// tree (most edits) win\n// The final sort algorithm is slightly documented in a sidebar here:\n// http://guide.couchdb.org/draft/conflicts.html\nfunction winningRev(metadata) {\n  var winningId;\n  var winningPos;\n  var winningDeleted;\n  var toVisit = metadata.rev_tree.slice();\n  var node;\n  while ((node = toVisit.pop())) {\n    var tree = node.ids;\n    var branches = tree[2];\n    var pos = node.pos;\n    if (branches.length) { // non-leaf\n      for (var i = 0, len = branches.length; i < len; i++) {\n        toVisit.push({pos: pos + 1, ids: branches[i]});\n      }\n      continue;\n    }\n    var deleted = !!tree[1].deleted;\n    var id = tree[0];\n    // sort by deleted, then pos, then id\n    if (!winningId || (winningDeleted !== deleted ? winningDeleted :\n        winningPos !== pos ? winningPos < pos : winningId < id)) {\n      winningId = id;\n      winningPos = pos;\n      winningDeleted = deleted;\n    }\n  }\n\n  return winningPos + '-' + winningId;\n}\n\nfunction getTrees(node) {\n  return node.ids;\n}\n\n// check if a specific revision of a doc has been deleted\n//  - metadata: the metadata object from the doc store\n//  - rev: (optional) the revision to check. defaults to winning revision\nfunction isDeleted(metadata, rev) {\n  if (!rev) {\n    rev = winningRev(metadata);\n  }\n  var id = rev.substring(rev.indexOf('-') + 1);\n  var toVisit = metadata.rev_tree.map(getTrees);\n\n  var tree;\n  while ((tree = toVisit.pop())) {\n    if (tree[0] === id) {\n      return !!tree[1].deleted;\n    }\n    toVisit = toVisit.concat(tree[2]);\n  }\n}\n\nfunction evalFilter(input) {\n  return scopedEval('return ' + input + ';', {});\n}\n\nfunction evalView(input) {\n  /* jshint evil:true */\n  return new Function('doc', [\n    'var emitted = false;',\n    'var emit = function (a, b) {',\n    '  emitted = true;',\n    '};',\n    'var view = ' + input + ';',\n    'view(doc);',\n    'if (emitted) {',\n    '  return true;',\n    '}'\n  ].join('\\n'));\n}\n\nfunction parseDesignDocFunctionName(s) {\n  if (!s) {\n    return null;\n  }\n  var parts = s.split('/');\n  if (parts.length === 2) {\n    return parts;\n  }\n  if (parts.length === 1) {\n    return [s, s];\n  }\n  return null;\n}\n\nfunction normalizeDesignDocFunctionName(s) {\n  var normalized = parseDesignDocFunctionName(s);\n  return normalized ? normalized.join('/') : null;\n}\n\n// Pretty much all below can be combined into a higher order function to\n// traverse revisions\n// The return value from the callback will be passed as context to all\n// children of that node\nfunction traverseRevTree(revs, callback) {\n  var toVisit = revs.slice();\n\n  var node;\n  while ((node = toVisit.pop())) {\n    var pos = node.pos;\n    var tree = node.ids;\n    var branches = tree[2];\n    var newCtx =\n      callback(branches.length === 0, pos, tree[0], node.ctx, tree[1]);\n    for (var i = 0, len = branches.length; i < len; i++) {\n      toVisit.push({pos: pos + 1, ids: branches[i], ctx: newCtx});\n    }\n  }\n}\n\nfunction sortByPos(a, b) {\n  return a.pos - b.pos;\n}\n\nfunction collectLeaves(revs) {\n  var leaves = [];\n  traverseRevTree(revs, function (isLeaf, pos, id, acc, opts) {\n    if (isLeaf) {\n      leaves.push({rev: pos + \"-\" + id, pos: pos, opts: opts});\n    }\n  });\n  leaves.sort(sortByPos).reverse();\n  for (var i = 0, len = leaves.length; i < len; i++) {\n    delete leaves[i].pos;\n  }\n  return leaves;\n}\n\n// returns revs of all conflicts that is leaves such that\n// 1. are not deleted and\n// 2. are different than winning revision\nfunction collectConflicts(metadata) {\n  var win = winningRev(metadata);\n  var leaves = collectLeaves(metadata.rev_tree);\n  var conflicts = [];\n  for (var i = 0, len = leaves.length; i < len; i++) {\n    var leaf = leaves[i];\n    if (leaf.rev !== win && !leaf.opts.deleted) {\n      conflicts.push(leaf.rev);\n    }\n  }\n  return conflicts;\n}\n\ninherits(PouchError, Error);\n\nfunction PouchError(opts) {\n  Error.call(this, opts.reason);\n  this.status = opts.status;\n  this.name = opts.error;\n  this.message = opts.reason;\n  this.error = true;\n}\n\nPouchError.prototype.toString = function () {\n  return JSON.stringify({\n    status: this.status,\n    name: this.name,\n    message: this.message,\n    reason: this.reason\n  });\n};\n\nvar UNAUTHORIZED = new PouchError({\n  status: 401,\n  error: 'unauthorized',\n  reason: \"Name or password is incorrect.\"\n});\n\nvar MISSING_BULK_DOCS = new PouchError({\n  status: 400,\n  error: 'bad_request',\n  reason: \"Missing JSON list of 'docs'\"\n});\n\nvar MISSING_DOC = new PouchError({\n  status: 404,\n  error: 'not_found',\n  reason: 'missing'\n});\n\nvar REV_CONFLICT = new PouchError({\n  status: 409,\n  error: 'conflict',\n  reason: 'Document update conflict'\n});\n\nvar INVALID_ID = new PouchError({\n  status: 400,\n  error: 'invalid_id',\n  reason: '_id field must contain a string'\n});\n\nvar MISSING_ID = new PouchError({\n  status: 412,\n  error: 'missing_id',\n  reason: '_id is required for puts'\n});\n\nvar RESERVED_ID = new PouchError({\n  status: 400,\n  error: 'bad_request',\n  reason: 'Only reserved document ids may start with underscore.'\n});\n\nvar NOT_OPEN = new PouchError({\n  status: 412,\n  error: 'precondition_failed',\n  reason: 'Database not open'\n});\n\nvar UNKNOWN_ERROR = new PouchError({\n  status: 500,\n  error: 'unknown_error',\n  reason: 'Database encountered an unknown error'\n});\n\nvar BAD_ARG = new PouchError({\n  status: 500,\n  error: 'badarg',\n  reason: 'Some query argument is invalid'\n});\n\nvar INVALID_REQUEST = new PouchError({\n  status: 400,\n  error: 'invalid_request',\n  reason: 'Request was invalid'\n});\n\nvar QUERY_PARSE_ERROR = new PouchError({\n  status: 400,\n  error: 'query_parse_error',\n  reason: 'Some query parameter is invalid'\n});\n\nvar DOC_VALIDATION = new PouchError({\n  status: 500,\n  error: 'doc_validation',\n  reason: 'Bad special document member'\n});\n\nvar BAD_REQUEST = new PouchError({\n  status: 400,\n  error: 'bad_request',\n  reason: 'Something wrong with the request'\n});\n\nvar NOT_AN_OBJECT = new PouchError({\n  status: 400,\n  error: 'bad_request',\n  reason: 'Document must be a JSON object'\n});\n\nvar DB_MISSING = new PouchError({\n  status: 404,\n  error: 'not_found',\n  reason: 'Database not found'\n});\n\nvar IDB_ERROR = new PouchError({\n  status: 500,\n  error: 'indexed_db_went_bad',\n  reason: 'unknown'\n});\n\nvar WSQ_ERROR = new PouchError({\n  status: 500,\n  error: 'web_sql_went_bad',\n  reason: 'unknown'\n});\n\nvar LDB_ERROR = new PouchError({\n  status: 500,\n  error: 'levelDB_went_went_bad',\n  reason: 'unknown'\n});\n\nvar FORBIDDEN = new PouchError({\n  status: 403,\n  error: 'forbidden',\n  reason: 'Forbidden by design doc validate_doc_update function'\n});\n\nvar INVALID_REV = new PouchError({\n  status: 400,\n  error: 'bad_request',\n  reason: 'Invalid rev format'\n});\n\nvar FILE_EXISTS = new PouchError({\n  status: 412,\n  error: 'file_exists',\n  reason: 'The database could not be created, the file already exists.'\n});\n\nvar MISSING_STUB = new PouchError({\n  status: 412,\n  error: 'missing_stub'\n});\n\nvar INVALID_URL = new PouchError({\n  status: 413,\n  error: 'invalid_url',\n  reason: 'Provided URL is invalid'\n});\n\nvar allErrors = {\n  UNAUTHORIZED: UNAUTHORIZED,\n  MISSING_BULK_DOCS: MISSING_BULK_DOCS,\n  MISSING_DOC: MISSING_DOC,\n  REV_CONFLICT: REV_CONFLICT,\n  INVALID_ID: INVALID_ID,\n  MISSING_ID: MISSING_ID,\n  RESERVED_ID: RESERVED_ID,\n  NOT_OPEN: NOT_OPEN,\n  UNKNOWN_ERROR: UNKNOWN_ERROR,\n  BAD_ARG: BAD_ARG,\n  INVALID_REQUEST: INVALID_REQUEST,\n  QUERY_PARSE_ERROR: QUERY_PARSE_ERROR,\n  DOC_VALIDATION: DOC_VALIDATION,\n  BAD_REQUEST: BAD_REQUEST,\n  NOT_AN_OBJECT: NOT_AN_OBJECT,\n  DB_MISSING: DB_MISSING,\n  WSQ_ERROR: WSQ_ERROR,\n  LDB_ERROR: LDB_ERROR,\n  FORBIDDEN: FORBIDDEN,\n  INVALID_REV: INVALID_REV,\n  FILE_EXISTS: FILE_EXISTS,\n  MISSING_STUB: MISSING_STUB,\n  IDB_ERROR: IDB_ERROR,\n  INVALID_URL: INVALID_URL\n};\n\nfunction createError(error, reason, name) {\n  function CustomPouchError(reason) {\n    // inherit error properties from our parent error manually\n    // so as to allow proper JSON parsing.\n    /* jshint ignore:start */\n    for (var p in error) {\n      if (typeof error[p] !== 'function') {\n        this[p] = error[p];\n      }\n    }\n    /* jshint ignore:end */\n    if (name !== undefined) {\n      this.name = name;\n    }\n    if (reason !== undefined) {\n      this.reason = reason;\n    }\n  }\n  CustomPouchError.prototype = PouchError.prototype;\n  return new CustomPouchError(reason);\n}\n\n// Find one of the errors defined above based on the value\n// of the specified property.\n// If reason is provided prefer the error matching that reason.\n// This is for differentiating between errors with the same name and status,\n// eg, bad_request.\nvar getErrorTypeByProp = function (prop, value, reason) {\n  var keys = Object.keys(allErrors).filter(function (key) {\n    var error = allErrors[key];\n    return typeof error !== 'function' && error[prop] === value;\n  });\n  var key = reason && keys.filter(function (key) {\n        var error = allErrors[key];\n        return error.message === reason;\n      })[0] || keys[0];\n  return (key) ? allErrors[key] : null;\n};\n\nfunction generateErrorFromResponse(res) {\n  var error, errName, errType, errMsg, errReason;\n\n  errName = (res.error === true && typeof res.name === 'string') ?\n              res.name :\n              res.error;\n  errReason = res.reason;\n  errType = getErrorTypeByProp('name', errName, errReason);\n\n  if (res.missing ||\n      errReason === 'missing' ||\n      errReason === 'deleted' ||\n      errName === 'not_found') {\n    errType = MISSING_DOC;\n  } else if (errName === 'doc_validation') {\n    // doc validation needs special treatment since\n    // res.reason depends on the validation error.\n    // see utils.js\n    errType = DOC_VALIDATION;\n    errMsg = errReason;\n  } else if (errName === 'bad_request' && errType.message !== errReason) {\n    // if bad_request error already found based on reason don't override.\n    errType = BAD_REQUEST;\n  }\n\n  // fallback to error by status or unknown error.\n  if (!errType) {\n    errType = getErrorTypeByProp('status', res.status, errReason) ||\n                UNKNOWN_ERROR;\n  }\n\n  error = createError(errType, errReason, errName);\n\n  // Keep custom message.\n  if (errMsg) {\n    error.message = errMsg;\n  }\n\n  // Keep helpful response data in our error messages.\n  if (res.id) {\n    error.id = res.id;\n  }\n  if (res.status) {\n    error.status = res.status;\n  }\n  if (res.missing) {\n    error.missing = res.missing;\n  }\n\n  return error;\n}\n\ninherits(Changes, events.EventEmitter);\n\nfunction Changes(db, opts, callback) {\n  events.EventEmitter.call(this);\n  var self = this;\n  this.db = db;\n  opts = opts ? clone(opts) : {};\n  var complete = opts.complete = once(function (err, resp) {\n    if (err) {\n      self.emit('error', err);\n    } else {\n      self.emit('complete', resp);\n    }\n    self.removeAllListeners();\n    db.removeListener('destroyed', onDestroy);\n  });\n  if (callback) {\n    self.on('complete', function (resp) {\n      callback(null, resp);\n    });\n    self.on('error', callback);\n  }\n  function onDestroy() {\n    self.cancel();\n  }\n  db.once('destroyed', onDestroy);\n\n  opts.onChange = function (change) {\n    /* istanbul ignore if */\n    if (opts.isCancelled) {\n      return;\n    }\n    self.emit('change', change);\n    if (self.startSeq && self.startSeq <= change.seq) {\n      self.startSeq = false;\n    }\n  };\n\n  var promise = new PouchPromise(function (fulfill, reject) {\n    opts.complete = function (err, res) {\n      if (err) {\n        reject(err);\n      } else {\n        fulfill(res);\n      }\n    };\n  });\n  self.once('cancel', function () {\n    db.removeListener('destroyed', onDestroy);\n    opts.complete(null, {status: 'cancelled'});\n  });\n  this.then = promise.then.bind(promise);\n  this['catch'] = promise['catch'].bind(promise);\n  this.then(function (result) {\n    complete(null, result);\n  }, complete);\n\n\n\n  if (!db.taskqueue.isReady) {\n    db.taskqueue.addTask(function () {\n      if (self.isCancelled) {\n        self.emit('cancel');\n      } else {\n        self.doChanges(opts);\n      }\n    });\n  } else {\n    self.doChanges(opts);\n  }\n}\nChanges.prototype.cancel = function () {\n  this.isCancelled = true;\n  if (this.db.taskqueue.isReady) {\n    this.emit('cancel');\n  }\n};\nfunction processChange(doc, metadata, opts) {\n  var changeList = [{rev: doc._rev}];\n  if (opts.style === 'all_docs') {\n    changeList = collectLeaves(metadata.rev_tree)\n    .map(function (x) { return {rev: x.rev}; });\n  }\n  var change = {\n    id: metadata.id,\n    changes: changeList,\n    doc: doc\n  };\n\n  if (isDeleted(metadata, doc._rev)) {\n    change.deleted = true;\n  }\n  if (opts.conflicts) {\n    change.doc._conflicts = collectConflicts(metadata);\n    if (!change.doc._conflicts.length) {\n      delete change.doc._conflicts;\n    }\n  }\n  return change;\n}\n\nChanges.prototype.doChanges = function (opts) {\n  var self = this;\n  var callback = opts.complete;\n\n  opts = clone(opts);\n  if ('live' in opts && !('continuous' in opts)) {\n    opts.continuous = opts.live;\n  }\n  opts.processChange = processChange;\n\n  if (opts.since === 'latest') {\n    opts.since = 'now';\n  }\n  if (!opts.since) {\n    opts.since = 0;\n  }\n  if (opts.since === 'now') {\n    this.db.info().then(function (info) {\n      /* istanbul ignore if */\n      if (self.isCancelled) {\n        callback(null, {status: 'cancelled'});\n        return;\n      }\n      opts.since = info.update_seq;\n      self.doChanges(opts);\n    }, callback);\n    return;\n  }\n\n  if (opts.continuous && opts.since !== 'now') {\n    this.db.info().then(function (info) {\n      self.startSeq = info.update_seq;\n    /* istanbul ignore next */\n    }, function (err) {\n      if (err.id === 'idbNull') {\n        // db closed before this returned thats ok\n        return;\n      }\n      throw err;\n    });\n  }\n\n  if (opts.filter && typeof opts.filter === 'string') {\n    if (opts.filter === '_view') {\n      opts.view = normalizeDesignDocFunctionName(opts.view);\n    } else {\n      opts.filter = normalizeDesignDocFunctionName(opts.filter);\n    }\n\n    if (this.db.type() !== 'http' && !opts.doc_ids) {\n      return this.filterChanges(opts);\n    }\n  }\n\n  if (!('descending' in opts)) {\n    opts.descending = false;\n  }\n\n  // 0 and 1 should return 1 document\n  opts.limit = opts.limit === 0 ? 1 : opts.limit;\n  opts.complete = callback;\n  var newPromise = this.db._changes(opts);\n  if (newPromise && typeof newPromise.cancel === 'function') {\n    var cancel = self.cancel;\n    self.cancel = getArguments(function (args) {\n      newPromise.cancel();\n      cancel.apply(this, args);\n    });\n  }\n};\n\nChanges.prototype.filterChanges = function (opts) {\n  var self = this;\n  var callback = opts.complete;\n  if (opts.filter === '_view') {\n    if (!opts.view || typeof opts.view !== 'string') {\n      var err = createError(BAD_REQUEST,\n        '`view` filter parameter not found or invalid.');\n      return callback(err);\n    }\n    // fetch a view from a design doc, make it behave like a filter\n    var viewName = parseDesignDocFunctionName(opts.view);\n    this.db.getView(viewName[0], viewName[1], function (err, view) {\n      /* istanbul ignore if */\n      if (self.isCancelled) {\n        return callback(null, {status: 'cancelled'});\n      }\n      /* istanbul ignore next */\n      if (err) {\n        return callback(generateErrorFromResponse(err));\n      }\n      if (!view.map) {\n        return callback(createError(MISSING_DOC));\n      }\n      opts.filter = evalView(view.map);\n      self.doChanges(opts);\n    });\n  } else {\n    // fetch a filter from a design doc\n    var filterName = parseDesignDocFunctionName(opts.filter);\n    if (!filterName) {\n      return self.doChanges(opts);\n    }\n    this.db.getFilter(filterName[0], filterName[1], function (err, filterFun) {\n      /* istanbul ignore if */\n      if (self.isCancelled) {\n        return callback(null, {status: 'cancelled'});\n      }\n      /* istanbul ignore next */\n      if (err) {\n        return callback(generateErrorFromResponse(err));\n      }\n      opts.filter = evalFilter(filterFun);\n      self.doChanges(opts);\n    });\n  }\n};\n\n// shim for P/CouchDB adapters that don't directly implement _bulk_get\nfunction bulkGet(db, opts, callback) {\n  var requests = Array.isArray(opts) ? opts : opts.docs;\n\n  // consolidate into one request per doc if possible\n  var requestsById = {};\n  requests.forEach(function (request) {\n    if (request.id in requestsById) {\n      requestsById[request.id].push(request);\n    } else {\n      requestsById[request.id] = [request];\n    }\n  });\n\n  var numDocs = Object.keys(requestsById).length;\n  var numDone = 0;\n  var perDocResults = new Array(numDocs);\n\n  function collapseResults() {\n    var results = [];\n    perDocResults.forEach(function (res) {\n      res.docs.forEach(function (info) {\n        results.push({\n          id: res.id,\n          docs: [info]\n        });\n      });\n    });\n    callback(null, {results: results});\n  }\n\n  function checkDone() {\n    if (++numDone === numDocs) {\n      collapseResults();\n    }\n  }\n\n  function gotResult(i, id, docs) {\n    perDocResults[i] = {id: id, docs: docs};\n    checkDone();\n  }\n\n  Object.keys(requestsById).forEach(function (docId, i) {\n\n    var docRequests = requestsById[docId];\n\n    // just use the first request as the \"template\"\n    // TODO: The _bulk_get API allows for more subtle use cases than this,\n    // but for now it is unlikely that there will be a mix of different\n    // \"atts_since\" or \"attachments\" in the same request, since it's just\n    // replicate.js that is using this for the moment.\n    // Also, atts_since is aspirational, since we don't support it yet.\n    var docOpts = pick(docRequests[0], ['atts_since', 'attachments']);\n    docOpts.open_revs = docRequests.map(function (request) {\n      // rev is optional, open_revs disallowed\n      return request.rev;\n    });\n\n    // remove falsey / undefined revisions\n    docOpts.open_revs = docOpts.open_revs.filter(function (e) { return e; });\n\n    var formatResult = function (result) { return result; };\n\n    if (docOpts.open_revs.length === 0) {\n      delete docOpts.open_revs;\n\n      // when fetching only the \"winning\" leaf,\n      // transform the result so it looks like an open_revs\n      // request\n      formatResult = function (result) {\n        return [{\n          ok: result\n        }];\n      };\n    }\n\n    // globally-supplied options\n    ['revs', 'attachments', 'binary'].forEach(function (param) {\n      if (param in opts) {\n        docOpts[param] = opts[param];\n      }\n    });\n    db.get(docId, docOpts, function (err, res) {\n      gotResult(i, docId, err ? [{error: err}] : formatResult(res));\n    });\n  });\n}\n\nfunction isLocalId(id) {\n  return (/^_local/).test(id);\n}\n\n// build up a list of all the paths to the leafs in this revision tree\nfunction rootToLeaf(revs) {\n  var paths = [];\n  var toVisit = revs.slice();\n  var node;\n  while ((node = toVisit.pop())) {\n    var pos = node.pos;\n    var tree = node.ids;\n    var id = tree[0];\n    var opts = tree[1];\n    var branches = tree[2];\n    var isLeaf = branches.length === 0;\n\n    var history = node.history ? node.history.slice() : [];\n    history.push({id: id, opts: opts});\n    if (isLeaf) {\n      paths.push({pos: (pos + 1 - history.length), ids: history});\n    }\n    for (var i = 0, len = branches.length; i < len; i++) {\n      toVisit.push({pos: pos + 1, ids: branches[i], history: history});\n    }\n  }\n  return paths.reverse();\n}\n\n// BEGIN Math.uuid.js\n\n/*!\nMath.uuid.js (v1.4)\nhttp://www.broofa.com\nmailto:robert@broofa.com\n\nCopyright (c) 2010 Robert Kieffer\nDual licensed under the MIT and GPL licenses.\n*/\n\n/*\n * Generate a random uuid.\n *\n * USAGE: Math.uuid(length, radix)\n *   length - the desired number of characters\n *   radix  - the number of allowable values for each character.\n *\n * EXAMPLES:\n *   // No arguments  - returns RFC4122, version 4 ID\n *   >>> Math.uuid()\n *   \"92329D39-6F5C-4520-ABFC-AAB64544E172\"\n *\n *   // One argument - returns ID of the specified length\n *   >>> Math.uuid(15)     // 15 character ID (default base=62)\n *   \"VcydxgltxrVZSTV\"\n *\n *   // Two arguments - returns ID of the specified length, and radix. \n *   // (Radix must be <= 62)\n *   >>> Math.uuid(8, 2)  // 8 character ID (base=2)\n *   \"01001010\"\n *   >>> Math.uuid(8, 10) // 8 character ID (base=10)\n *   \"47473046\"\n *   >>> Math.uuid(8, 16) // 8 character ID (base=16)\n *   \"098F4D35\"\n */\nvar chars = (\n  '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ' +\n  'abcdefghijklmnopqrstuvwxyz'\n).split('');\nfunction getValue(radix) {\n  return 0 | Math.random() * radix;\n}\nfunction uuid(len, radix) {\n  radix = radix || chars.length;\n  var out = '';\n  var i = -1;\n\n  if (len) {\n    // Compact form\n    while (++i < len) {\n      out += chars[getValue(radix)];\n    }\n    return out;\n  }\n    // rfc4122, version 4 form\n    // Fill in random data.  At i==19 set the high bits of clock sequence as\n    // per rfc4122, sec. 4.1.5\n  while (++i < 36) {\n    switch (i) {\n      case 8:\n      case 13:\n      case 18:\n      case 23:\n        out += '-';\n        break;\n      case 19:\n        out += chars[(getValue(16) & 0x3) | 0x8];\n        break;\n      default:\n        out += chars[getValue(16)];\n    }\n  }\n\n  return out;\n}\n\nfunction toObject(array) {\n  return array.reduce(function (obj, item) {\n    obj[item] = true;\n    return obj;\n  }, {});\n}\n// List of top level reserved words for doc\nvar reservedWords = toObject([\n  '_id',\n  '_rev',\n  '_attachments',\n  '_deleted',\n  '_revisions',\n  '_revs_info',\n  '_conflicts',\n  '_deleted_conflicts',\n  '_local_seq',\n  '_rev_tree',\n  //replication documents\n  '_replication_id',\n  '_replication_state',\n  '_replication_state_time',\n  '_replication_state_reason',\n  '_replication_stats',\n  // Specific to Couchbase Sync Gateway\n  '_removed'\n]);\n\n// List of reserved words that should end up the document\nvar dataWords = toObject([\n  '_attachments',\n  //replication documents\n  '_replication_id',\n  '_replication_state',\n  '_replication_state_time',\n  '_replication_state_reason',\n  '_replication_stats'\n]);\n\n// Determine id an ID is valid\n//   - invalid IDs begin with an underescore that does not begin '_design' or\n//     '_local'\n//   - any other string value is a valid id\n// Returns the specific error object for each case\nfunction invalidIdError(id) {\n  var err;\n  if (!id) {\n    err = createError(MISSING_ID);\n  } else if (typeof id !== 'string') {\n    err = createError(INVALID_ID);\n  } else if (/^_/.test(id) && !(/^_(design|local)/).test(id)) {\n    err = createError(RESERVED_ID);\n  }\n  if (err) {\n    throw err;\n  }\n}\n\nfunction parseRevisionInfo(rev) {\n  if (!/^\\d+\\-./.test(rev)) {\n    return createError(INVALID_REV);\n  }\n  var idx = rev.indexOf('-');\n  var left = rev.substring(0, idx);\n  var right = rev.substring(idx + 1);\n  return {\n    prefix: parseInt(left, 10),\n    id: right\n  };\n}\n\nfunction makeRevTreeFromRevisions(revisions, opts) {\n  var pos = revisions.start - revisions.ids.length + 1;\n\n  var revisionIds = revisions.ids;\n  var ids = [revisionIds[0], opts, []];\n\n  for (var i = 1, len = revisionIds.length; i < len; i++) {\n    ids = [revisionIds[i], {status: 'missing'}, [ids]];\n  }\n\n  return [{\n    pos: pos,\n    ids: ids\n  }];\n}\n\n// Preprocess documents, parse their revisions, assign an id and a\n// revision for new writes that are missing them, etc\nfunction parseDoc(doc, newEdits) {\n\n  var nRevNum;\n  var newRevId;\n  var revInfo;\n  var opts = {status: 'available'};\n  if (doc._deleted) {\n    opts.deleted = true;\n  }\n\n  if (newEdits) {\n    if (!doc._id) {\n      doc._id = uuid();\n    }\n    newRevId = uuid(32, 16).toLowerCase();\n    if (doc._rev) {\n      revInfo = parseRevisionInfo(doc._rev);\n      if (revInfo.error) {\n        return revInfo;\n      }\n      doc._rev_tree = [{\n        pos: revInfo.prefix,\n        ids: [revInfo.id, {status: 'missing'}, [[newRevId, opts, []]]]\n      }];\n      nRevNum = revInfo.prefix + 1;\n    } else {\n      doc._rev_tree = [{\n        pos: 1,\n        ids : [newRevId, opts, []]\n      }];\n      nRevNum = 1;\n    }\n  } else {\n    if (doc._revisions) {\n      doc._rev_tree = makeRevTreeFromRevisions(doc._revisions, opts);\n      nRevNum = doc._revisions.start;\n      newRevId = doc._revisions.ids[0];\n    }\n    if (!doc._rev_tree) {\n      revInfo = parseRevisionInfo(doc._rev);\n      if (revInfo.error) {\n        return revInfo;\n      }\n      nRevNum = revInfo.prefix;\n      newRevId = revInfo.id;\n      doc._rev_tree = [{\n        pos: nRevNum,\n        ids: [newRevId, opts, []]\n      }];\n    }\n  }\n\n  invalidIdError(doc._id);\n\n  doc._rev = nRevNum + '-' + newRevId;\n\n  var result = {metadata : {}, data : {}};\n  for (var key in doc) {\n    /* istanbul ignore else */\n    if (Object.prototype.hasOwnProperty.call(doc, key)) {\n      var specialKey = key[0] === '_';\n      if (specialKey && !reservedWords[key]) {\n        var error = createError(DOC_VALIDATION, key);\n        error.message = DOC_VALIDATION.message + ': ' + key;\n        throw error;\n      } else if (specialKey && !dataWords[key]) {\n        result.metadata[key.slice(1)] = doc[key];\n      } else {\n        result.data[key] = doc[key];\n      }\n    }\n  }\n  return result;\n}\n\n/*\n * A generic pouch adapter\n */\n\nfunction compare(left, right) {\n  return left < right ? -1 : left > right ? 1 : 0;\n}\n\n// returns first element of arr satisfying callback predicate\nfunction arrayFirst(arr, callback) {\n  for (var i = 0; i < arr.length; i++) {\n    if (callback(arr[i], i) === true) {\n      return arr[i];\n    }\n  }\n}\n\n// Wrapper for functions that call the bulkdocs api with a single doc,\n// if the first result is an error, return an error\nfunction yankError(callback) {\n  return function (err, results) {\n    if (err || (results[0] && results[0].error)) {\n      callback(err || results[0]);\n    } else {\n      callback(null, results.length ? results[0]  : results);\n    }\n  };\n}\n\n// clean docs given to us by the user\nfunction cleanDocs(docs) {\n  for (var i = 0; i < docs.length; i++) {\n    var doc = docs[i];\n    if (doc._deleted) {\n      delete doc._attachments; // ignore atts for deleted docs\n    } else if (doc._attachments) {\n      // filter out extraneous keys from _attachments\n      var atts = Object.keys(doc._attachments);\n      for (var j = 0; j < atts.length; j++) {\n        var att = atts[j];\n        doc._attachments[att] = pick(doc._attachments[att],\n          ['data', 'digest', 'content_type', 'length', 'revpos', 'stub']);\n      }\n    }\n  }\n}\n\n// compare two docs, first by _id then by _rev\nfunction compareByIdThenRev(a, b) {\n  var idCompare = compare(a._id, b._id);\n  if (idCompare !== 0) {\n    return idCompare;\n  }\n  var aStart = a._revisions ? a._revisions.start : 0;\n  var bStart = b._revisions ? b._revisions.start : 0;\n  return compare(aStart, bStart);\n}\n\n// for every node in a revision tree computes its distance from the closest\n// leaf\nfunction computeHeight(revs) {\n  var height = {};\n  var edges = [];\n  traverseRevTree(revs, function (isLeaf, pos, id, prnt) {\n    var rev = pos + \"-\" + id;\n    if (isLeaf) {\n      height[rev] = 0;\n    }\n    if (prnt !== undefined) {\n      edges.push({from: prnt, to: rev});\n    }\n    return rev;\n  });\n\n  edges.reverse();\n  edges.forEach(function (edge) {\n    if (height[edge.from] === undefined) {\n      height[edge.from] = 1 + height[edge.to];\n    } else {\n      height[edge.from] = Math.min(height[edge.from], 1 + height[edge.to]);\n    }\n  });\n  return height;\n}\n\nfunction allDocsKeysQuery(api, opts, callback) {\n  var keys =  ('limit' in opts) ?\n      opts.keys.slice(opts.skip, opts.limit + opts.skip) :\n      (opts.skip > 0) ? opts.keys.slice(opts.skip) : opts.keys;\n  if (opts.descending) {\n    keys.reverse();\n  }\n  if (!keys.length) {\n    return api._allDocs({limit: 0}, callback);\n  }\n  var finalResults = {\n    offset: opts.skip\n  };\n  return PouchPromise.all(keys.map(function (key) {\n    var subOpts = jsExtend.extend({key: key, deleted: 'ok'}, opts);\n    ['limit', 'skip', 'keys'].forEach(function (optKey) {\n      delete subOpts[optKey];\n    });\n    return new PouchPromise(function (resolve, reject) {\n      api._allDocs(subOpts, function (err, res) {\n        /* istanbul ignore if */\n        if (err) {\n          return reject(err);\n        }\n        finalResults.total_rows = res.total_rows;\n        resolve(res.rows[0] || {key: key, error: 'not_found'});\n      });\n    });\n  })).then(function (results) {\n    finalResults.rows = results;\n    return finalResults;\n  });\n}\n\n// all compaction is done in a queue, to avoid attaching\n// too many listeners at once\nfunction doNextCompaction(self) {\n  var task = self._compactionQueue[0];\n  var opts = task.opts;\n  var callback = task.callback;\n  self.get('_local/compaction').catch(function () {\n    return false;\n  }).then(function (doc) {\n    if (doc && doc.last_seq) {\n      opts.last_seq = doc.last_seq;\n    }\n    self._compact(opts, function (err, res) {\n      /* istanbul ignore if */\n      if (err) {\n        callback(err);\n      } else {\n        callback(null, res);\n      }\n      process.nextTick(function () {\n        self._compactionQueue.shift();\n        if (self._compactionQueue.length) {\n          doNextCompaction(self);\n        }\n      });\n    });\n  });\n}\n\nfunction attachmentNameError(name) {\n  if (name.charAt(0) === '_') {\n    return name + 'is not a valid attachment name, attachment ' +\n      'names cannot start with \\'_\\'';\n  }\n  return false;\n}\n\nfunction cacheUpdateRequired(api, cache, designDocName, callback) {\n  cache.seq = cache.seq || 0;\n  var changesOpts = {\n    doc_ids: [ '_design/' + designDocName ],\n    limit: 1,\n    since: cache.seq\n  };\n  api.changes(changesOpts).then(function(res) {\n    var latestSeq = res.results && res.results.length && res.results[0].seq;\n    if (latestSeq && latestSeq > cache.seq) {\n      // invalidate the cache\n      cache.seq = latestSeq;\n      delete cache.promise;\n    }\n    callback();\n  }).catch(callback);\n}\n\nfunction getDesignDocCache(api, designDocName, callback) {\n  api._ddocCache = api._ddocCache || {};\n  api._ddocCache[designDocName] = api._ddocCache[designDocName] || {};\n  var cache = api._ddocCache[designDocName];\n  cacheUpdateRequired(api, cache, designDocName, function(err) {\n    if (err) {\n      return callback(err);\n    }\n    if (!cache.promise) {\n      cache.promise = new PouchPromise(function (resolve, reject) {\n        api._get('_design/' + designDocName, {}, function (err, res) {\n          if (err) {\n            return reject(err);\n          }\n          var cache = {};\n          ['views', 'filters'].forEach(function(propertyName) {\n            cache[propertyName] = res.doc[propertyName];\n          });\n          resolve(cache);\n        });\n      });\n    }\n    cache.promise.then(function(cache) {\n      callback(null, cache);\n    }).catch(callback);\n  });\n}\n\nfunction getDesignDocProperty(api, designDocName, propertyName,\n                              propertyElement, callback) {\n  getDesignDocCache(api, designDocName, function(err, designDoc) {\n    if (err) {\n      return callback(err);\n    }\n    var element = designDoc[propertyName] &&\n                  designDoc[propertyName][propertyElement];\n    if (!element) {\n      return callback(createError(MISSING_DOC));\n    }\n    callback(null, element);\n  });\n}\n\ninherits(AbstractPouchDB, events.EventEmitter);\n\nfunction AbstractPouchDB() {\n  events.EventEmitter.call(this);\n}\n\nAbstractPouchDB.prototype.post =\n  adapterFun('post', function (doc, opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n  if (typeof doc !== 'object' || Array.isArray(doc)) {\n    return callback(createError(NOT_AN_OBJECT));\n  }\n  this.bulkDocs({docs: [doc]}, opts, yankError(callback));\n});\n\nAbstractPouchDB.prototype.put =\n  adapterFun('put', getArguments(function (args) {\n  var temp, temptype, opts, callback;\n  var doc = args.shift();\n  var id = '_id' in doc;\n  if (typeof doc !== 'object' || Array.isArray(doc)) {\n    callback = args.pop();\n    return callback(createError(NOT_AN_OBJECT));\n  }\n\n  /* eslint no-constant-condition: 0 */\n  while (true) {\n    temp = args.shift();\n    temptype = typeof temp;\n    if (temptype === \"string\" && !id) {\n      doc._id = temp;\n      id = true;\n    } else if (temptype === \"string\" && id && !('_rev' in doc)) {\n      doc._rev = temp;\n    } else if (temptype === \"object\") {\n      opts = temp;\n    } else if (temptype === \"function\") {\n      callback = temp;\n    }\n    if (!args.length) {\n      break;\n    }\n  }\n  opts = opts || {};\n  invalidIdError(doc._id);\n  if (isLocalId(doc._id) && typeof this._putLocal === 'function') {\n    if (doc._deleted) {\n      return this._removeLocal(doc, callback);\n    } else {\n      return this._putLocal(doc, callback);\n    }\n  }\n  this.bulkDocs({docs: [doc]}, opts, yankError(callback));\n}));\n\nAbstractPouchDB.prototype.putAttachment =\n  adapterFun('putAttachment', function (docId, attachmentId, rev,\n                                              blob, type) {\n  var api = this;\n  if (typeof type === 'function') {\n    type = blob;\n    blob = rev;\n    rev = null;\n  }\n  // Lets fix in https://github.com/pouchdb/pouchdb/issues/3267\n  /* istanbul ignore if */\n  if (typeof type === 'undefined') {\n    type = blob;\n    blob = rev;\n    rev = null;\n  }\n\n  function createAttachment(doc) {\n    doc._attachments = doc._attachments || {};\n    doc._attachments[attachmentId] = {\n      content_type: type,\n      data: blob\n    };\n    return api.put(doc);\n  }\n\n  return api.get(docId).then(function (doc) {\n    if (doc._rev !== rev) {\n      throw createError(REV_CONFLICT);\n    }\n\n    return createAttachment(doc);\n  }, function (err) {\n     // create new doc\n    /* istanbul ignore else */\n    if (err.reason === MISSING_DOC.message) {\n      return createAttachment({_id: docId});\n    } else {\n      throw err;\n    }\n  });\n});\n\nAbstractPouchDB.prototype.removeAttachment =\n  adapterFun('removeAttachment', function (docId, attachmentId, rev,\n                                                 callback) {\n  var self = this;\n  self.get(docId, function (err, obj) {\n    /* istanbul ignore if */\n    if (err) {\n      callback(err);\n      return;\n    }\n    if (obj._rev !== rev) {\n      callback(createError(REV_CONFLICT));\n      return;\n    }\n    /* istanbul ignore if */\n    if (!obj._attachments) {\n      return callback();\n    }\n    delete obj._attachments[attachmentId];\n    if (Object.keys(obj._attachments).length === 0) {\n      delete obj._attachments;\n    }\n    self.put(obj, callback);\n  });\n});\n\nAbstractPouchDB.prototype.remove =\n  adapterFun('remove', function (docOrId, optsOrRev, opts, callback) {\n  var doc;\n  if (typeof optsOrRev === 'string') {\n    // id, rev, opts, callback style\n    doc = {\n      _id: docOrId,\n      _rev: optsOrRev\n    };\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n  } else {\n    // doc, opts, callback style\n    doc = docOrId;\n    if (typeof optsOrRev === 'function') {\n      callback = optsOrRev;\n      opts = {};\n    } else {\n      callback = opts;\n      opts = optsOrRev;\n    }\n  }\n  opts = opts || {};\n  opts.was_delete = true;\n  var newDoc = {_id: doc._id, _rev: (doc._rev || opts.rev)};\n  newDoc._deleted = true;\n  if (isLocalId(newDoc._id) && typeof this._removeLocal === 'function') {\n    return this._removeLocal(doc, callback);\n  }\n  this.bulkDocs({docs: [newDoc]}, opts, yankError(callback));\n});\n\nAbstractPouchDB.prototype.revsDiff =\n  adapterFun('revsDiff', function (req, opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n  var ids = Object.keys(req);\n\n  if (!ids.length) {\n    return callback(null, {});\n  }\n\n  var count = 0;\n  var missing = new pouchdbCollections.Map();\n\n  function addToMissing(id, revId) {\n    if (!missing.has(id)) {\n      missing.set(id, {missing: []});\n    }\n    missing.get(id).missing.push(revId);\n  }\n\n  function processDoc(id, rev_tree) {\n    // Is this fast enough? Maybe we should switch to a set simulated by a map\n    var missingForId = req[id].slice(0);\n    traverseRevTree(rev_tree, function (isLeaf, pos, revHash, ctx,\n      opts) {\n        var rev = pos + '-' + revHash;\n        var idx = missingForId.indexOf(rev);\n        if (idx === -1) {\n          return;\n        }\n\n        missingForId.splice(idx, 1);\n        /* istanbul ignore if */\n        if (opts.status !== 'available') {\n          addToMissing(id, rev);\n        }\n      });\n\n    // Traversing the tree is synchronous, so now `missingForId` contains\n    // revisions that were not found in the tree\n    missingForId.forEach(function (rev) {\n      addToMissing(id, rev);\n    });\n  }\n\n  ids.map(function (id) {\n    this._getRevisionTree(id, function (err, rev_tree) {\n      if (err && err.status === 404 && err.message === 'missing') {\n        missing.set(id, {missing: req[id]});\n      } else if (err) {\n        /* istanbul ignore next */\n        return callback(err);\n      } else {\n        processDoc(id, rev_tree);\n      }\n\n      if (++count === ids.length) {\n        // convert LazyMap to object\n        var missingObj = {};\n        missing.forEach(function (value, key) {\n          missingObj[key] = value;\n        });\n        return callback(null, missingObj);\n      }\n    });\n  }, this);\n});\n\n// _bulk_get API for faster replication, as described in\n// https://github.com/apache/couchdb-chttpd/pull/33\n// At the \"abstract\" level, it will just run multiple get()s in\n// parallel, because this isn't much of a performance cost\n// for local databases (except the cost of multiple transactions, which is\n// small). The http adapter overrides this in order\n// to do a more efficient single HTTP request.\nAbstractPouchDB.prototype.bulkGet =\n  adapterFun('bulkGet', function (opts, callback) {\n  bulkGet(this, opts, callback);\n});\n\n// compact one document and fire callback\n// by compacting we mean removing all revisions which\n// are further from the leaf in revision tree than max_height\nAbstractPouchDB.prototype.compactDocument =\n  adapterFun('compactDocument', function (docId, maxHeight, callback) {\n  var self = this;\n  this._getRevisionTree(docId, function (err, revTree) {\n    /* istanbul ignore if */\n    if (err) {\n      return callback(err);\n    }\n    var height = computeHeight(revTree);\n    var candidates = [];\n    var revs = [];\n    Object.keys(height).forEach(function (rev) {\n      if (height[rev] > maxHeight) {\n        candidates.push(rev);\n      }\n    });\n\n    traverseRevTree(revTree, function (isLeaf, pos, revHash, ctx, opts) {\n      var rev = pos + '-' + revHash;\n      if (opts.status === 'available' && candidates.indexOf(rev) !== -1) {\n        revs.push(rev);\n      }\n    });\n    self._doCompaction(docId, revs, callback);\n  });\n});\n\n// compact the whole database using single document\n// compaction\nAbstractPouchDB.prototype.compact =\n  adapterFun('compact', function (opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n\n  var self = this;\n  opts = opts || {};\n\n  self._compactionQueue = self._compactionQueue || [];\n  self._compactionQueue.push({opts: opts, callback: callback});\n  if (self._compactionQueue.length === 1) {\n    doNextCompaction(self);\n  }\n});\nAbstractPouchDB.prototype._compact = function (opts, callback) {\n  var self = this;\n  var changesOpts = {\n    return_docs: false,\n    last_seq: opts.last_seq || 0\n  };\n  var promises = [];\n\n  function onChange(row) {\n    promises.push(self.compactDocument(row.id, 0));\n  }\n  function onComplete(resp) {\n    var lastSeq = resp.last_seq;\n    PouchPromise.all(promises).then(function () {\n      return upsert(self, '_local/compaction', function deltaFunc(doc) {\n        if (!doc.last_seq || doc.last_seq < lastSeq) {\n          doc.last_seq = lastSeq;\n          return doc;\n        }\n        return false; // somebody else got here first, don't update\n      });\n    }).then(function () {\n      callback(null, {ok: true});\n    }).catch(callback);\n  }\n  self.changes(changesOpts)\n    .on('change', onChange)\n    .on('complete', onComplete)\n    .on('error', callback);\n};\n/* Begin api wrappers. Specific functionality to storage belongs in the\n   _[method] */\nAbstractPouchDB.prototype.get =\n  adapterFun('get', function (id, opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n  if (typeof id !== 'string') {\n    return callback(createError(INVALID_ID));\n  }\n  if (isLocalId(id) && typeof this._getLocal === 'function') {\n    return this._getLocal(id, callback);\n  }\n  var leaves = [], self = this;\n\n  function finishOpenRevs() {\n    var result = [];\n    var count = leaves.length;\n    /* istanbul ignore if */\n    if (!count) {\n      return callback(null, result);\n    }\n    // order with open_revs is unspecified\n    leaves.forEach(function (leaf) {\n      self.get(id, {\n        rev: leaf,\n        revs: opts.revs,\n        attachments: opts.attachments\n      }, function (err, doc) {\n        if (!err) {\n          result.push({ok: doc});\n        } else {\n          result.push({missing: leaf});\n        }\n        count--;\n        if (!count) {\n          callback(null, result);\n        }\n      });\n    });\n  }\n\n  if (opts.open_revs) {\n    if (opts.open_revs === \"all\") {\n      this._getRevisionTree(id, function (err, rev_tree) {\n        if (err) {\n          return callback(err);\n        }\n        leaves = collectLeaves(rev_tree).map(function (leaf) {\n          return leaf.rev;\n        });\n        finishOpenRevs();\n      });\n    } else {\n      if (Array.isArray(opts.open_revs)) {\n        leaves = opts.open_revs;\n        for (var i = 0; i < leaves.length; i++) {\n          var l = leaves[i];\n          // looks like it's the only thing couchdb checks\n          if (!(typeof(l) === \"string\" && /^\\d+-/.test(l))) {\n            return callback(createError(INVALID_REV));\n          }\n        }\n        finishOpenRevs();\n      } else {\n        return callback(createError(UNKNOWN_ERROR,\n          'function_clause'));\n      }\n    }\n    return; // open_revs does not like other options\n  }\n\n  return this._get(id, opts, function (err, result) {\n    if (err) {\n      return callback(err);\n    }\n\n    var doc = result.doc;\n    var metadata = result.metadata;\n    var ctx = result.ctx;\n\n    if (opts.conflicts) {\n      var conflicts = collectConflicts(metadata);\n      if (conflicts.length) {\n        doc._conflicts = conflicts;\n      }\n    }\n\n    if (isDeleted(metadata, doc._rev)) {\n      doc._deleted = true;\n    }\n\n    if (opts.revs || opts.revs_info) {\n      var paths = rootToLeaf(metadata.rev_tree);\n      var path = arrayFirst(paths, function (arr) {\n        return arr.ids.map(function (x) { return x.id; })\n          .indexOf(doc._rev.split('-')[1]) !== -1;\n      });\n\n      var indexOfRev = path.ids.map(function (x) {return x.id; })\n        .indexOf(doc._rev.split('-')[1]) + 1;\n      var howMany = path.ids.length - indexOfRev;\n      path.ids.splice(indexOfRev, howMany);\n      path.ids.reverse();\n\n      if (opts.revs) {\n        doc._revisions = {\n          start: (path.pos + path.ids.length) - 1,\n          ids: path.ids.map(function (rev) {\n            return rev.id;\n          })\n        };\n      }\n      if (opts.revs_info) {\n        var pos =  path.pos + path.ids.length;\n        doc._revs_info = path.ids.map(function (rev) {\n          pos--;\n          return {\n            rev: pos + '-' + rev.id,\n            status: rev.opts.status\n          };\n        });\n      }\n    }\n\n    if (opts.attachments && doc._attachments) {\n      var attachments = doc._attachments;\n      var count = Object.keys(attachments).length;\n      if (count === 0) {\n        return callback(null, doc);\n      }\n      Object.keys(attachments).forEach(function (key) {\n        this._getAttachment(attachments[key], {\n          binary: opts.binary,\n          ctx: ctx\n        }, function (err, data) {\n          var att = doc._attachments[key];\n          att.data = data;\n          delete att.stub;\n          delete att.length;\n          if (!--count) {\n            callback(null, doc);\n          }\n        });\n      }, self);\n    } else {\n      if (doc._attachments) {\n        for (var key in doc._attachments) {\n          /* istanbul ignore else */\n          if (doc._attachments.hasOwnProperty(key)) {\n            doc._attachments[key].stub = true;\n          }\n        }\n      }\n      callback(null, doc);\n    }\n  });\n});\n\nAbstractPouchDB.prototype.getView =\n  adapterFun('getView', function (designDocName, viewName, callback) {\n  getDesignDocProperty(this, designDocName, 'views', viewName, callback);\n});\n\nAbstractPouchDB.prototype.getFilter =\n  adapterFun('getFilter', function (designDocName, filterName, callback) {\n  getDesignDocProperty(this, designDocName, 'filters', filterName, callback);\n});\n\nAbstractPouchDB.prototype.getAttachment =\n  adapterFun('getAttachment', function (docId, attachmentId, opts,\n                                              callback) {\n  var self = this;\n  if (opts instanceof Function) {\n    callback = opts;\n    opts = {};\n  }\n  this._get(docId, opts, function (err, res) {\n    if (err) {\n      return callback(err);\n    }\n    if (res.doc._attachments && res.doc._attachments[attachmentId]) {\n      opts.ctx = res.ctx;\n      opts.binary = true;\n      self._getAttachment(res.doc._attachments[attachmentId], opts, callback);\n    } else {\n      return callback(createError(MISSING_DOC));\n    }\n  });\n});\n\nAbstractPouchDB.prototype.allDocs =\n  adapterFun('allDocs', function (opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n  opts.skip = typeof opts.skip !== 'undefined' ? opts.skip : 0;\n  if (opts.start_key) {\n    opts.startkey = opts.start_key;\n  }\n  if (opts.end_key) {\n    opts.endkey = opts.end_key;\n  }\n  if ('keys' in opts) {\n    if (!Array.isArray(opts.keys)) {\n      return callback(new TypeError('options.keys must be an array'));\n    }\n    var incompatibleOpt =\n      ['startkey', 'endkey', 'key'].filter(function (incompatibleOpt) {\n      return incompatibleOpt in opts;\n    })[0];\n    if (incompatibleOpt) {\n      callback(createError(QUERY_PARSE_ERROR,\n        'Query parameter `' + incompatibleOpt +\n        '` is not compatible with multi-get'\n      ));\n      return;\n    }\n    if (this.type() !== 'http') {\n      return allDocsKeysQuery(this, opts, callback);\n    }\n  }\n\n  return this._allDocs(opts, callback);\n});\n\nAbstractPouchDB.prototype.changes = function (opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n  return new Changes(this, opts, callback);\n};\n\nAbstractPouchDB.prototype.close =\n  adapterFun('close', function (callback) {\n  this._closed = true;\n  return this._close(callback);\n});\n\nAbstractPouchDB.prototype.info = adapterFun('info', function (callback) {\n  var self = this;\n  this._info(function (err, info) {\n    if (err) {\n      return callback(err);\n    }\n    // assume we know better than the adapter, unless it informs us\n    info.db_name = info.db_name || self._db_name;\n    info.auto_compaction = !!(self.auto_compaction && self.type() !== 'http');\n    info.adapter = self.type();\n    callback(null, info);\n  });\n});\n\nAbstractPouchDB.prototype.id = adapterFun('id', function (callback) {\n  return this._id(callback);\n});\n\nAbstractPouchDB.prototype.type = function () {\n  /* istanbul ignore next */\n  return (typeof this._type === 'function') ? this._type() : this.adapter;\n};\n\nAbstractPouchDB.prototype.bulkDocs =\n  adapterFun('bulkDocs', function (req, opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n\n  opts = opts || {};\n\n  if (Array.isArray(req)) {\n    req = {\n      docs: req\n    };\n  }\n\n  if (!req || !req.docs || !Array.isArray(req.docs)) {\n    return callback(createError(MISSING_BULK_DOCS));\n  }\n\n  for (var i = 0; i < req.docs.length; ++i) {\n    if (typeof req.docs[i] !== 'object' || Array.isArray(req.docs[i])) {\n      return callback(createError(NOT_AN_OBJECT));\n    }\n  }\n\n  var attachmentError;\n  req.docs.forEach(function(doc) {\n    if (doc._attachments) {\n      Object.keys(doc._attachments).forEach(function (name) {\n        attachmentError = attachmentError || attachmentNameError(name);\n      });\n    }\n  });\n\n  if (attachmentError) {\n    return callback(createError(BAD_REQUEST, attachmentError));\n  }\n\n  if (!('new_edits' in opts)) {\n    if ('new_edits' in req) {\n      opts.new_edits = req.new_edits;\n    } else {\n      opts.new_edits = true;\n    }\n  }\n\n  if (!opts.new_edits && this.type() !== 'http') {\n    // ensure revisions of the same doc are sorted, so that\n    // the local adapter processes them correctly (#2935)\n    req.docs.sort(compareByIdThenRev);\n  }\n\n  cleanDocs(req.docs);\n\n  return this._bulkDocs(req, opts, function (err, res) {\n    if (err) {\n      return callback(err);\n    }\n    if (!opts.new_edits) {\n      // this is what couch does when new_edits is false\n      res = res.filter(function (x) {\n        return x.error;\n      });\n    }\n    callback(null, res);\n  });\n});\n\nAbstractPouchDB.prototype.registerDependentDatabase =\n  adapterFun('registerDependentDatabase', function (dependentDb,\n                                                          callback) {\n  var depDB = new this.constructor(dependentDb, this.__opts);\n\n  function diffFun(doc) {\n    doc.dependentDbs = doc.dependentDbs || {};\n    if (doc.dependentDbs[dependentDb]) {\n      return false; // no update required\n    }\n    doc.dependentDbs[dependentDb] = true;\n    return doc;\n  }\n  upsert(this, '_local/_pouch_dependentDbs', diffFun)\n    .then(function () {\n      callback(null, {db: depDB});\n    }).catch(callback);\n});\n\nAbstractPouchDB.prototype.destroy =\n  adapterFun('destroy', function (opts, callback) {\n\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n\n  var self = this;\n  var usePrefix = 'use_prefix' in self ? self.use_prefix : true;\n\n  function destroyDb() {\n    // call destroy method of the particular adaptor\n    self._destroy(opts, function (err, resp) {\n      if (err) {\n        return callback(err);\n      }\n      self._destroyed = true;\n      self.emit('destroyed');\n      callback(null, resp || { 'ok': true });\n    });\n  }\n\n  if (self.type() === 'http') {\n    // no need to check for dependent DBs if it's a remote DB\n    return destroyDb();\n  }\n\n  self.get('_local/_pouch_dependentDbs', function (err, localDoc) {\n    if (err) {\n      /* istanbul ignore if */\n      if (err.status !== 404) {\n        return callback(err);\n      } else { // no dependencies\n        return destroyDb();\n      }\n    }\n    var dependentDbs = localDoc.dependentDbs;\n    var PouchDB = self.constructor;\n    var deletedMap = Object.keys(dependentDbs).map(function (name) {\n      // use_prefix is only false in the browser\n      /* istanbul ignore next */\n      var trueName = usePrefix ?\n        name.replace(new RegExp('^' + PouchDB.prefix), '') : name;\n      return new PouchDB(trueName, self.__opts).destroy();\n    });\n    PouchPromise.all(deletedMap).then(destroyDb, callback);\n  });\n});\n\nfunction TaskQueue() {\n  this.isReady = false;\n  this.failed = false;\n  this.queue = [];\n}\n\nTaskQueue.prototype.execute = function () {\n  var fun;\n  if (this.failed) {\n    while ((fun = this.queue.shift())) {\n      fun(this.failed);\n    }\n  } else {\n    while ((fun = this.queue.shift())) {\n      fun();\n    }\n  }\n};\n\nTaskQueue.prototype.fail = function (err) {\n  this.failed = err;\n  this.execute();\n};\n\nTaskQueue.prototype.ready = function (db) {\n  this.isReady = true;\n  this.db = db;\n  this.execute();\n};\n\nTaskQueue.prototype.addTask = function (fun) {\n  this.queue.push(fun);\n  if (this.failed) {\n    this.execute();\n  }\n};\n\nfunction defaultCallback(err) {\n  /* istanbul ignore next */\n  if (err && global.debug) {\n    console.error(err);\n  }\n}\n\n// OK, so here's the deal. Consider this code:\n//     var db1 = new PouchDB('foo');\n//     var db2 = new PouchDB('foo');\n//     db1.destroy();\n// ^ these two both need to emit 'destroyed' events,\n// as well as the PouchDB constructor itself.\n// So we have one db object (whichever one got destroy() called on it)\n// responsible for emitting the initial event, which then gets emitted\n// by the constructor, which then broadcasts it to any other dbs\n// that may have been created with the same name.\nfunction prepareForDestruction(self, opts) {\n  var name = opts.originalName;\n  var ctor = self.constructor;\n  var destructionListeners = ctor._destructionListeners;\n\n  function onDestroyed() {\n    ctor.emit('destroyed', name);\n  }\n\n  function onConstructorDestroyed() {\n    self.removeListener('destroyed', onDestroyed);\n    self.emit('destroyed', self);\n  }\n\n  self.once('destroyed', onDestroyed);\n\n  // in setup.js, the constructor is primed to listen for destroy events\n  if (!destructionListeners.has(name)) {\n    destructionListeners.set(name, []);\n  }\n  destructionListeners.get(name).push(onConstructorDestroyed);\n}\n\ninherits(PouchDB, AbstractPouchDB);\nfunction PouchDB(name, opts, callback) {\n\n  if (!(this instanceof PouchDB)) {\n    return new PouchDB(name, opts, callback);\n  }\n  var self = this;\n  if (typeof opts === 'function' || typeof opts === 'undefined') {\n    callback = opts;\n    opts = {};\n  }\n\n  if (name && typeof name === 'object') {\n    opts = name;\n    name = undefined;\n  }\n  if (typeof callback === 'undefined') {\n    callback = defaultCallback;\n  }\n  name = name || opts.name;\n  opts = clone(opts);\n  // if name was specified via opts, ignore for the sake of dependentDbs\n  delete opts.name;\n  this.__opts = opts;\n  var oldCB = callback;\n  self.auto_compaction = opts.auto_compaction;\n  self.prefix = PouchDB.prefix;\n  AbstractPouchDB.call(self);\n  self.taskqueue = new TaskQueue();\n  var promise = new PouchPromise(function (fulfill, reject) {\n    callback = function (err, resp) {\n      /* istanbul ignore if */\n      if (err) {\n        return reject(err);\n      }\n      delete resp.then;\n      fulfill(resp);\n    };\n  \n    opts = clone(opts);\n    var originalName = opts.name || name;\n    var backend, error;\n    (function () {\n      try {\n\n        if (typeof originalName !== 'string') {\n          error = new Error('Missing/invalid DB name');\n          error.code = 400;\n          throw error;\n        }\n\n        backend = PouchDB.parseAdapter(originalName, opts);\n        \n        opts.originalName = originalName;\n        opts.name = backend.name;\n        if (opts.prefix && backend.adapter !== 'http' &&\n            backend.adapter !== 'https') {\n          opts.name = opts.prefix + opts.name;\n        }\n        opts.adapter = opts.adapter || backend.adapter;\n        self._adapter = opts.adapter;\n        debug('pouchdb:adapter')('Picked adapter: ' + opts.adapter);\n\n        self._db_name = originalName;\n        if (!PouchDB.adapters[opts.adapter]) {\n          error = new Error('Adapter is missing');\n          error.code = 404;\n          throw error;\n        }\n\n        /* istanbul ignore if */\n        if (!PouchDB.adapters[opts.adapter].valid()) {\n          error = new Error('Invalid Adapter');\n          error.code = 404;\n          throw error;\n        }\n      } catch (err) {\n        self.taskqueue.fail(err);\n      }\n    }());\n    if (error) {\n      return reject(error); // constructor error, see above\n    }\n    self.adapter = opts.adapter;\n\n    // needs access to PouchDB;\n    self.replicate = {};\n\n    self.replicate.from = function (url, opts, callback) {\n      return self.constructor.replicate(url, self, opts, callback);\n    };\n\n    self.replicate.to = function (url, opts, callback) {\n      return self.constructor.replicate(self, url, opts, callback);\n    };\n\n    self.sync = function (dbName, opts, callback) {\n      return self.constructor.sync(self, dbName, opts, callback);\n    };\n\n    self.replicate.sync = self.sync;\n\n    PouchDB.adapters[opts.adapter].call(self, opts, function (err) {\n      /* istanbul ignore if */\n      if (err) {\n        self.taskqueue.fail(err);\n        callback(err);\n        return;\n      }\n      prepareForDestruction(self, opts);\n\n      self.emit('created', self);\n      PouchDB.emit('created', opts.originalName);\n      self.taskqueue.ready(self);\n      callback(null, self);\n    });\n\n  });\n  promise.then(function (resp) {\n    oldCB(null, resp);\n  }, oldCB);\n  self.then = promise.then.bind(promise);\n  self.catch = promise.catch.bind(promise);\n}\n\nPouchDB.debug = debug;\n\nfunction isChromeApp() {\n  return (typeof chrome !== \"undefined\" &&\n    typeof chrome.storage !== \"undefined\" &&\n    typeof chrome.storage.local !== \"undefined\");\n}\n\nvar hasLocal;\n\nif (isChromeApp()) {\n  hasLocal = false;\n} else {\n  try {\n    localStorage.setItem('_pouch_check_localstorage', 1);\n    hasLocal = !!localStorage.getItem('_pouch_check_localstorage');\n  } catch (e) {\n    hasLocal = false;\n  }\n}\n\nfunction hasLocalStorage() {\n  return hasLocal;\n}\n\nPouchDB.adapters = {};\nPouchDB.preferredAdapters = [];\n\nPouchDB.prefix = '_pouch_';\n\nvar eventEmitter = new events.EventEmitter();\n\nfunction setUpEventEmitter(Pouch) {\n  Object.keys(events.EventEmitter.prototype).forEach(function (key) {\n    if (typeof events.EventEmitter.prototype[key] === 'function') {\n      Pouch[key] = eventEmitter[key].bind(eventEmitter);\n    }\n  });\n\n  // these are created in constructor.js, and allow us to notify each DB with\n  // the same name that it was destroyed, via the constructor object\n  var destructListeners = Pouch._destructionListeners = new pouchdbCollections.Map();\n  Pouch.on('destroyed', function onConstructorDestroyed(name) {\n    if (!destructListeners.has(name)) {\n      return;\n    }\n    destructListeners.get(name).forEach(function (callback) {\n      callback();\n    });\n    destructListeners.delete(name);\n  });\n}\n\nsetUpEventEmitter(PouchDB);\n\nPouchDB.parseAdapter = function (name, opts) {\n  var match = name.match(/([a-z\\-]*):\\/\\/(.*)/);\n  var adapter, adapterName;\n  if (match) {\n    // the http adapter expects the fully qualified name\n    name = /http(s?)/.test(match[1]) ? match[1] + '://' + match[2] : match[2];\n    adapter = match[1];\n    /* istanbul ignore if */\n    if (!PouchDB.adapters[adapter].valid()) {\n      throw 'Invalid adapter';\n    }\n    return {name: name, adapter: match[1]};\n  }\n\n  // check for browsers that have been upgraded from websql-only to websql+idb\n  var skipIdb = 'idb' in PouchDB.adapters && 'websql' in PouchDB.adapters &&\n    hasLocalStorage() &&\n    localStorage['_pouch__websqldb_' + PouchDB.prefix + name];\n\n\n  if (opts.adapter) {\n    adapterName = opts.adapter;\n  } else if (typeof opts !== 'undefined' && opts.db) {\n    adapterName = 'leveldb';\n  } else { // automatically determine adapter\n    for (var i = 0; i < PouchDB.preferredAdapters.length; ++i) {\n      adapterName = PouchDB.preferredAdapters[i];\n      if (adapterName in PouchDB.adapters) {\n        /* istanbul ignore if */\n        if (skipIdb && adapterName === 'idb') {\n          // log it, because this can be confusing during development\n          console.log('PouchDB is downgrading \"' + name + '\" to WebSQL to' +\n            ' avoid data loss, because it was already opened with WebSQL.');\n          continue; // keep using websql to avoid user data loss\n        }\n        break;\n      }\n    }\n  }\n\n  adapter = PouchDB.adapters[adapterName];\n\n  // if adapter is invalid, then an error will be thrown later\n  var usePrefix = (adapter && 'use_prefix' in adapter) ?\n      adapter.use_prefix : true;\n\n  return {\n    name: usePrefix ? (PouchDB.prefix + name) : name,\n    adapter: adapterName\n  };\n};\n\nPouchDB.adapter = function (id, obj, addToPreferredAdapters) {\n  if (obj.valid()) {\n    PouchDB.adapters[id] = obj;\n    if (addToPreferredAdapters) {\n      PouchDB.preferredAdapters.push(id);\n    }\n  }\n};\n\nPouchDB.plugin = function (obj) {\n  Object.keys(obj).forEach(function (id) {\n    PouchDB.prototype[id] = obj[id];\n  });\n\n  return PouchDB;\n};\n\nPouchDB.defaults = function (defaultOpts) {\n  function PouchAlt(name, opts, callback) {\n    if (!(this instanceof PouchAlt)) {\n      return new PouchAlt(name, opts, callback);\n    }\n\n    if (typeof opts === 'function' || typeof opts === 'undefined') {\n      callback = opts;\n      opts = {};\n    }\n    if (name && typeof name === 'object') {\n      opts = name;\n      name = undefined;\n    }\n\n    opts = jsExtend.extend({}, defaultOpts, opts);\n    PouchDB.call(this, name, opts, callback);\n  }\n\n  inherits(PouchAlt, PouchDB);\n\n  setUpEventEmitter(PouchAlt);\n\n  PouchAlt.preferredAdapters = PouchDB.preferredAdapters.slice();\n  Object.keys(PouchDB).forEach(function (key) {\n    if (!(key in PouchAlt)) {\n      PouchAlt[key] = PouchDB[key];\n    }\n  });\n\n  return PouchAlt;\n};\n\n// Abstracts constructing a Blob object, so it also works in older\n// browsers that don't support the native Blob constructor (e.g.\n// old QtWebKit versions, Android < 4.4).\nfunction createBlob(parts, properties) {\n  /* global BlobBuilder,MSBlobBuilder,MozBlobBuilder,WebKitBlobBuilder */\n  parts = parts || [];\n  properties = properties || {};\n  try {\n    return new Blob(parts, properties);\n  } catch (e) {\n    if (e.name !== \"TypeError\") {\n      throw e;\n    }\n    var Builder = typeof BlobBuilder !== 'undefined' ? BlobBuilder :\n                  typeof MSBlobBuilder !== 'undefined' ? MSBlobBuilder :\n                  typeof MozBlobBuilder !== 'undefined' ? MozBlobBuilder :\n                  WebKitBlobBuilder;\n    var builder = new Builder();\n    for (var i = 0; i < parts.length; i += 1) {\n      builder.append(parts[i]);\n    }\n    return builder.getBlob(properties.type);\n  }\n}\n\n// simplified API. universal browser support is assumed\nfunction readAsArrayBuffer(blob, callback) {\n  if (typeof FileReader === 'undefined') {\n    // fix for Firefox in a web worker:\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=901097\n    return callback(new FileReaderSync().readAsArrayBuffer(blob));\n  }\n\n  var reader = new FileReader();\n  reader.onloadend = function (e) {\n    var result = e.target.result || new ArrayBuffer(0);\n    callback(result);\n  };\n  reader.readAsArrayBuffer(blob);\n}\n\nfunction wrappedFetch() {\n  var wrappedPromise = {};\n\n  var promise = new PouchPromise(function(resolve, reject) {\n    wrappedPromise.resolve = resolve;\n    wrappedPromise.reject = reject;\n  });\n\n  var args = new Array(arguments.length);\n\n  for (var i = 0; i < args.length; i++) {\n    args[i] = arguments[i];\n  }\n\n  wrappedPromise.promise = promise;\n\n  PouchPromise.resolve().then(function () {\n    return fetch.apply(null, args);\n  }).then(function(response) {\n    wrappedPromise.resolve(response);\n  }).catch(function(error) {\n    wrappedPromise.reject(error);\n  });\n\n  return wrappedPromise;\n}\n\nfunction fetchRequest(options, callback) {\n  var wrappedPromise, timer, response;\n\n  var headers = new Headers();\n\n  var fetchOptions = {\n    method: options.method,\n    credentials: 'include',\n    headers: headers\n  };\n\n  if (options.json) {\n    headers.set('Accept', 'application/json');\n    headers.set('Content-Type', options.headers['Content-Type'] ||\n      'application/json');\n  }\n\n  if (options.body && (options.body instanceof Blob)) {\n    readAsArrayBuffer(options.body, function (arrayBuffer) {\n      fetchOptions.body = arrayBuffer;\n    });\n  } else if (options.body &&\n             options.processData &&\n             typeof options.body !== 'string') {\n    fetchOptions.body = JSON.stringify(options.body);\n  } else if ('body' in options) {\n    fetchOptions.body = options.body;\n  } else {\n    fetchOptions.body = null;\n  }\n\n  Object.keys(options.headers).forEach(function(key) {\n    if (options.headers.hasOwnProperty(key)) {\n      headers.set(key, options.headers[key]);\n    }\n  });\n\n  wrappedPromise = wrappedFetch(options.url, fetchOptions);\n\n  if (options.timeout > 0) {\n    timer = setTimeout(function() {\n      wrappedPromise.reject(new Error('Load timeout for resource: ' +\n        options.url));\n    }, options.timeout);\n  }\n\n  wrappedPromise.promise.then(function(fetchResponse) {\n    response = {\n      statusCode: fetchResponse.status\n    };\n\n    if (options.timeout > 0) {\n      clearTimeout(timer);\n    }\n\n    if (response.statusCode >= 200 && response.statusCode < 300) {\n      return options.binary ? fetchResponse.blob() : fetchResponse.text();\n    }\n\n    return fetchResponse.json();\n  }).then(function(result) {\n    if (response.statusCode >= 200 && response.statusCode < 300) {\n      callback(null, response, result);\n    } else {\n      callback(result, response);\n    }\n  }).catch(function(error) {\n    callback(error, response);\n  });\n\n  return {abort: wrappedPromise.reject};\n}\n\nfunction xhRequest(options, callback) {\n\n  var xhr, timer;\n\n  var abortReq = function () {\n    xhr.abort();\n  };\n\n  if (options.xhr) {\n    xhr = new options.xhr();\n  } else {\n    xhr = new XMLHttpRequest();\n  }\n\n  try {\n    xhr.open(options.method, options.url);\n  } catch (exception) {\n   /* error code hardcoded to throw INVALID_URL */\n    callback(exception, {statusCode: 413});\n  }\n\n  xhr.withCredentials = ('withCredentials' in options) ?\n    options.withCredentials : true;\n\n  if (options.method === 'GET') {\n    delete options.headers['Content-Type'];\n  } else if (options.json) {\n    options.headers.Accept = 'application/json';\n    options.headers['Content-Type'] = options.headers['Content-Type'] ||\n      'application/json';\n    if (options.body &&\n        options.processData &&\n        typeof options.body !== \"string\") {\n      options.body = JSON.stringify(options.body);\n    }\n  }\n\n  if (options.binary) {\n    xhr.responseType = 'arraybuffer';\n  }\n\n  if (!('body' in options)) {\n    options.body = null;\n  }\n\n  for (var key in options.headers) {\n    if (options.headers.hasOwnProperty(key)) {\n      xhr.setRequestHeader(key, options.headers[key]);\n    }\n  }\n\n  if (options.timeout > 0) {\n    timer = setTimeout(abortReq, options.timeout);\n    xhr.onprogress = function () {\n      clearTimeout(timer);\n      timer = setTimeout(abortReq, options.timeout);\n    };\n    if (typeof xhr.upload !== 'undefined') { // does not exist in ie9\n      xhr.upload.onprogress = xhr.onprogress;\n    }\n  }\n\n  xhr.onreadystatechange = function () {\n    if (xhr.readyState !== 4) {\n      return;\n    }\n\n    var response = {\n      statusCode: xhr.status\n    };\n\n    if (xhr.status >= 200 && xhr.status < 300) {\n      var data;\n      if (options.binary) {\n        data = createBlob([xhr.response || ''], {\n          type: xhr.getResponseHeader('Content-Type')\n        });\n      } else {\n        data = xhr.responseText;\n      }\n      callback(null, response, data);\n    } else {\n      var err = {};\n      try {\n        err = JSON.parse(xhr.response);\n      } catch(e) {}\n      callback(err, response);\n    }\n  };\n\n  if (options.body && (options.body instanceof Blob)) {\n    readAsArrayBuffer(options.body, function (arrayBuffer) {\n      xhr.send(arrayBuffer);\n    });\n  } else {\n    xhr.send(options.body);\n  }\n\n  return {abort: abortReq};\n}\n\nfunction testXhr() {\n  try {\n    new XMLHttpRequest();\n    return true;\n  } catch (err) {\n    return false;\n  }\n}\n\nvar hasXhr = testXhr();\n\nfunction ajax$1(options, callback) {\n  if (hasXhr || options.xhr) {\n    return xhRequest(options, callback);\n  } else {\n    return fetchRequest(options, callback);\n  }\n}\n\n// the blob already has a type; do nothing\nvar res = function () {};\n\nfunction defaultBody() {\n  return '';\n}\n\nfunction ajaxCore(options, callback) {\n\n  options = clone(options);\n\n  var defaultOptions = {\n    method : \"GET\",\n    headers: {},\n    json: true,\n    processData: true,\n    timeout: 10000,\n    cache: false\n  };\n\n  options = jsExtend.extend(defaultOptions, options);\n\n  function onSuccess(obj, resp, cb) {\n    if (!options.binary && options.json && typeof obj === 'string') {\n      try {\n        obj = JSON.parse(obj);\n      } catch (e) {\n        // Probably a malformed JSON from server\n        return cb(e);\n      }\n    }\n    if (Array.isArray(obj)) {\n      obj = obj.map(function (v) {\n        if (v.error || v.missing) {\n          return generateErrorFromResponse(v);\n        } else {\n          return v;\n        }\n      });\n    }\n    if (options.binary) {\n      res(obj, resp);\n    }\n    cb(null, obj, resp);\n  }\n\n  function onError(err, cb) {\n    var errParsed, errObj;\n    if (err.code && err.status) {\n      var err2 = new Error(err.message || err.code);\n      err2.status = err.status;\n      return cb(err2);\n    }\n    // We always get code && status in node\n    /* istanbul ignore next */\n    try {\n      errParsed = JSON.parse(err.responseText);\n      //would prefer not to have a try/catch clause\n      errObj = generateErrorFromResponse(errParsed);\n    } catch (e) {\n      errObj = generateErrorFromResponse(err);\n    }\n    /* istanbul ignore next */\n    cb(errObj);\n  }\n\n\n  if (options.json) {\n    if (!options.binary) {\n      options.headers.Accept = 'application/json';\n    }\n    options.headers['Content-Type'] = options.headers['Content-Type'] ||\n      'application/json';\n  }\n\n  if (options.binary) {\n    options.encoding = null;\n    options.json = false;\n  }\n\n  if (!options.processData) {\n    options.json = false;\n  }\n\n  return ajax$1(options, function (err, response, body) {\n    if (err) {\n      err.status = response ? response.statusCode : 400;\n      return onError(err, callback);\n    }\n\n    var error;\n    var content_type = response.headers && response.headers['content-type'];\n    var data = body || defaultBody();\n\n    // CouchDB doesn't always return the right content-type for JSON data, so\n    // we check for ^{ and }$ (ignoring leading/trailing whitespace)\n    if (!options.binary && (options.json || !options.processData) &&\n        typeof data !== 'object' &&\n        (/json/.test(content_type) ||\n         (/^[\\s]*\\{/.test(data) && /\\}[\\s]*$/.test(data)))) {\n      try {\n        data = JSON.parse(data.toString());\n      } catch (e) {}\n    }\n\n    if (response.statusCode >= 200 && response.statusCode < 300) {\n      onSuccess(data, response, callback);\n    } else {\n      error = generateErrorFromResponse(data);\n      error.status = response.statusCode;\n      callback(error);\n    }\n  });\n}\n\nfunction ajax(opts, callback) {\n\n  // cache-buster, specifically designed to work around IE's aggressive caching\n  // see http://www.dashbay.com/2011/05/internet-explorer-caches-ajax/\n  // Also Safari caches POSTs, so we need to cache-bust those too.\n  var ua = (navigator && navigator.userAgent) ?\n    navigator.userAgent.toLowerCase() : '';\n\n  var isSafari = ua.indexOf('safari') !== -1 && ua.indexOf('chrome') === -1;\n  var isIE = ua.indexOf('msie') !== -1;\n  var isEdge = ua.indexOf('edge') !== -1;\n\n  var shouldCacheBust = (isSafari && opts.method === 'POST') ||\n    ((isIE || isEdge) && opts.method === 'GET');\n\n  var cache = 'cache' in opts ? opts.cache : true;\n\n  if (shouldCacheBust || !cache) {\n    var hasArgs = opts.url.indexOf('?') !== -1;\n    opts.url += (hasArgs ? '&' : '?') + '_nonce=' + Date.now();\n  }\n\n  return ajaxCore(opts, callback);\n}\n\n// originally parseUri 1.2.2, now patched by us\n// (c) Steven Levithan <stevenlevithan.com>\n// MIT License\nvar keys = [\"source\", \"protocol\", \"authority\", \"userInfo\", \"user\", \"password\",\n    \"host\", \"port\", \"relative\", \"path\", \"directory\", \"file\", \"query\", \"anchor\"];\nvar qName =\"queryKey\";\nvar qParser = /(?:^|&)([^&=]*)=?([^&]*)/g;\n\n// use the \"loose\" parser\n/* jshint maxlen: false */\nvar parser = /^(?:(?![^:@]+:[^:@\\/]*@)([^:\\/?#.]+):)?(?:\\/\\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\\/?#]*)(?::(\\d*))?)(((\\/(?:[^?#](?![^?#\\/]*\\.[^?#\\/.]+(?:[?#]|$)))*\\/?)?([^?#\\/]*))(?:\\?([^#]*))?(?:#(.*))?)/;\n\nfunction parseUri(str) {\n  var m = parser.exec(str);\n  var uri = {};\n  var i = 14;\n\n  while (i--) {\n    var key = keys[i];\n    var value = m[i] || \"\";\n    var encoded = ['user', 'password'].indexOf(key) !== -1;\n    uri[key] = encoded ? decodeURIComponent(value) : value;\n  }\n\n  uri[qName] = {};\n  uri[keys[12]].replace(qParser, function ($0, $1, $2) {\n    if ($1) {\n      uri[qName][$1] = $2;\n    }\n  });\n\n  return uri;\n}\n\nvar atob$1 = function (str) {\n  return atob(str);\n};\n\nvar btoa$1 = function (str) {\n  return btoa(str);\n};\n\n// From http://stackoverflow.com/questions/14967647/ (continues on next line)\n// encode-decode-image-with-base64-breaks-image (2013-04-21)\nfunction binaryStringToArrayBuffer(bin) {\n  var length = bin.length;\n  var buf = new ArrayBuffer(length);\n  var arr = new Uint8Array(buf);\n  for (var i = 0; i < length; i++) {\n    arr[i] = bin.charCodeAt(i);\n  }\n  return buf;\n}\n\nfunction binStringToBluffer(binString, type) {\n  return createBlob([binaryStringToArrayBuffer(binString)], {type: type});\n}\n\nvar extend$1 = jsExtend__default.extend;\n\nvar utils = {\n  ajax: ajax,\n  parseUri: parseUri,\n  uuid: uuid,\n  Promise: PouchPromise,\n  atob: atob$1,\n  btoa: btoa$1,\n  binaryStringToBlobOrBuffer: binStringToBluffer,\n  clone: clone,\n  extend: extend$1,\n  createError: createError\n};\n\nfunction tryFilter(filter, doc, req) {\n  try {\n    return !filter(doc, req);\n  } catch (err) {\n    var msg = 'Filter function threw: ' + err.toString();\n    return createError(BAD_REQUEST, msg);\n  }\n}\n\nfunction filterChange(opts) {\n  var req = {};\n  var hasFilter = opts.filter && typeof opts.filter === 'function';\n  req.query = opts.query_params;\n\n  return function filter(change) {\n    if (!change.doc) {\n      // CSG sends events on the changes feed that don't have documents,\n      // this hack makes a whole lot of existing code robust.\n      change.doc = {};\n    }\n\n    var filterReturn = hasFilter && tryFilter(opts.filter, change.doc, req);\n\n    if (typeof filterReturn === 'object') {\n      return filterReturn;\n    }\n\n    if (filterReturn) {\n      return false;\n    }\n\n    if (!opts.include_docs) {\n      delete change.doc;\n    } else if (!opts.attachments) {\n      for (var att in change.doc._attachments) {\n        /* istanbul ignore else */\n        if (change.doc._attachments.hasOwnProperty(att)) {\n          change.doc._attachments[att].stub = true;\n        }\n      }\n    }\n    return true;\n  };\n}\n\n// designed to give info to browser users, who are disturbed\n// when they see http errors in the console\nfunction explainError(status, str) {\n  if ('console' in global && 'info' in console) {\n    console.info('The above ' + status + ' is totally normal. ' + str);\n  }\n}\n\nvar collate$1 = pouchCollate__default.collate;\n\nvar CHECKPOINT_VERSION = 1;\nvar REPLICATOR = \"pouchdb\";\n// This is an arbitrary number to limit the\n// amount of replication history we save in the checkpoint.\n// If we save too much, the checkpoing docs will become very big,\n// if we save fewer, we'll run a greater risk of having to\n// read all the changes from 0 when checkpoint PUTs fail\n// CouchDB 2.0 has a more involved history pruning,\n// but let's go for the simple version for now.\nvar CHECKPOINT_HISTORY_SIZE = 5;\nvar LOWEST_SEQ = 0;\n\nfunction updateCheckpoint(db, id, checkpoint, session, returnValue) {\n  return db.get(id).catch(function (err) {\n    if (err.status === 404) {\n      if (db.type() === 'http') {\n        explainError(\n          404, 'PouchDB is just checking if a remote checkpoint exists.'\n        );\n      }\n      return {\n        session_id: session,\n        _id: id,\n        history: [],\n        replicator: REPLICATOR,\n        version: CHECKPOINT_VERSION\n      };\n    }\n    throw err;\n  }).then(function (doc) {\n    if (returnValue.cancelled) {\n      return;\n    }\n    // Filter out current entry for this replication\n    doc.history = (doc.history || []).filter(function (item) {\n      return item.session_id !== session;\n    });\n\n    // Add the latest checkpoint to history\n    doc.history.unshift({\n      last_seq: checkpoint,\n      session_id: session\n    });\n\n    // Just take the last pieces in history, to\n    // avoid really big checkpoint docs.\n    // see comment on history size above\n    doc.history = doc.history.slice(0, CHECKPOINT_HISTORY_SIZE);\n\n    doc.version = CHECKPOINT_VERSION;\n    doc.replicator = REPLICATOR;\n\n    doc.session_id = session;\n    doc.last_seq = checkpoint;\n\n    return db.put(doc).catch(function (err) {\n      if (err.status === 409) {\n        // retry; someone is trying to write a checkpoint simultaneously\n        return updateCheckpoint(db, id, checkpoint, session, returnValue);\n      }\n      throw err;\n    });\n  });\n}\n\nfunction Checkpointer(src, target, id, returnValue) {\n  this.src = src;\n  this.target = target;\n  this.id = id;\n  this.returnValue = returnValue;\n}\n\nCheckpointer.prototype.writeCheckpoint = function (checkpoint, session) {\n  var self = this;\n  return this.updateTarget(checkpoint, session).then(function () {\n    return self.updateSource(checkpoint, session);\n  });\n};\n\nCheckpointer.prototype.updateTarget = function (checkpoint, session) {\n  return updateCheckpoint(this.target, this.id, checkpoint,\n      session, this.returnValue);\n};\n\nCheckpointer.prototype.updateSource = function (checkpoint, session) {\n  var self = this;\n  if (this.readOnlySource) {\n    return PouchPromise.resolve(true);\n  }\n  return updateCheckpoint(this.src, this.id, checkpoint,\n      session, this.returnValue)\n    .catch(function (err) {\n      if (isForbiddenError(err)) {\n        self.readOnlySource = true;\n        return true;\n      }\n      throw err;\n    });\n};\n\nvar comparisons = {\n  \"undefined\": function(targetDoc, sourceDoc) {\n    // This is the previous comparison function\n    if (collate$1(targetDoc.last_seq, sourceDoc.last_seq) === 0) {\n      return sourceDoc.last_seq;\n    }\n    /* istanbul ignore next */\n    return 0;\n  },\n  \"1\": function(targetDoc, sourceDoc) {\n    // This is the comparison function ported from CouchDB\n    return compareReplicationLogs(sourceDoc, targetDoc).last_seq;\n  }\n};\n\nCheckpointer.prototype.getCheckpoint = function () {\n  var self = this;\n  return self.target.get(self.id).then(function (targetDoc) {\n    if (self.readOnlySource) {\n      return PouchPromise.resolve(targetDoc.last_seq);\n    }\n\n    return self.src.get(self.id).then(function (sourceDoc) {\n      // Since we can't migrate an old version doc to a new one\n      // (no session id), we just go with the lowest seq in this case\n      /* istanbul ignore if */\n      if (targetDoc.version !== sourceDoc.version) {\n        return LOWEST_SEQ;\n      }\n\n      var version;\n      if (targetDoc.version) {\n        version = targetDoc.version.toString();\n      } else {\n        version = \"undefined\";\n      }\n\n      if (version in comparisons) {\n        return comparisons[version](targetDoc, sourceDoc);\n      }\n      /* istanbul ignore next */\n      return LOWEST_SEQ;\n    }, function (err) {\n      if (err.status === 404 && targetDoc.last_seq) {\n        return self.src.put({\n          _id: self.id,\n          last_seq: LOWEST_SEQ\n        }).then(function () {\n          return LOWEST_SEQ;\n        }, function (err) {\n          if (isForbiddenError(err)) {\n            self.readOnlySource = true;\n            return targetDoc.last_seq;\n          }\n          /* istanbul ignore next */\n          return LOWEST_SEQ;\n        });\n      }\n      throw err;\n    });\n  }).catch(function (err) {\n    if (err.status !== 404) {\n      throw err;\n    }\n    return LOWEST_SEQ;\n  });\n};\n// This checkpoint comparison is ported from CouchDBs source\n// they come from here:\n// https://github.com/apache/couchdb-couch-replicator/blob/master/src/couch_replicator.erl#L863-L906\n\nfunction compareReplicationLogs (srcDoc, tgtDoc) {\n  if (srcDoc.session_id === tgtDoc.session_id) {\n    return {\n      last_seq: srcDoc.last_seq,\n      history: srcDoc.history || []\n    };\n  }\n\n  var sourceHistory = srcDoc.history || [];\n  var targetHistory = tgtDoc.history || [];\n  return compareReplicationHistory(sourceHistory, targetHistory);\n}\n\nfunction compareReplicationHistory (sourceHistory, targetHistory) {\n  // the erlang loop via function arguments is not so easy to repeat in JS\n  // therefore, doing this as recursion\n  var S = sourceHistory[0];\n  var sourceRest = sourceHistory.slice(1);\n  var T = targetHistory[0];\n  var targetRest = targetHistory.slice(1);\n\n  if (!S || targetHistory.length === 0) {\n    return {\n      last_seq: LOWEST_SEQ,\n      history: []\n    };\n  }\n\n  var sourceId = S.session_id;\n  /* istanbul ignore if */\n  if (hasSessionId(sourceId, targetHistory)) {\n    return {\n      last_seq: S.last_seq,\n      history: sourceHistory\n    };\n  }\n\n  var targetId = T.session_id;\n  if (hasSessionId(targetId, sourceRest)) {\n    return {\n      last_seq: T.last_seq,\n      history: targetRest\n    };\n  }\n\n  return compareReplicationHistory(sourceRest, targetRest);\n}\n\nfunction hasSessionId (sessionId, history) {\n  var props = history[0];\n  var rest = history.slice(1);\n\n  if (!sessionId || history.length === 0) {\n    return false;\n  }\n\n  if (sessionId === props.session_id) {\n    return true;\n  }\n\n  return hasSessionId(sessionId, rest);\n}\n\nfunction isForbiddenError (err) {\n  return typeof err.status === 'number' && Math.floor(err.status / 100) === 4;\n}\n\nvar STARTING_BACK_OFF = 0;\n\nfunction randomNumber(min, max) {\n  min = parseInt(min, 10) || 0;\n  max = parseInt(max, 10);\n  if (max !== max || max <= min) {\n    max = (min || 1) << 1; //doubling\n  } else {\n    max = max + 1;\n  }\n  var ratio = Math.random();\n  var range = max - min;\n\n  return ~~(range * ratio + min); // ~~ coerces to an int, but fast.\n}\n\nfunction defaultBackOff(min) {\n  var max = 0;\n  if (!min) {\n    max = 2000;\n  }\n  return randomNumber(min, max);\n}\n\nfunction backOff(opts, returnValue, error, callback) {\n  if (opts.retry === false) {\n    returnValue.emit('error', error);\n    returnValue.removeAllListeners();\n    return;\n  }\n  if (typeof opts.back_off_function !== 'function') {\n    opts.back_off_function = defaultBackOff;\n  }\n  returnValue.emit('requestError', error);\n  if (returnValue.state === 'active' || returnValue.state === 'pending') {\n    returnValue.emit('paused', error);\n    returnValue.state = 'stopped';\n    returnValue.once('active', function () {\n      opts.current_back_off = STARTING_BACK_OFF;\n    });\n  }\n\n  opts.current_back_off = opts.current_back_off || STARTING_BACK_OFF;\n  opts.current_back_off = opts.back_off_function(opts.current_back_off);\n  setTimeout(callback, opts.current_back_off);\n}\n\nvar setImmediateShim = global.setImmediate || global.setTimeout;\nvar MD5_CHUNK_SIZE = 32768;\n\nfunction rawToBase64(raw) {\n  return btoa$1(raw);\n}\n\nfunction appendBuffer(buffer, data, start, end) {\n  if (start > 0 || end < data.byteLength) {\n    // only create a subarray if we really need to\n    data = new Uint8Array(data, start,\n      Math.min(end, data.byteLength) - start);\n  }\n  buffer.append(data);\n}\n\nfunction appendString(buffer, data, start, end) {\n  if (start > 0 || end < data.length) {\n    // only create a substring if we really need to\n    data = data.substring(start, end);\n  }\n  buffer.appendBinary(data);\n}\n\nvar md5 = toPromise(function (data, callback) {\n  var inputIsString = typeof data === 'string';\n  var len = inputIsString ? data.length : data.byteLength;\n  var chunkSize = Math.min(MD5_CHUNK_SIZE, len);\n  var chunks = Math.ceil(len / chunkSize);\n  var currentChunk = 0;\n  var buffer = inputIsString ? new Md5() : new Md5.ArrayBuffer();\n\n  var append = inputIsString ? appendString : appendBuffer;\n\n  function loadNextChunk() {\n    var start = currentChunk * chunkSize;\n    var end = start + chunkSize;\n    currentChunk++;\n    if (currentChunk < chunks) {\n      append(buffer, data, start, end);\n      setImmediateShim(loadNextChunk);\n    } else {\n      append(buffer, data, start, end);\n      var raw = buffer.end(true);\n      var base64 = rawToBase64(raw);\n      callback(null, base64);\n      buffer.destroy();\n    }\n  }\n  loadNextChunk();\n});\n\nfunction sortObjectPropertiesByKey(queryParams) {\n  return Object.keys(queryParams).sort(pouchCollate.collate).reduce(function (result, key) {\n    result[key] = queryParams[key];\n    return result;\n  }, {});\n}\n\n// Generate a unique id particular to this replication.\n// Not guaranteed to align perfectly with CouchDB's rep ids.\nfunction generateReplicationId(src, target, opts) {\n  var docIds = opts.doc_ids ? opts.doc_ids.sort(pouchCollate.collate) : '';\n  var filterFun = opts.filter ? opts.filter.toString() : '';\n  var queryParams = '';\n  var filterViewName =  '';\n\n  if (opts.filter && opts.query_params) {\n    queryParams = JSON.stringify(sortObjectPropertiesByKey(opts.query_params));\n  }\n\n  if (opts.filter && opts.filter === '_view') {\n    filterViewName = opts.view.toString();\n  }\n\n  return PouchPromise.all([src.id(), target.id()]).then(function (res) {\n    var queryData = res[0] + res[1] + filterFun + filterViewName +\n      queryParams + docIds;\n    return md5(queryData);\n  }).then(function (md5sum) {\n    // can't use straight-up md5 alphabet, because\n    // the char '/' is interpreted as being for attachments,\n    // and + is also not url-safe\n    md5sum = md5sum.replace(/\\//g, '.').replace(/\\+/g, '_');\n    return '_local/' + md5sum;\n  });\n}\n\nfunction isGenOne(rev) {\n  return /^1-/.test(rev);\n}\n\nfunction createBulkGetOpts(diffs) {\n  var requests = [];\n  Object.keys(diffs).forEach(function (id) {\n    var missingRevs = diffs[id].missing;\n    missingRevs.forEach(function (missingRev) {\n      requests.push({\n        id: id,\n        rev: missingRev\n      });\n    });\n  });\n\n  return {\n    docs: requests,\n    revs: true,\n    attachments: true,\n    binary: true\n  };\n}\n\n//\n// Fetch all the documents from the src as described in the \"diffs\",\n// which is a mapping of docs IDs to revisions. If the state ever\n// changes to \"cancelled\", then the returned promise will be rejected.\n// Else it will be resolved with a list of fetched documents.\n//\nfunction getDocs(src, diffs, state) {\n  diffs = clone(diffs); // we do not need to modify this\n\n  var resultDocs = [];\n\n  function getAllDocs() {\n\n    var bulkGetOpts = createBulkGetOpts(diffs);\n\n    if (!bulkGetOpts.docs.length) { // optimization: skip empty requests\n      return;\n    }\n\n    return src.bulkGet(bulkGetOpts).then(function (bulkGetResponse) {\n      /* istanbul ignore if */\n      if (state.cancelled) {\n        throw new Error('cancelled');\n      }\n      bulkGetResponse.results.forEach(function (bulkGetInfo) {\n        bulkGetInfo.docs.forEach(function (doc) {\n          if (doc.ok) {\n            resultDocs.push(doc.ok);\n          }\n        });\n      });\n    });\n  }\n\n  function hasAttachments(doc) {\n    return doc._attachments && Object.keys(doc._attachments).length > 0;\n  }\n\n  function fetchRevisionOneDocs(ids) {\n    // Optimization: fetch gen-1 docs and attachments in\n    // a single request using _all_docs\n    return src.allDocs({\n      keys: ids,\n      include_docs: true\n    }).then(function (res) {\n      if (state.cancelled) {\n        throw new Error('cancelled');\n      }\n      res.rows.forEach(function (row) {\n        if (row.deleted || !row.doc || !isGenOne(row.value.rev) ||\n            hasAttachments(row.doc)) {\n          // if any of these conditions apply, we need to fetch using get()\n          return;\n        }\n\n        // the doc we got back from allDocs() is sufficient\n        resultDocs.push(row.doc);\n        delete diffs[row.id];\n      });\n    });\n  }\n\n  function getRevisionOneDocs() {\n    // filter out the generation 1 docs and get them\n    // leaving the non-generation one docs to be got otherwise\n    var ids = Object.keys(diffs).filter(function (id) {\n      var missing = diffs[id].missing;\n      return missing.length === 1 && isGenOne(missing[0]);\n    });\n    if (ids.length > 0) {\n      return fetchRevisionOneDocs(ids);\n    }\n  }\n\n  function returnDocs() {\n    return resultDocs;\n  }\n\n  return PouchPromise.resolve()\n    .then(getRevisionOneDocs)\n    .then(getAllDocs)\n    .then(returnDocs);\n}\n\nfunction replicate(src, target, opts, returnValue, result) {\n  var batches = [];               // list of batches to be processed\n  var currentBatch;               // the batch currently being processed\n  var pendingBatch = {\n    seq: 0,\n    changes: [],\n    docs: []\n  }; // next batch, not yet ready to be processed\n  var writingCheckpoint = false;  // true while checkpoint is being written\n  var changesCompleted = false;   // true when all changes received\n  var replicationCompleted = false; // true when replication has completed\n  var last_seq = 0;\n  var continuous = opts.continuous || opts.live || false;\n  var batch_size = opts.batch_size || 100;\n  var batches_limit = opts.batches_limit || 10;\n  var changesPending = false;     // true while src.changes is running\n  var doc_ids = opts.doc_ids;\n  var repId;\n  var checkpointer;\n  var allErrors = [];\n  var changedDocs = [];\n  // Like couchdb, every replication gets a unique session id\n  var session = uuid();\n\n  result = result || {\n    ok: true,\n    start_time: new Date(),\n    docs_read: 0,\n    docs_written: 0,\n    doc_write_failures: 0,\n    errors: []\n  };\n\n  var changesOpts = {};\n  returnValue.ready(src, target);\n\n  function initCheckpointer() {\n    if (checkpointer) {\n      return PouchPromise.resolve();\n    }\n    return generateReplicationId(src, target, opts).then(function (res) {\n      repId = res;\n      checkpointer = new Checkpointer(src, target, repId, returnValue);\n    });\n  }\n\n  function writeDocs() {\n    changedDocs = [];\n\n    if (currentBatch.docs.length === 0) {\n      return;\n    }\n    var docs = currentBatch.docs;\n    return target.bulkDocs({docs: docs, new_edits: false}).then(function (res) {\n      if (returnValue.cancelled) {\n        completeReplication();\n        throw new Error('cancelled');\n      }\n      var errors = [];\n      var errorsById = {};\n      res.forEach(function (res) {\n        if (res.error) {\n          result.doc_write_failures++;\n          errors.push(res);\n          errorsById[res.id] = res;\n        }\n      });\n      allErrors = allErrors.concat(errors);\n      result.docs_written += currentBatch.docs.length - errors.length;\n      var non403s = errors.filter(function (error) {\n        return error.name !== 'unauthorized' && error.name !== 'forbidden';\n      });\n\n      docs.forEach(function(doc) {\n        var error = errorsById[doc._id];\n        if (error) {\n          returnValue.emit('denied', clone(error));\n        } else {\n          changedDocs.push(doc);\n        }\n      });\n\n      if (non403s.length > 0) {\n        var error = new Error('bulkDocs error');\n        error.other_errors = errors;\n        abortReplication('target.bulkDocs failed to write docs', error);\n        throw new Error('bulkWrite partial failure');\n      }\n    }, function (err) {\n      result.doc_write_failures += docs.length;\n      throw err;\n    });\n  }\n\n  function finishBatch() {\n    result.last_seq = last_seq = currentBatch.seq;\n    var outResult = clone(result);\n    if (changedDocs.length) {\n      outResult.docs = changedDocs;\n      returnValue.emit('change', outResult);\n    }\n    writingCheckpoint = true;\n    return checkpointer.writeCheckpoint(currentBatch.seq,\n        session).then(function () {\n      writingCheckpoint = false;\n      if (returnValue.cancelled) {\n        completeReplication();\n        throw new Error('cancelled');\n      }\n      currentBatch = undefined;\n      getChanges();\n    }).catch(function (err) {\n      writingCheckpoint = false;\n      abortReplication('writeCheckpoint completed with error', err);\n      throw err;\n    });\n  }\n\n  function getDiffs() {\n    var diff = {};\n    currentBatch.changes.forEach(function (change) {\n      // Couchbase Sync Gateway emits these, but we can ignore them\n      /* istanbul ignore if */\n      if (change.id === \"_user/\") {\n        return;\n      }\n      diff[change.id] = change.changes.map(function (x) {\n        return x.rev;\n      });\n    });\n    return target.revsDiff(diff).then(function (diffs) {\n      if (returnValue.cancelled) {\n        completeReplication();\n        throw new Error('cancelled');\n      }\n      // currentBatch.diffs elements are deleted as the documents are written\n      currentBatch.diffs = diffs;\n    });\n  }\n\n  function getBatchDocs() {\n    return getDocs(src, currentBatch.diffs, returnValue).then(function (docs) {\n      docs.forEach(function (doc) {\n        delete currentBatch.diffs[doc._id];\n        result.docs_read++;\n        currentBatch.docs.push(doc);\n      });\n    });\n  }\n\n  function startNextBatch() {\n    if (returnValue.cancelled || currentBatch) {\n      return;\n    }\n    if (batches.length === 0) {\n      processPendingBatch(true);\n      return;\n    }\n    currentBatch = batches.shift();\n    getDiffs()\n      .then(getBatchDocs)\n      .then(writeDocs)\n      .then(finishBatch)\n      .then(startNextBatch)\n      .catch(function (err) {\n        abortReplication('batch processing terminated with error', err);\n      });\n  }\n\n\n  function processPendingBatch(immediate) {\n    if (pendingBatch.changes.length === 0) {\n      if (batches.length === 0 && !currentBatch) {\n        if ((continuous && changesOpts.live) || changesCompleted) {\n          returnValue.state = 'pending';\n          returnValue.emit('paused');\n        }\n        if (changesCompleted) {\n          completeReplication();\n        }\n      }\n      return;\n    }\n    if (\n      immediate ||\n      changesCompleted ||\n      pendingBatch.changes.length >= batch_size\n    ) {\n      batches.push(pendingBatch);\n      pendingBatch = {\n        seq: 0,\n        changes: [],\n        docs: []\n      };\n      if (returnValue.state === 'pending' || returnValue.state === 'stopped') {\n        returnValue.state = 'active';\n        returnValue.emit('active');\n      }\n      startNextBatch();\n    }\n  }\n\n\n  function abortReplication(reason, err) {\n    if (replicationCompleted) {\n      return;\n    }\n    if (!err.message) {\n      err.message = reason;\n    }\n    result.ok = false;\n    result.status = 'aborting';\n    result.errors.push(err);\n    allErrors = allErrors.concat(err);\n    batches = [];\n    pendingBatch = {\n      seq: 0,\n      changes: [],\n      docs: []\n    };\n    completeReplication();\n  }\n\n\n  function completeReplication() {\n    if (replicationCompleted) {\n      return;\n    }\n    if (returnValue.cancelled) {\n      result.status = 'cancelled';\n      if (writingCheckpoint) {\n        return;\n      }\n    }\n    result.status = result.status || 'complete';\n    result.end_time = new Date();\n    result.last_seq = last_seq;\n    replicationCompleted = true;\n    var non403s = allErrors.filter(function (error) {\n      return error.name !== 'unauthorized' && error.name !== 'forbidden';\n    });\n    if (non403s.length > 0) {\n      var error = allErrors.pop();\n      if (allErrors.length > 0) {\n        error.other_errors = allErrors;\n      }\n      error.result = result;\n      backOff(opts, returnValue, error, function () {\n        replicate(src, target, opts, returnValue);\n      });\n    } else {\n      result.errors = allErrors;\n      returnValue.emit('complete', result);\n      returnValue.removeAllListeners();\n    }\n  }\n\n\n  function onChange(change) {\n    if (returnValue.cancelled) {\n      return completeReplication();\n    }\n    var filter = filterChange(opts)(change);\n    if (!filter) {\n      return;\n    }\n    pendingBatch.seq = change.seq;\n    pendingBatch.changes.push(change);\n    processPendingBatch(changesOpts.live);\n  }\n\n\n  function onChangesComplete(changes) {\n    changesPending = false;\n    if (returnValue.cancelled) {\n      return completeReplication();\n    }\n\n    // if no results were returned then we're done,\n    // else fetch more\n    if (changes.results.length > 0) {\n      changesOpts.since = changes.last_seq;\n      getChanges();\n    } else {\n      if (continuous) {\n        changesOpts.live = true;\n        getChanges();\n      } else {\n        changesCompleted = true;\n      }\n    }\n    processPendingBatch(true);\n  }\n\n\n  function onChangesError(err) {\n    changesPending = false;\n    /* istanbul ignore if */\n    if (returnValue.cancelled) {\n      return completeReplication();\n    }\n    abortReplication('changes rejected', err);\n  }\n\n\n  function getChanges() {\n    if (!(\n      !changesPending &&\n      !changesCompleted &&\n      batches.length < batches_limit\n      )) {\n      return;\n    }\n    changesPending = true;\n    function abortChanges() {\n      changes.cancel();\n    }\n    function removeListener() {\n      returnValue.removeListener('cancel', abortChanges);\n    }\n\n    if (returnValue._changes) { // remove old changes() and listeners\n      returnValue.removeListener('cancel', returnValue._abortChanges);\n      returnValue._changes.cancel();\n    }\n    returnValue.once('cancel', abortChanges);\n\n    var changes = src.changes(changesOpts)\n      .on('change', onChange);\n    changes.then(removeListener, removeListener);\n    changes.then(onChangesComplete)\n      .catch(onChangesError);\n\n    if (opts.retry) {\n      // save for later so we can cancel if necessary\n      returnValue._changes = changes;\n      returnValue._abortChanges = abortChanges;\n    }\n  }\n\n\n  function startChanges() {\n    initCheckpointer().then(function () {\n      if (returnValue.cancelled) {\n        completeReplication();\n        return;\n      }\n      return checkpointer.getCheckpoint().then(function (checkpoint) {\n        last_seq = checkpoint;\n        changesOpts = {\n          since: last_seq,\n          limit: batch_size,\n          batch_size: batch_size,\n          style: 'all_docs',\n          doc_ids: doc_ids,\n          return_docs: true // required so we know when we're done\n        };\n        if (opts.filter) {\n          if (typeof opts.filter !== 'string') {\n            // required for the client-side filter in onChange\n            changesOpts.include_docs = true;\n          } else { // ddoc filter\n            changesOpts.filter = opts.filter;\n          }\n        }\n        if ('heartbeat' in opts) {\n          changesOpts.heartbeat = opts.heartbeat;\n        }\n        if ('timeout' in opts) {\n          changesOpts.timeout = opts.timeout;\n        }\n        if (opts.query_params) {\n          changesOpts.query_params = opts.query_params;\n        }\n        if (opts.view) {\n          changesOpts.view = opts.view;\n        }\n        getChanges();\n      });\n    }).catch(function (err) {\n      abortReplication('getCheckpoint rejected with ', err);\n    });\n  }\n\n  /* istanbul ignore next */\n  function onCheckpointError(err) {\n    writingCheckpoint = false;\n    abortReplication('writeCheckpoint completed with error', err);\n    throw err;\n  }\n\n  /* istanbul ignore if */\n  if (returnValue.cancelled) { // cancelled immediately\n    completeReplication();\n    return;\n  }\n\n  if (!returnValue._addedListeners) {\n    returnValue.once('cancel', completeReplication);\n\n    if (typeof opts.complete === 'function') {\n      returnValue.once('error', opts.complete);\n      returnValue.once('complete', function (result) {\n        opts.complete(null, result);\n      });\n    }\n    returnValue._addedListeners = true;\n  }\n\n  if (typeof opts.since === 'undefined') {\n    startChanges();\n  } else {\n    initCheckpointer().then(function () {\n      writingCheckpoint = true;\n      return checkpointer.writeCheckpoint(opts.since, session);\n    }).then(function () {\n      writingCheckpoint = false;\n      /* istanbul ignore if */\n      if (returnValue.cancelled) {\n        completeReplication();\n        return;\n      }\n      last_seq = opts.since;\n      startChanges();\n    }).catch(onCheckpointError);\n  }\n}\n\n// We create a basic promise so the caller can cancel the replication possibly\n// before we have actually started listening to changes etc\ninherits(Replication, events.EventEmitter);\nfunction Replication() {\n  events.EventEmitter.call(this);\n  this.cancelled = false;\n  this.state = 'pending';\n  var self = this;\n  var promise = new PouchPromise(function (fulfill, reject) {\n    self.once('complete', fulfill);\n    self.once('error', reject);\n  });\n  self.then = function (resolve, reject) {\n    return promise.then(resolve, reject);\n  };\n  self.catch = function (reject) {\n    return promise.catch(reject);\n  };\n  // As we allow error handling via \"error\" event as well,\n  // put a stub in here so that rejecting never throws UnhandledError.\n  self.catch(function () {});\n}\n\nReplication.prototype.cancel = function () {\n  this.cancelled = true;\n  this.state = 'cancelled';\n  this.emit('cancel');\n};\n\nReplication.prototype.ready = function (src, target) {\n  var self = this;\n  if (self._readyCalled) {\n    return;\n  }\n  self._readyCalled = true;\n\n  function onDestroy() {\n    self.cancel();\n  }\n  src.once('destroyed', onDestroy);\n  target.once('destroyed', onDestroy);\n  function cleanup() {\n    src.removeListener('destroyed', onDestroy);\n    target.removeListener('destroyed', onDestroy);\n  }\n  self.once('complete', cleanup);\n};\n\nfunction toPouch(db, opts) {\n  var PouchConstructor = opts.PouchConstructor;\n  if (typeof db === 'string') {\n    return new PouchConstructor(db, opts);\n  } else {\n    return db;\n  }\n}\n\nfunction replicateWrapper(src, target, opts, callback) {\n\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n  if (typeof opts === 'undefined') {\n    opts = {};\n  }\n\n  if (opts.doc_ids && !Array.isArray(opts.doc_ids)) {\n    throw createError(BAD_REQUEST,\n                       \"`doc_ids` filter parameter is not a list.\");\n  }\n\n  opts.complete = callback;\n  opts = clone(opts);\n  opts.continuous = opts.continuous || opts.live;\n  opts.retry = ('retry' in opts) ? opts.retry : false;\n  /*jshint validthis:true */\n  opts.PouchConstructor = opts.PouchConstructor || this;\n  var replicateRet = new Replication(opts);\n  var srcPouch = toPouch(src, opts);\n  var targetPouch = toPouch(target, opts);\n  replicate(srcPouch, targetPouch, opts, replicateRet);\n  return replicateRet;\n}\n\nvar replication = {\n  replicate: replicateWrapper,\n  toPouch: toPouch\n};\n\nvar replicate$1 = replication.replicate;\ninherits(Sync, events.EventEmitter);\nfunction sync(src, target, opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n  if (typeof opts === 'undefined') {\n    opts = {};\n  }\n  opts = clone(opts);\n  /*jshint validthis:true */\n  opts.PouchConstructor = opts.PouchConstructor || this;\n  src = replication.toPouch(src, opts);\n  target = replication.toPouch(target, opts);\n  return new Sync(src, target, opts, callback);\n}\n\nfunction Sync(src, target, opts, callback) {\n  var self = this;\n  this.canceled = false;\n\n  var optsPush = opts.push ? jsExtend.extend({}, opts, opts.push) : opts;\n  var optsPull = opts.pull ? jsExtend.extend({}, opts, opts.pull) : opts;\n\n  this.push = replicate$1(src, target, optsPush);\n  this.pull = replicate$1(target, src, optsPull);\n\n  this.pushPaused = true;\n  this.pullPaused = true;\n\n  function pullChange(change) {\n    self.emit('change', {\n      direction: 'pull',\n      change: change\n    });\n  }\n  function pushChange(change) {\n    self.emit('change', {\n      direction: 'push',\n      change: change\n    });\n  }\n  function pushDenied(doc) {\n    self.emit('denied', {\n      direction: 'push',\n      doc: doc\n    });\n  }\n  function pullDenied(doc) {\n    self.emit('denied', {\n      direction: 'pull',\n      doc: doc\n    });\n  }\n  function pushPaused() {\n    self.pushPaused = true;\n    if (self.pullPaused) {\n      self.emit('paused');\n    }\n  }\n  function pullPaused() {\n    self.pullPaused = true;\n    if (self.pushPaused) {\n      self.emit('paused');\n    }\n  }\n  function pushActive() {\n    self.pushPaused = false;\n    if (self.pullPaused) {\n      self.emit('active', {\n        direction: 'push'\n      });\n    }\n  }\n  function pullActive() {\n    self.pullPaused = false;\n    /* istanbul ignore if */\n    if (self.pushPaused) {\n      self.emit('active', {\n        direction: 'pull'\n      });\n    }\n  }\n\n  var removed = {};\n\n  function removeAll(type) { // type is 'push' or 'pull'\n    return function (event, func) {\n      var isChange = event === 'change' &&\n        (func === pullChange || func === pushChange);\n      var isDenied = event === 'denied' &&\n        (func === pullDenied || func === pushDenied);\n      var isPaused = event === 'paused' &&\n        (func === pullPaused || func === pushPaused);\n      var isActive = event === 'active' &&\n        (func === pullActive || func === pushActive);\n\n      if (isChange || isDenied || isPaused || isActive) {\n        if (!(event in removed)) {\n          removed[event] = {};\n        }\n        removed[event][type] = true;\n        if (Object.keys(removed[event]).length === 2) {\n          // both push and pull have asked to be removed\n          self.removeAllListeners(event);\n        }\n      }\n    };\n  }\n\n  if (opts.live) {\n    this.push.on('complete', self.pull.cancel.bind(self.pull));\n    this.pull.on('complete', self.push.cancel.bind(self.push));\n  }\n\n  this.on('newListener', function (event) {\n    if (event === 'change') {\n      self.pull.on('change', pullChange);\n      self.push.on('change', pushChange);\n    } else if (event === 'denied') {\n      self.pull.on('denied', pullDenied);\n      self.push.on('denied', pushDenied);\n    } else if (event === 'active') {\n      self.pull.on('active', pullActive);\n      self.push.on('active', pushActive);\n    } else if (event === 'paused') {\n      self.pull.on('paused', pullPaused);\n      self.push.on('paused', pushPaused);\n    }\n  });\n\n  this.on('removeListener', function (event) {\n    if (event === 'change') {\n      self.pull.removeListener('change', pullChange);\n      self.push.removeListener('change', pushChange);\n    } else if (event === 'denied') {\n      self.pull.removeListener('denied', pullDenied);\n      self.push.removeListener('denied', pushDenied);\n    } else if (event === 'active') {\n      self.pull.removeListener('active', pullActive);\n      self.push.removeListener('active', pushActive);\n    } else if (event === 'paused') {\n      self.pull.removeListener('paused', pullPaused);\n      self.push.removeListener('paused', pushPaused);\n    }\n  });\n\n  this.pull.on('removeListener', removeAll('pull'));\n  this.push.on('removeListener', removeAll('push'));\n\n  var promise = PouchPromise.all([\n    this.push,\n    this.pull\n  ]).then(function (resp) {\n    var out = {\n      push: resp[0],\n      pull: resp[1]\n    };\n    self.emit('complete', out);\n    if (callback) {\n      callback(null, out);\n    }\n    self.removeAllListeners();\n    return out;\n  }, function (err) {\n    self.cancel();\n    if (callback) {\n      // if there's a callback, then the callback can receive\n      // the error event\n      callback(err);\n    } else {\n      // if there's no callback, then we're safe to emit an error\n      // event, which would otherwise throw an unhandled error\n      // due to 'error' being a special event in EventEmitters\n      self.emit('error', err);\n    }\n    self.removeAllListeners();\n    if (callback) {\n      // no sense throwing if we're already emitting an 'error' event\n      throw err;\n    }\n  });\n\n  this.then = function (success, err) {\n    return promise.then(success, err);\n  };\n\n  this.catch = function (err) {\n    return promise.catch(err);\n  };\n}\n\nSync.prototype.cancel = function () {\n  if (!this.canceled) {\n    this.canceled = true;\n    this.push.cancel();\n    this.pull.cancel();\n  }\n};\n\nfunction b64ToBluffer(b64, type) {\n  return binStringToBluffer(atob$1(b64), type);\n}\n\n//Can't find original post, but this is close\n//http://stackoverflow.com/questions/6965107/ (continues on next line)\n//converting-between-strings-and-arraybuffers\nfunction arrayBufferToBinaryString(buffer) {\n  var binary = '';\n  var bytes = new Uint8Array(buffer);\n  var length = bytes.byteLength;\n  for (var i = 0; i < length; i++) {\n    binary += String.fromCharCode(bytes[i]);\n  }\n  return binary;\n}\n\n// shim for browsers that don't support it\nfunction readAsBinaryString(blob, callback) {\n  if (typeof FileReader === 'undefined') {\n    // fix for Firefox in a web worker\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=901097\n    return callback(arrayBufferToBinaryString(\n      new FileReaderSync().readAsArrayBuffer(blob)));\n  }\n\n  var reader = new FileReader();\n  var hasBinaryString = typeof reader.readAsBinaryString === 'function';\n  reader.onloadend = function (e) {\n    var result = e.target.result || '';\n    if (hasBinaryString) {\n      return callback(result);\n    }\n    callback(arrayBufferToBinaryString(result));\n  };\n  if (hasBinaryString) {\n    reader.readAsBinaryString(blob);\n  } else {\n    reader.readAsArrayBuffer(blob);\n  }\n}\n\nfunction blobToBase64(blobOrBuffer) {\n  return new PouchPromise(function (resolve) {\n    readAsBinaryString(blobOrBuffer, function (bin) {\n      resolve(btoa$1(bin));\n    });\n  });\n}\n\nfunction flatten(arrs) {\n  var res = [];\n  for (var i = 0, len = arrs.length; i < len; i++) {\n    res = res.concat(arrs[i]);\n  }\n  return res;\n}\n\nvar CHANGES_BATCH_SIZE = 25;\nvar MAX_SIMULTANEOUS_REVS = 50;\n\nvar supportsBulkGetMap = {};\n\n// according to http://stackoverflow.com/a/417184/680742,\n// the de facto URL length limit is 2000 characters.\n// but since most of our measurements don't take the full\n// URL into account, we fudge it a bit.\n// TODO: we could measure the full URL to enforce exactly 2000 chars\nvar MAX_URL_LENGTH = 1800;\n\nvar log$1 = debug('pouchdb:http');\nfunction readAttachmentsAsBlobOrBuffer(row) {\n  var atts = row.doc && row.doc._attachments;\n  if (!atts) {\n    return;\n  }\n  Object.keys(atts).forEach(function (filename) {\n    var att = atts[filename];\n    att.data = b64ToBluffer(att.data, att.content_type);\n  });\n}\n\nfunction encodeDocId(id) {\n  if (/^_design/.test(id)) {\n    return '_design/' + encodeURIComponent(id.slice(8));\n  }\n  if (/^_local/.test(id)) {\n    return '_local/' + encodeURIComponent(id.slice(7));\n  }\n  return encodeURIComponent(id);\n}\n\nfunction preprocessAttachments(doc) {\n  if (!doc._attachments || !Object.keys(doc._attachments)) {\n    return PouchPromise.resolve();\n  }\n\n  return PouchPromise.all(Object.keys(doc._attachments).map(function (key) {\n    var attachment = doc._attachments[key];\n    if (attachment.data && typeof attachment.data !== 'string') {\n      return blobToBase64(attachment.data).then(function (b64) {\n        attachment.data = b64;\n      });\n    }\n  }));\n}\n\n// Get all the information you possibly can about the URI given by name and\n// return it as a suitable object.\nfunction getHost(name) {\n  // Prase the URI into all its little bits\n  var uri = parseUri(name);\n\n  // Store the user and password as a separate auth object\n  if (uri.user || uri.password) {\n    uri.auth = {username: uri.user, password: uri.password};\n  }\n\n  // Split the path part of the URI into parts using '/' as the delimiter\n  // after removing any leading '/' and any trailing '/'\n  var parts = uri.path.replace(/(^\\/|\\/$)/g, '').split('/');\n\n  // Store the first part as the database name and remove it from the parts\n  // array\n  uri.db = parts.pop();\n  // Prevent double encoding of URI component\n  if (uri.db.indexOf('%') === -1) {\n    uri.db = encodeURIComponent(uri.db);\n  }\n\n  // Restore the path by joining all the remaining parts (all the parts\n  // except for the database name) with '/'s\n  uri.path = parts.join('/');\n\n  return uri;\n}\n\n// Generate a URL with the host data given by opts and the given path\nfunction genDBUrl(opts, path) {\n  return genUrl(opts, opts.db + '/' + path);\n}\n\n// Generate a URL with the host data given by opts and the given path\nfunction genUrl(opts, path) {\n  // If the host already has a path, then we need to have a path delimiter\n  // Otherwise, the path delimiter is the empty string\n  var pathDel = !opts.path ? '' : '/';\n\n  // If the host already has a path, then we need to have a path delimiter\n  // Otherwise, the path delimiter is the empty string\n  return opts.protocol + '://' + opts.host +\n         (opts.port ? (':' + opts.port) : '') +\n         '/' + opts.path + pathDel + path;\n}\n\nfunction paramsToStr(params) {\n  return '?' + Object.keys(params).map(function (k) {\n    return k + '=' + encodeURIComponent(params[k]);\n  }).join('&');\n}\n\n// Implements the PouchDB API for dealing with CouchDB instances over HTTP\nfunction HttpPouch(opts, callback) {\n  // The functions that will be publicly available for HttpPouch\n  var api = this;\n\n  // Parse the URI given by opts.name into an easy-to-use object\n  var getHostFun = getHost;\n\n  // TODO: this seems to only be used by yarong for the Thali project.\n  // Verify whether or not it's still needed.\n  /* istanbul ignore if */\n  if (opts.getHost) {\n    getHostFun = opts.getHost;\n  }\n\n  var host = getHostFun(opts.name, opts);\n  var dbUrl = genDBUrl(host, '');\n\n  opts = clone(opts);\n  var ajaxOpts = opts.ajax || {};\n\n  api.getUrl = function () { return dbUrl; };\n  api.getHeaders = function () { return ajaxOpts.headers || {}; };\n\n  if (opts.auth || host.auth) {\n    var nAuth = opts.auth || host.auth;\n    var str = nAuth.username + ':' + nAuth.password;\n    var token = btoa$1(unescape(encodeURIComponent(str)));\n    ajaxOpts.headers = ajaxOpts.headers || {};\n    ajaxOpts.headers.Authorization = 'Basic ' + token;\n  }\n\n  function ajax(userOpts, options, callback) {\n    var reqAjax = userOpts.ajax || {};\n    var reqOpts = jsExtend.extend(clone(ajaxOpts), reqAjax, options);\n    log$1(reqOpts.method + ' ' + reqOpts.url);\n    return utils.ajax(reqOpts, callback);\n  }\n\n  function ajaxPromise(userOpts, opts) {\n    return new PouchPromise(function (resolve, reject) {\n      ajax(userOpts, opts, function (err, res) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(res);\n      });\n    });\n  }\n\n  function adapterFun$$(name, fun) {\n    return adapterFun(name, getArguments(function (args) {\n      setup().then(function () {\n        return fun.apply(this, args);\n      }).catch(function(e) {\n        var callback = args.pop();\n        callback(e);\n      });\n    }));\n  }\n\n  var setupPromise;\n\n  function setup() {\n    // TODO: Remove `skipSetup` in favor of `skip_setup` in a future release\n    if (opts.skipSetup || opts.skip_setup) {\n      return PouchPromise.resolve();\n    }\n\n    // If there is a setup in process or previous successful setup\n    // done then we will use that\n    // If previous setups have been rejected we will try again\n    if (setupPromise) {\n      return setupPromise;\n    }\n\n    var checkExists = {method: 'GET', url: dbUrl};\n    setupPromise = ajaxPromise({}, checkExists).catch(function(err) {\n      if (err && err.status && err.status === 404) {\n        // Doesnt exist, create it\n        explainError(404, 'PouchDB is just detecting if the remote exists.');\n        return ajaxPromise({}, {method: 'PUT', url: dbUrl});\n      } else {\n        return PouchPromise.reject(err);\n      }\n    }).catch(function(err) {\n      // If we try to create a database that already exists\n      if (err && err.status && err.status === 412) {\n        return true;\n      }\n      return PouchPromise.reject(err);\n    });\n\n    setupPromise.catch(function() {\n      setupPromise = null;\n    });\n\n    return setupPromise;\n  }\n\n  setTimeout(function() {\n    callback(null, api);\n  });\n\n  api.type = function () {\n    return 'http';\n  };\n\n  api.id = adapterFun$$('id', function (callback) {\n    ajax({}, {method: 'GET', url: genUrl(host, '')}, function (err, result) {\n      var uuid = (result && result.uuid) ?\n        (result.uuid + host.db) : genDBUrl(host, '');\n      callback(null, uuid);\n    });\n  });\n\n  api.request = adapterFun$$('request', function (options, callback) {\n    options.url = genDBUrl(host, options.url);\n    ajax({}, options, callback);\n  });\n\n  // Sends a POST request to the host calling the couchdb _compact function\n  //    version: The version of CouchDB it is running\n  api.compact = adapterFun$$('compact', function (opts, callback) {\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n    opts = clone(opts);\n    ajax(opts, {\n      url: genDBUrl(host, '_compact'),\n      method: 'POST'\n    }, function () {\n      function ping() {\n        api.info(function (err, res) {\n          if (res && !res.compact_running) {\n            callback(null, {ok: true});\n          } else {\n            setTimeout(ping, opts.interval || 200);\n          }\n        });\n      }\n      // Ping the http if it's finished compaction\n      ping();\n    });\n  });\n\n  api.bulkGet = adapterFun('bulkGet', function (opts, callback) {\n    var self = this;\n\n    function doBulkGet(cb) {\n      var params = {};\n      if (opts.revs) {\n        params.revs = true;\n      }\n      if (opts.attachments) {\n        params.attachments = true;\n      }\n      ajax({}, {\n        url: genDBUrl(host, '_bulk_get' + paramsToStr(params)),\n        method: 'POST',\n        body: { docs: opts.docs}\n      }, cb);\n    }\n\n    function doBulkGetShim() {\n      // avoid \"url too long error\" by splitting up into multiple requests\n      var batchSize = MAX_SIMULTANEOUS_REVS;\n      var numBatches = Math.ceil(opts.docs.length / batchSize);\n      var numDone = 0;\n      var results = new Array(numBatches);\n\n      function onResult(batchNum) {\n        return function (err, res) {\n          // err is impossible because shim returns a list of errs in that case\n          results[batchNum] = res.results;\n          if (++numDone === numBatches) {\n            callback(null, {results: flatten(results)});\n          }\n        };\n      }\n\n      for (var i = 0; i < numBatches; i++) {\n        var subOpts = pick(opts, ['revs', 'attachments']);\n        subOpts.docs = opts.docs.slice(i * batchSize,\n          Math.min(opts.docs.length, (i + 1) * batchSize));\n        bulkGet(self, subOpts, onResult(i));\n      }\n    }\n\n    // mark the whole database as either supporting or not supporting _bulk_get\n    var dbUrl = genUrl(host, '');\n    var supportsBulkGet = supportsBulkGetMap[dbUrl];\n\n    if (typeof supportsBulkGet !== 'boolean') {\n      // check if this database supports _bulk_get\n      doBulkGet(function (err, res) {\n        /* istanbul ignore else */\n        if (err) {\n          var status = Math.floor(err.status / 100);\n          /* istanbul ignore else */\n          if (status === 4 || status === 5) { // 40x or 50x\n            supportsBulkGetMap[dbUrl] = false;\n            explainError(\n              err.status,\n              'PouchDB is just detecting if the remote ' +\n              'supports the _bulk_get API.'\n            );\n            doBulkGetShim();\n          } else {\n            callback(err);\n          }\n        } else {\n          supportsBulkGetMap[dbUrl] = true;\n          callback(null, res);\n        }\n      });\n    } else if (supportsBulkGet) {\n      /* istanbul ignore next */\n      doBulkGet(callback);\n    } else {\n      doBulkGetShim();\n    }\n  });\n\n  // Calls GET on the host, which gets back a JSON string containing\n  //    couchdb: A welcome string\n  //    version: The version of CouchDB it is running\n  api._info = function (callback) {\n    setup().then(function() {\n      ajax({}, {\n        method: 'GET',\n        url: genDBUrl(host, '')\n      }, function (err, res) {\n        /* istanbul ignore next */\n        if (err) {\n        return callback(err);\n        }\n        res.host = genDBUrl(host, '');\n        callback(null, res);\n      });\n    }).catch(callback);\n  };\n\n  // Get the document with the given id from the database given by host.\n  // The id could be solely the _id in the database, or it may be a\n  // _design/ID or _local/ID path\n  api.get = adapterFun$$('get', function (id, opts, callback) {\n    // If no options were given, set the callback to the second parameter\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n    opts = clone(opts);\n\n    // List of parameters to add to the GET request\n    var params = {};\n\n    if (opts.revs) {\n      params.revs = true;\n    }\n\n    if (opts.revs_info) {\n      params.revs_info = true;\n    }\n\n    if (opts.open_revs) {\n      if (opts.open_revs !== \"all\") {\n        opts.open_revs = JSON.stringify(opts.open_revs);\n      }\n      params.open_revs = opts.open_revs;\n    }\n\n    if (opts.rev) {\n      params.rev = opts.rev;\n    }\n\n    if (opts.conflicts) {\n      params.conflicts = opts.conflicts;\n    }\n\n    id = encodeDocId(id);\n\n    // Set the options for the ajax call\n    var options = {\n      method: 'GET',\n      url: genDBUrl(host, id + paramsToStr(params))\n    };\n\n    function fetchAttachments(doc) {\n      var atts = doc._attachments;\n      var filenames = atts && Object.keys(atts);\n      if (!atts || !filenames.length) {\n        return;\n      }\n      // we fetch these manually in separate XHRs, because\n      // Sync Gateway would normally send it back as multipart/mixed,\n      // which we cannot parse. Also, this is more efficient than\n      // receiving attachments as base64-encoded strings.\n      return PouchPromise.all(filenames.map(function (filename) {\n        var att = atts[filename];\n        var path = encodeDocId(doc._id) + '/' + encodeAttachmentId(filename) +\n          '?rev=' + doc._rev;\n        return ajaxPromise(opts, {\n          method: 'GET',\n          url: genDBUrl(host, path),\n          binary: true\n        }).then(function (blob) {\n          if (opts.binary) {\n            return blob;\n          }\n          return blobToBase64(blob);\n        }).then(function (data) {\n          delete att.stub;\n          delete att.length;\n          att.data = data;\n        });\n      }));\n    }\n\n    function fetchAllAttachments(docOrDocs) {\n      if (Array.isArray(docOrDocs)) {\n        return PouchPromise.all(docOrDocs.map(function (doc) {\n          if (doc.ok) {\n            return fetchAttachments(doc.ok);\n          }\n        }));\n      }\n      return fetchAttachments(docOrDocs);\n    }\n\n    ajaxPromise(opts, options).then(function (res) {\n      return PouchPromise.resolve().then(function () {\n        if (opts.attachments) {\n          return fetchAllAttachments(res);\n        }\n      }).then(function () {\n        callback(null, res);\n      });\n    }).catch(callback);\n  });\n\n  // Delete the document given by doc from the database given by host.\n  api.remove = adapterFun$$('remove',\n      function (docOrId, optsOrRev, opts, callback) {\n    var doc;\n    if (typeof optsOrRev === 'string') {\n      // id, rev, opts, callback style\n      doc = {\n        _id: docOrId,\n        _rev: optsOrRev\n      };\n      if (typeof opts === 'function') {\n        callback = opts;\n        opts = {};\n      }\n    } else {\n      // doc, opts, callback style\n      doc = docOrId;\n      if (typeof optsOrRev === 'function') {\n        callback = optsOrRev;\n        opts = {};\n      } else {\n        callback = opts;\n        opts = optsOrRev;\n      }\n    }\n\n    var rev = (doc._rev || opts.rev);\n\n    // Delete the document\n    ajax(opts, {\n      method: 'DELETE',\n      url: genDBUrl(host, encodeDocId(doc._id)) + '?rev=' + rev\n    }, callback);\n  });\n\n  function encodeAttachmentId(attachmentId) {\n    return attachmentId.split(\"/\").map(encodeURIComponent).join(\"/\");\n  }\n\n  // Get the attachment\n  api.getAttachment =\n    adapterFun$$('getAttachment', function (docId, attachmentId, opts,\n                                                callback) {\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n    var params = opts.rev ? ('?rev=' + opts.rev) : '';\n    var url = genDBUrl(host, encodeDocId(docId)) + '/' +\n      encodeAttachmentId(attachmentId) + params;\n    ajax(opts, {\n      method: 'GET',\n      url: url,\n      binary: true\n    }, callback);\n  });\n\n  // Remove the attachment given by the id and rev\n  api.removeAttachment =\n    adapterFun$$('removeAttachment', function (docId, attachmentId, rev,\n                                                   callback) {\n\n    var url = genDBUrl(host, encodeDocId(docId) + '/' +\n      encodeAttachmentId(attachmentId)) + '?rev=' + rev;\n\n    ajax({}, {\n      method: 'DELETE',\n      url: url\n    }, callback);\n  });\n\n  // Add the attachment given by blob and its contentType property\n  // to the document with the given id, the revision given by rev, and\n  // add it to the database given by host.\n  api.putAttachment =\n    adapterFun$$('putAttachment', function (docId, attachmentId, rev, blob,\n                                                type, callback) {\n    if (typeof type === 'function') {\n      callback = type;\n      type = blob;\n      blob = rev;\n      rev = null;\n    }\n    var id = encodeDocId(docId) + '/' + encodeAttachmentId(attachmentId);\n    var url = genDBUrl(host, id);\n    if (rev) {\n      url += '?rev=' + rev;\n    }\n\n    if (typeof blob === 'string') {\n      // input is assumed to be a base64 string\n      var binary;\n      try {\n        binary = atob$1(blob);\n      } catch (err) {\n        return callback(createError(BAD_ARG,\n                        'Attachment is not a valid base64 string'));\n      }\n      blob = binary ? binStringToBluffer(binary, type) : '';\n    }\n\n    var opts = {\n      headers: {'Content-Type': type},\n      method: 'PUT',\n      url: url,\n      processData: false,\n      body: blob,\n      timeout: ajaxOpts.timeout || 60000\n    };\n    // Add the attachment\n    ajax({}, opts, callback);\n  });\n\n  // Update/create multiple documents given by req in the database\n  // given by host.\n  api._bulkDocs = function (req, opts, callback) {\n    // If new_edits=false then it prevents the database from creating\n    // new revision numbers for the documents. Instead it just uses\n    // the old ones. This is used in database replication.\n    req.new_edits = opts.new_edits;\n\n    setup().then(function () {\n      return PouchPromise.all(req.docs.map(preprocessAttachments));\n    }).then(function () {\n      // Update/create the documents\n      ajax(opts, {\n        method: 'POST',\n        url: genDBUrl(host, '_bulk_docs'),\n        body: req\n      }, function (err, results) {\n        if (err) {\n          return callback(err);\n        }\n        results.forEach(function (result) {\n          result.ok = true; // smooths out cloudant not adding this\n        });\n        callback(null, results);\n      });\n    }).catch(callback);\n  };\n\n  // Get a listing of the documents in the database given\n  // by host and ordered by increasing id.\n  api.allDocs = adapterFun$$('allDocs', function (opts, callback) {\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n    opts = clone(opts);\n\n    // List of parameters to add to the GET request\n    var params = {};\n    var body;\n    var method = 'GET';\n\n    if (opts.conflicts) {\n      params.conflicts = true;\n    }\n\n    if (opts.descending) {\n      params.descending = true;\n    }\n\n    if (opts.include_docs) {\n      params.include_docs = true;\n    }\n\n    // added in CouchDB 1.6.0\n    if (opts.attachments) {\n      params.attachments = true;\n    }\n\n    if (opts.key) {\n      params.key = JSON.stringify(opts.key);\n    }\n\n    if (opts.start_key) {\n      opts.startkey = opts.start_key;\n    }\n\n    if (opts.startkey) {\n      params.startkey = JSON.stringify(opts.startkey);\n    }\n\n    if (opts.end_key) {\n      opts.endkey = opts.end_key;\n    }\n\n    if (opts.endkey) {\n      params.endkey = JSON.stringify(opts.endkey);\n    }\n\n    if (typeof opts.inclusive_end !== 'undefined') {\n      params.inclusive_end = !!opts.inclusive_end;\n    }\n\n    if (typeof opts.limit !== 'undefined') {\n      params.limit = opts.limit;\n    }\n\n    if (typeof opts.skip !== 'undefined') {\n      params.skip = opts.skip;\n    }\n\n    var paramStr = paramsToStr(params);\n\n    if (typeof opts.keys !== 'undefined') {\n\n      var keysAsString =\n        'keys=' + encodeURIComponent(JSON.stringify(opts.keys));\n      if (keysAsString.length + paramStr.length + 1 <= MAX_URL_LENGTH) {\n        // If the keys are short enough, do a GET. we do this to work around\n        // Safari not understanding 304s on POSTs (see issue #1239)\n        paramStr += '&' + keysAsString;\n      } else {\n        // If keys are too long, issue a POST request to circumvent GET\n        // query string limits\n        // see http://wiki.apache.org/couchdb/HTTP_view_API#Querying_Options\n        method = 'POST';\n        body = {keys: opts.keys};\n      }\n    }\n\n    // Get the document listing\n    ajaxPromise(opts, {\n      method: method,\n      url: genDBUrl(host, '_all_docs' + paramStr),\n      body: body\n    }).then(function (res) {\n      if (opts.include_docs && opts.attachments && opts.binary) {\n        res.rows.forEach(readAttachmentsAsBlobOrBuffer);\n      }\n      callback(null, res);\n    }).catch(callback);\n  });\n\n  // Get a list of changes made to documents in the database given by host.\n  // TODO According to the README, there should be two other methods here,\n  // api.changes.addListener and api.changes.removeListener.\n  api._changes = function (opts) {\n\n    // We internally page the results of a changes request, this means\n    // if there is a large set of changes to be returned we can start\n    // processing them quicker instead of waiting on the entire\n    // set of changes to return and attempting to process them at once\n    var batchSize = 'batch_size' in opts ? opts.batch_size : CHANGES_BATCH_SIZE;\n\n    opts = clone(opts);\n    opts.timeout = ('timeout' in opts) ? opts.timeout :\n      ('timeout' in ajaxOpts) ? ajaxOpts.timeout :\n      30 * 1000;\n\n    // We give a 5 second buffer for CouchDB changes to respond with\n    // an ok timeout (if a timeout it set)\n    var params = opts.timeout ? {timeout: opts.timeout - (5 * 1000)} : {};\n    var limit = (typeof opts.limit !== 'undefined') ? opts.limit : false;\n    var returnDocs;\n    if ('return_docs' in opts) {\n      returnDocs = opts.return_docs;\n    } else if ('returnDocs' in opts) {\n      // TODO: Remove 'returnDocs' in favor of 'return_docs' in a future release\n      returnDocs = opts.returnDocs;\n    } else {\n      returnDocs = true;\n    }\n    //\n    var leftToFetch = limit;\n\n    if (opts.style) {\n      params.style = opts.style;\n    }\n\n    if (opts.include_docs || opts.filter && typeof opts.filter === 'function') {\n      params.include_docs = true;\n    }\n\n    if (opts.attachments) {\n      params.attachments = true;\n    }\n\n    if (opts.continuous) {\n      params.feed = 'longpoll';\n    }\n\n    if (opts.conflicts) {\n      params.conflicts = true;\n    }\n\n    if (opts.descending) {\n      params.descending = true;\n    }\n\n    if ('heartbeat' in opts) {\n      // If the heartbeat value is false, it disables the default heartbeat\n      if (opts.heartbeat) {\n        params.heartbeat = opts.heartbeat;\n      }\n    } else {\n      // Default heartbeat to 10 seconds\n      params.heartbeat = 10000;\n    }\n\n    if (opts.filter && typeof opts.filter === 'string') {\n      params.filter = opts.filter;\n      if (opts.filter === '_view' &&\n          opts.view &&\n          typeof opts.view === 'string') {\n        params.view = opts.view;\n      }\n    }\n\n    // If opts.query_params exists, pass it through to the changes request.\n    // These parameters may be used by the filter on the source database.\n    if (opts.query_params && typeof opts.query_params === 'object') {\n      for (var param_name in opts.query_params) {\n        /* istanbul ignore else */\n        if (opts.query_params.hasOwnProperty(param_name)) {\n          params[param_name] = opts.query_params[param_name];\n        }\n      }\n    }\n\n    var method = 'GET';\n    var body;\n\n    if (opts.doc_ids) {\n      // set this automagically for the user; it's annoying that couchdb\n      // requires both a \"filter\" and a \"doc_ids\" param.\n      params.filter = '_doc_ids';\n\n      var docIdsJson = JSON.stringify(opts.doc_ids);\n\n      if (docIdsJson.length < MAX_URL_LENGTH) {\n        params.doc_ids = docIdsJson;\n      } else {\n        // anything greater than ~2000 is unsafe for gets, so\n        // use POST instead\n        method = 'POST';\n        body = {doc_ids: opts.doc_ids };\n      }\n    }\n\n    var xhr;\n    var lastFetchedSeq;\n\n    // Get all the changes starting wtih the one immediately after the\n    // sequence number given by since.\n    var fetch = function (since, callback) {\n      if (opts.aborted) {\n        return;\n      }\n      params.since = since;\n      // \"since\" can be any kind of json object in Coudant/CouchDB 2.x\n      /* istanbul ignore next */\n      if (typeof params.since === \"object\") {\n        params.since = JSON.stringify(params.since);\n      }\n\n      if (opts.descending) {\n        if (limit) {\n          params.limit = leftToFetch;\n        }\n      } else {\n        params.limit = (!limit || leftToFetch > batchSize) ?\n          batchSize : leftToFetch;\n      }\n\n      // Set the options for the ajax call\n      var xhrOpts = {\n        method: method,\n        url: genDBUrl(host, '_changes' + paramsToStr(params)),\n        timeout: opts.timeout,\n        body: body\n      };\n      lastFetchedSeq = since;\n\n      /* istanbul ignore if */\n      if (opts.aborted) {\n        return;\n      }\n\n      // Get the changes\n      setup().then(function() {\n        xhr = ajax(opts, xhrOpts, callback);\n      }).catch(callback);\n    };\n\n    // If opts.since exists, get all the changes from the sequence\n    // number given by opts.since. Otherwise, get all the changes\n    // from the sequence number 0.\n    var results = {results: []};\n\n    var fetched = function (err, res) {\n      if (opts.aborted) {\n        return;\n      }\n      var raw_results_length = 0;\n      // If the result of the ajax call (res) contains changes (res.results)\n      if (res && res.results) {\n        raw_results_length = res.results.length;\n        results.last_seq = res.last_seq;\n        // For each change\n        var req = {};\n        req.query = opts.query_params;\n        res.results = res.results.filter(function (c) {\n          leftToFetch--;\n          var ret = filterChange(opts)(c);\n          if (ret) {\n            if (opts.include_docs && opts.attachments && opts.binary) {\n              readAttachmentsAsBlobOrBuffer(c);\n            }\n            if (returnDocs) {\n              results.results.push(c);\n            }\n            opts.onChange(c);\n          }\n          return ret;\n        });\n      } else if (err) {\n        // In case of an error, stop listening for changes and call\n        // opts.complete\n        opts.aborted = true;\n        opts.complete(err);\n        return;\n      }\n\n      // The changes feed may have timed out with no results\n      // if so reuse last update sequence\n      if (res && res.last_seq) {\n        lastFetchedSeq = res.last_seq;\n      }\n\n      var finished = (limit && leftToFetch <= 0) ||\n        (res && raw_results_length < batchSize) ||\n        (opts.descending);\n\n      if ((opts.continuous && !(limit && leftToFetch <= 0)) || !finished) {\n        // Queue a call to fetch again with the newest sequence number\n        setTimeout(function () { fetch(lastFetchedSeq, fetched); }, 0);\n      } else {\n        // We're done, call the callback\n        opts.complete(null, results);\n      }\n    };\n\n    fetch(opts.since || 0, fetched);\n\n    // Return a method to cancel this method from processing any more\n    return {\n      cancel: function () {\n        opts.aborted = true;\n        if (xhr) {\n          xhr.abort();\n        }\n      }\n    };\n  };\n\n  // Given a set of document/revision IDs (given by req), tets the subset of\n  // those that do NOT correspond to revisions stored in the database.\n  // See http://wiki.apache.org/couchdb/HttpPostRevsDiff\n  api.revsDiff = adapterFun$$('revsDiff', function (req, opts, callback) {\n    // If no options were given, set the callback to be the second parameter\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n\n    // Get the missing document/revision IDs\n    ajax(opts, {\n      method: 'POST',\n      url: genDBUrl(host, '_revs_diff'),\n      body: req\n    }, callback);\n  });\n\n  api._close = function (callback) {\n    callback();\n  };\n\n  api._destroy = function (options, callback) {\n    ajax(options, {\n      url: genDBUrl(host, ''),\n      method: 'DELETE'\n    }, function (err, resp) {\n      if (err && err.status && err.status !== 404) {\n        return callback(err);\n      }\n      api.emit('destroyed');\n      api.constructor.emit('destroyed', opts.name);\n      callback(null, resp);\n    });\n  };\n}\n\n// HttpPouch is a valid adapter.\nHttpPouch.valid = function () {\n  return true;\n};\n\nfunction TaskQueue$1() {\n  this.promise = new PouchPromise(function (fulfill) {fulfill(); });\n}\nTaskQueue$1.prototype.add = function (promiseFactory) {\n  this.promise = this.promise.catch(function () {\n    // just recover\n  }).then(function () {\n    return promiseFactory();\n  });\n  return this.promise;\n};\nTaskQueue$1.prototype.finish = function () {\n  return this.promise;\n};\n\nfunction md5$1(string) {\n  return Md5.hash(string);\n}\n\nfunction createView(opts) {\n  var sourceDB = opts.db;\n  var viewName = opts.viewName;\n  var mapFun = opts.map;\n  var reduceFun = opts.reduce;\n  var temporary = opts.temporary;\n\n  // the \"undefined\" part is for backwards compatibility\n  var viewSignature = mapFun.toString() + (reduceFun && reduceFun.toString()) +\n    'undefined';\n\n  if (!temporary && sourceDB._cachedViews) {\n    var cachedView = sourceDB._cachedViews[viewSignature];\n    if (cachedView) {\n      return PouchPromise.resolve(cachedView);\n    }\n  }\n\n  return sourceDB.info().then(function (info) {\n\n    var depDbName = info.db_name + '-mrview-' +\n      (temporary ? 'temp' : md5$1(viewSignature));\n\n    // save the view name in the source db so it can be cleaned up if necessary\n    // (e.g. when the _design doc is deleted, remove all associated view data)\n    function diffFunction(doc) {\n      doc.views = doc.views || {};\n      var fullViewName = viewName;\n      if (fullViewName.indexOf('/') === -1) {\n        fullViewName = viewName + '/' + viewName;\n      }\n      var depDbs = doc.views[fullViewName] = doc.views[fullViewName] || {};\n      /* istanbul ignore if */\n      if (depDbs[depDbName]) {\n        return; // no update necessary\n      }\n      depDbs[depDbName] = true;\n      return doc;\n    }\n    return upsert(sourceDB, '_local/mrviews', diffFunction).then(function () {\n      return sourceDB.registerDependentDatabase(depDbName).then(function (res) {\n        var db = res.db;\n        db.auto_compaction = true;\n        var view = {\n          name: depDbName,\n          db: db,\n          sourceDB: sourceDB,\n          adapter: sourceDB.adapter,\n          mapFun: mapFun,\n          reduceFun: reduceFun\n        };\n        return view.db.get('_local/lastSeq').catch(function (err) {\n          /* istanbul ignore if */\n          if (err.status !== 404) {\n            throw err;\n          }\n        }).then(function (lastSeqDoc) {\n          view.seq = lastSeqDoc ? lastSeqDoc.seq : 0;\n          if (!temporary) {\n            sourceDB._cachedViews = sourceDB._cachedViews || {};\n            sourceDB._cachedViews[viewSignature] = view;\n            view.db.once('destroyed', function () {\n              delete sourceDB._cachedViews[viewSignature];\n            });\n          }\n          return view;\n        });\n      });\n    });\n  });\n}\n\nfunction evalfunc(func, emit, sum, log, isArray, toJSON) {\n  return scopedEval(\n    \"return (\" + func.replace(/;\\s*$/, \"\") + \");\",\n    {\n      emit: emit,\n      sum: sum,\n      log: log,\n      isArray: isArray,\n      toJSON: toJSON\n    }\n  );\n}\n\nvar promisedCallback$1 = function (promise, callback) {\n  if (callback) {\n    promise.then(function (res) {\n      process.nextTick(function () {\n        callback(null, res);\n      });\n    }, function (reason) {\n      process.nextTick(function () {\n        callback(reason);\n      });\n    });\n  }\n  return promise;\n};\n\nvar callbackify$1 = function (fun) {\n  return getArguments(function (args) {\n    var cb = args.pop();\n    var promise = fun.apply(this, args);\n    if (typeof cb === 'function') {\n      promisedCallback$1(promise, cb);\n    }\n    return promise;\n  });\n};\n\n// Promise finally util similar to Q.finally\nvar fin$1 = function (promise, finalPromiseFactory) {\n  return promise.then(function (res) {\n    return finalPromiseFactory().then(function () {\n      return res;\n    });\n  }, function (reason) {\n    return finalPromiseFactory().then(function () {\n      throw reason;\n    });\n  });\n};\n\nvar sequentialize$1 = function (queue, promiseFactory) {\n  return function () {\n    var args = arguments;\n    var that = this;\n    return queue.add(function () {\n      return promiseFactory.apply(that, args);\n    });\n  };\n};\n\n// uniq an array of strings, order not guaranteed\n// similar to underscore/lodash _.uniq\nvar uniq$1 = function (arr) {\n  var map = {};\n\n  for (var i = 0, len = arr.length; i < len; i++) {\n    map['$' + arr[i]] = true;\n  }\n\n  var keys = Object.keys(map);\n  var output = new Array(keys.length);\n\n  for (i = 0, len = keys.length; i < len; i++) {\n    output[i] = keys[i].substring(1);\n  }\n  return output;\n};\n\nvar utils$1 = {\n  uniq: uniq$1,\n  sequentialize: sequentialize$1,\n  fin: fin$1,\n  callbackify: callbackify$1,\n  promisedCallback: promisedCallback$1\n};\n\nvar collate$2 = pouchCollate__default.collate;\nvar toIndexableString = pouchCollate__default.toIndexableString;\nvar normalizeKey = pouchCollate__default.normalizeKey;\nvar parseIndexableString = pouchCollate__default.parseIndexableString;\nvar log$2;\n/* istanbul ignore else */\nif ((typeof console !== 'undefined') && (typeof console.log === 'function')) {\n  log$2 = Function.prototype.bind.call(console.log, console);\n} else {\n  log$2 = function () {};\n}\nvar callbackify = utils$1.callbackify;\nvar sequentialize = utils$1.sequentialize;\nvar uniq = utils$1.uniq;\nvar fin = utils$1.fin;\nvar promisedCallback = utils$1.promisedCallback;\nvar persistentQueues = {};\nvar tempViewQueue = new TaskQueue$1();\nvar CHANGES_BATCH_SIZE$1 = 50;\n\nfunction parseViewName(name) {\n  // can be either 'ddocname/viewname' or just 'viewname'\n  // (where the ddoc name is the same)\n  return name.indexOf('/') === -1 ? [name, name] : name.split('/');\n}\n\nfunction isGenOne$1(changes) {\n  // only return true if the current change is 1-\n  // and there are no other leafs\n  return changes.length === 1 && /^1-/.test(changes[0].rev);\n}\n\nfunction emitError(db, e) {\n  try {\n    db.emit('error', e);\n  } catch (err) {\n    console.error(\n      'The user\\'s map/reduce function threw an uncaught error.\\n' +\n      'You can debug this error by doing:\\n' +\n      'myDatabase.on(\\'error\\', function (err) { debugger; });\\n' +\n      'Please double-check your map/reduce function.');\n    console.error(e);\n  }\n}\n\nfunction tryCode(db, fun, args) {\n  // emit an event if there was an error thrown by a map/reduce function.\n  // putting try/catches in a single function also avoids deoptimizations.\n  try {\n    return {\n      output : fun.apply(null, args)\n    };\n  } catch (e) {\n    emitError(db, e);\n    return {error: e};\n  }\n}\n\nfunction sortByKeyThenValue(x, y) {\n  var keyCompare = collate$2(x.key, y.key);\n  return keyCompare !== 0 ? keyCompare : collate$2(x.value, y.value);\n}\n\nfunction sliceResults(results, limit, skip) {\n  skip = skip || 0;\n  if (typeof limit === 'number') {\n    return results.slice(skip, limit + skip);\n  } else if (skip > 0) {\n    return results.slice(skip);\n  }\n  return results;\n}\n\nfunction rowToDocId(row) {\n  var val = row.value;\n  // Users can explicitly specify a joined doc _id, or it\n  // defaults to the doc _id that emitted the key/value.\n  var docId = (val && typeof val === 'object' && val._id) || row.id;\n  return docId;\n}\n\nfunction readAttachmentsAsBlobOrBuffer$1(res) {\n  res.rows.forEach(function (row) {\n    var atts = row.doc && row.doc._attachments;\n    if (!atts) {\n      return;\n    }\n    Object.keys(atts).forEach(function (filename) {\n      var att = atts[filename];\n      atts[filename].data = b64ToBluffer(att.data, att.content_type);\n    });\n  });\n}\n\nfunction postprocessAttachments(opts) {\n  return function (res) {\n    if (opts.include_docs && opts.attachments && opts.binary) {\n      readAttachmentsAsBlobOrBuffer$1(res);\n    }\n    return res;\n  };\n}\n\nfunction createBuiltInError(name) {\n  var message = 'builtin ' + name +\n    ' function requires map values to be numbers' +\n    ' or number arrays';\n  return new BuiltInError(message);\n}\n\nfunction sum(values) {\n  var result = 0;\n  for (var i = 0, len = values.length; i < len; i++) {\n    var num = values[i];\n    if (typeof num !== 'number') {\n      if (Array.isArray(num)) {\n        // lists of numbers are also allowed, sum them separately\n        result = typeof result === 'number' ? [result] : result;\n        for (var j = 0, jLen = num.length; j < jLen; j++) {\n          var jNum = num[j];\n          if (typeof jNum !== 'number') {\n            throw createBuiltInError('_sum');\n          } else if (typeof result[j] === 'undefined') {\n            result.push(jNum);\n          } else {\n            result[j] += jNum;\n          }\n        }\n      } else { // not array/number\n        throw createBuiltInError('_sum');\n      }\n    } else if (typeof result === 'number') {\n      result += num;\n    } else { // add number to array\n      result[0] += num;\n    }\n  }\n  return result;\n}\n\nvar builtInReduce = {\n  _sum: function (keys, values) {\n    return sum(values);\n  },\n\n  _count: function (keys, values) {\n    return values.length;\n  },\n\n  _stats: function (keys, values) {\n    // no need to implement rereduce=true, because Pouch\n    // will never call it\n    function sumsqr(values) {\n      var _sumsqr = 0;\n      for (var i = 0, len = values.length; i < len; i++) {\n        var num = values[i];\n        _sumsqr += (num * num);\n      }\n      return _sumsqr;\n    }\n    return {\n      sum     : sum(values),\n      min     : Math.min.apply(null, values),\n      max     : Math.max.apply(null, values),\n      count   : values.length,\n      sumsqr : sumsqr(values)\n    };\n  }\n};\n\nfunction addHttpParam(paramName, opts, params, asJson) {\n  // add an http param from opts to params, optionally json-encoded\n  var val = opts[paramName];\n  if (typeof val !== 'undefined') {\n    if (asJson) {\n      val = encodeURIComponent(JSON.stringify(val));\n    }\n    params.push(paramName + '=' + val);\n  }\n}\n\nfunction coerceInteger (integerCandidate) {\n  if (typeof integerCandidate !== 'undefined') {\n    var asNumber = Number(integerCandidate);\n    // prevents e.g. '1foo' or '1.1' being coerced to 1\n    if (!isNaN(asNumber) && asNumber === parseInt(integerCandidate, 10)) {\n      return asNumber;\n    } else {\n      return integerCandidate;\n    }\n  }\n}\n\nfunction coerceOptions(opts) {\n  opts.group_level = coerceInteger(opts.group_level);\n  opts.limit = coerceInteger(opts.limit);\n  opts.skip = coerceInteger(opts.skip);\n  return opts;\n}\n\nfunction checkPositiveInteger (number) {\n  if (number) {\n    if (typeof number !== 'number') {\n      return  new QueryParseError('Invalid value for integer: \"' +\n      number + '\"');\n    }\n    if (number < 0) {\n      return new QueryParseError('Invalid value for positive integer: ' +\n        '\"' + number + '\"');\n    }\n  }\n}\n\nfunction checkQueryParseError(options, fun) {\n  var startkeyName = options.descending ? 'endkey' : 'startkey';\n  var endkeyName = options.descending ? 'startkey' : 'endkey';\n\n  if (typeof options[startkeyName] !== 'undefined' &&\n    typeof options[endkeyName] !== 'undefined' &&\n    collate$2(options[startkeyName], options[endkeyName]) > 0) {\n    throw new QueryParseError('No rows can match your key range, ' +\n    'reverse your start_key and end_key or set {descending : true}');\n  } else if (fun.reduce && options.reduce !== false) {\n    if (options.include_docs) {\n      throw new QueryParseError('{include_docs:true} is invalid for reduce');\n    } else if (options.keys && options.keys.length > 1 &&\n        !options.group && !options.group_level) {\n      throw new QueryParseError('Multi-key fetches for reduce views must use ' +\n      '{group: true}');\n    }\n  }\n  ['group_level', 'limit', 'skip'].forEach(function (optionName) {\n    var error = checkPositiveInteger(options[optionName]);\n    if (error) {\n      throw error;\n    }\n  });\n}\n\nfunction httpQuery(db, fun, opts) {\n  // List of parameters to add to the PUT request\n  var params = [];\n  var body;\n  var method = 'GET';\n\n  // If opts.reduce exists and is defined, then add it to the list\n  // of parameters.\n  // If reduce=false then the results are that of only the map function\n  // not the final result of map and reduce.\n  addHttpParam('reduce', opts, params);\n  addHttpParam('include_docs', opts, params);\n  addHttpParam('attachments', opts, params);\n  addHttpParam('limit', opts, params);\n  addHttpParam('descending', opts, params);\n  addHttpParam('group', opts, params);\n  addHttpParam('group_level', opts, params);\n  addHttpParam('skip', opts, params);\n  addHttpParam('stale', opts, params);\n  addHttpParam('conflicts', opts, params);\n  addHttpParam('startkey', opts, params, true);\n  addHttpParam('start_key', opts, params, true);\n  addHttpParam('endkey', opts, params, true);\n  addHttpParam('end_key', opts, params, true);\n  addHttpParam('inclusive_end', opts, params);\n  addHttpParam('key', opts, params, true);\n\n  // Format the list of parameters into a valid URI query string\n  params = params.join('&');\n  params = params === '' ? '' : '?' + params;\n\n  // If keys are supplied, issue a POST to circumvent GET query string limits\n  // see http://wiki.apache.org/couchdb/HTTP_view_API#Querying_Options\n  if (typeof opts.keys !== 'undefined') {\n    var MAX_URL_LENGTH = 2000;\n    // according to http://stackoverflow.com/a/417184/680742,\n    // the de facto URL length limit is 2000 characters\n\n    var keysAsString =\n      'keys=' + encodeURIComponent(JSON.stringify(opts.keys));\n    if (keysAsString.length + params.length + 1 <= MAX_URL_LENGTH) {\n      // If the keys are short enough, do a GET. we do this to work around\n      // Safari not understanding 304s on POSTs (see pouchdb/pouchdb#1239)\n      params += (params[0] === '?' ? '&' : '?') + keysAsString;\n    } else {\n      method = 'POST';\n      if (typeof fun === 'string') {\n        body = {keys: opts.keys};\n      } else { // fun is {map : mapfun}, so append to this\n        fun.keys = opts.keys;\n      }\n    }\n  }\n\n  // We are referencing a query defined in the design doc\n  if (typeof fun === 'string') {\n    var parts = parseViewName(fun);\n    return db.request({\n      method: method,\n      url: '_design/' + parts[0] + '/_view/' + parts[1] + params,\n      body: body\n    }).then(postprocessAttachments(opts));\n  }\n\n  // We are using a temporary view, terrible for performance, good for testing\n  body = body || {};\n  Object.keys(fun).forEach(function (key) {\n    if (Array.isArray(fun[key])) {\n      body[key] = fun[key];\n    } else {\n      body[key] = fun[key].toString();\n    }\n  });\n  return db.request({\n    method: 'POST',\n    url: '_temp_view' + params,\n    body: body\n  }).then(postprocessAttachments(opts));\n}\n\n// custom adapters can define their own api._query\n// and override the default behavior\n/* istanbul ignore next */\nfunction customQuery(db, fun, opts) {\n  return new PouchPromise(function (resolve, reject) {\n    db._query(fun, opts, function (err, res) {\n      if (err) {\n        return reject(err);\n      }\n      resolve(res);\n    });\n  });\n}\n\n// custom adapters can define their own api._viewCleanup\n// and override the default behavior\n/* istanbul ignore next */\nfunction customViewCleanup(db) {\n  return new PouchPromise(function (resolve, reject) {\n    db._viewCleanup(function (err, res) {\n      if (err) {\n        return reject(err);\n      }\n      resolve(res);\n    });\n  });\n}\n\nfunction defaultsTo(value) {\n  return function (reason) {\n    /* istanbul ignore else */\n    if (reason.status === 404) {\n      return value;\n    } else {\n      throw reason;\n    }\n  };\n}\n\n// returns a promise for a list of docs to update, based on the input docId.\n// the order doesn't matter, because post-3.2.0, bulkDocs\n// is an atomic operation in all three adapters.\nfunction getDocsToPersist(docId, view, docIdsToChangesAndEmits) {\n  var metaDocId = '_local/doc_' + docId;\n  var defaultMetaDoc = {_id: metaDocId, keys: []};\n  var docData = docIdsToChangesAndEmits[docId];\n  var indexableKeysToKeyValues = docData.indexableKeysToKeyValues;\n  var changes = docData.changes;\n\n  function getMetaDoc() {\n    if (isGenOne$1(changes)) {\n      // generation 1, so we can safely assume initial state\n      // for performance reasons (avoids unnecessary GETs)\n      return PouchPromise.resolve(defaultMetaDoc);\n    }\n    return view.db.get(metaDocId).catch(defaultsTo(defaultMetaDoc));\n  }\n\n  function getKeyValueDocs(metaDoc) {\n    if (!metaDoc.keys.length) {\n      // no keys, no need for a lookup\n      return PouchPromise.resolve({rows: []});\n    }\n    return view.db.allDocs({\n      keys: metaDoc.keys,\n      include_docs: true\n    });\n  }\n\n  function processKvDocs(metaDoc, kvDocsRes) {\n    var kvDocs = [];\n    var oldKeysMap = {};\n\n    for (var i = 0, len = kvDocsRes.rows.length; i < len; i++) {\n      var row = kvDocsRes.rows[i];\n      var doc = row.doc;\n      if (!doc) { // deleted\n        continue;\n      }\n      kvDocs.push(doc);\n      oldKeysMap[doc._id] = true;\n      doc._deleted = !indexableKeysToKeyValues[doc._id];\n      if (!doc._deleted) {\n        var keyValue = indexableKeysToKeyValues[doc._id];\n        if ('value' in keyValue) {\n          doc.value = keyValue.value;\n        }\n      }\n    }\n\n    var newKeys = Object.keys(indexableKeysToKeyValues);\n    newKeys.forEach(function (key) {\n      if (!oldKeysMap[key]) {\n        // new doc\n        var kvDoc = {\n          _id: key\n        };\n        var keyValue = indexableKeysToKeyValues[key];\n        if ('value' in keyValue) {\n          kvDoc.value = keyValue.value;\n        }\n        kvDocs.push(kvDoc);\n      }\n    });\n    metaDoc.keys = uniq(newKeys.concat(metaDoc.keys));\n    kvDocs.push(metaDoc);\n\n    return kvDocs;\n  }\n\n  return getMetaDoc().then(function (metaDoc) {\n    return getKeyValueDocs(metaDoc).then(function (kvDocsRes) {\n      return processKvDocs(metaDoc, kvDocsRes);\n    });\n  });\n}\n\n// updates all emitted key/value docs and metaDocs in the mrview database\n// for the given batch of documents from the source database\nfunction saveKeyValues(view, docIdsToChangesAndEmits, seq) {\n  var seqDocId = '_local/lastSeq';\n  return view.db.get(seqDocId)\n  .catch(defaultsTo({_id: seqDocId, seq: 0}))\n  .then(function (lastSeqDoc) {\n    var docIds = Object.keys(docIdsToChangesAndEmits);\n    return PouchPromise.all(docIds.map(function (docId) {\n      return getDocsToPersist(docId, view, docIdsToChangesAndEmits);\n    })).then(function (listOfDocsToPersist) {\n      var docsToPersist = flatten(listOfDocsToPersist);\n      lastSeqDoc.seq = seq;\n      docsToPersist.push(lastSeqDoc);\n      // write all docs in a single operation, update the seq once\n      return view.db.bulkDocs({docs : docsToPersist});\n    });\n  });\n}\n\nfunction getQueue(view) {\n  var viewName = typeof view === 'string' ? view : view.name;\n  var queue = persistentQueues[viewName];\n  if (!queue) {\n    queue = persistentQueues[viewName] = new TaskQueue$1();\n  }\n  return queue;\n}\n\nfunction updateView(view) {\n  return sequentialize(getQueue(view), function () {\n    return updateViewInQueue(view);\n  })();\n}\n\nfunction updateViewInQueue(view) {\n  // bind the emit function once\n  var mapResults;\n  var doc;\n\n  function emit(key, value) {\n    var output = {id: doc._id, key: normalizeKey(key)};\n    // Don't explicitly store the value unless it's defined and non-null.\n    // This saves on storage space, because often people don't use it.\n    if (typeof value !== 'undefined' && value !== null) {\n      output.value = normalizeKey(value);\n    }\n    mapResults.push(output);\n  }\n\n  var mapFun;\n  // for temp_views one can use emit(doc, emit), see #38\n  if (typeof view.mapFun === \"function\" && view.mapFun.length === 2) {\n    var origMap = view.mapFun;\n    mapFun = function (doc) {\n      return origMap(doc, emit);\n    };\n  } else {\n    mapFun = evalfunc(view.mapFun.toString(), emit, sum, log$2, Array.isArray,\n      JSON.parse);\n  }\n\n  var currentSeq = view.seq || 0;\n\n  function processChange(docIdsToChangesAndEmits, seq) {\n    return function () {\n      return saveKeyValues(view, docIdsToChangesAndEmits, seq);\n    };\n  }\n\n  var queue = new TaskQueue$1();\n  // TODO(neojski): https://github.com/daleharvey/pouchdb/issues/1521\n\n  return new PouchPromise(function (resolve, reject) {\n\n    function complete() {\n      queue.finish().then(function () {\n        view.seq = currentSeq;\n        resolve();\n      });\n    }\n\n    function processNextBatch() {\n      view.sourceDB.changes({\n        conflicts: true,\n        include_docs: true,\n        style: 'all_docs',\n        since: currentSeq,\n        limit: CHANGES_BATCH_SIZE$1\n      }).on('complete', function (response) {\n        var results = response.results;\n        if (!results.length) {\n          return complete();\n        }\n        var docIdsToChangesAndEmits = {};\n        for (var i = 0, l = results.length; i < l; i++) {\n          var change = results[i];\n          if (change.doc._id[0] !== '_') {\n            mapResults = [];\n            doc = change.doc;\n\n            if (!doc._deleted) {\n              tryCode(view.sourceDB, mapFun, [doc]);\n            }\n            mapResults.sort(sortByKeyThenValue);\n\n            var indexableKeysToKeyValues = {};\n            var lastKey;\n            for (var j = 0, jl = mapResults.length; j < jl; j++) {\n              var obj = mapResults[j];\n              var complexKey = [obj.key, obj.id];\n              if (collate$2(obj.key, lastKey) === 0) {\n                complexKey.push(j); // dup key+id, so make it unique\n              }\n              var indexableKey = toIndexableString(complexKey);\n              indexableKeysToKeyValues[indexableKey] = obj;\n              lastKey = obj.key;\n            }\n            docIdsToChangesAndEmits[change.doc._id] = {\n              indexableKeysToKeyValues: indexableKeysToKeyValues,\n              changes: change.changes\n            };\n          }\n          currentSeq = change.seq;\n        }\n        queue.add(processChange(docIdsToChangesAndEmits, currentSeq));\n        if (results.length < CHANGES_BATCH_SIZE$1) {\n          return complete();\n        }\n        return processNextBatch();\n      }).on('error', onError);\n      /* istanbul ignore next */\n      function onError(err) {\n        reject(err);\n      }\n    }\n\n    processNextBatch();\n  });\n}\n\nfunction reduceView(view, results, options) {\n  if (options.group_level === 0) {\n    delete options.group_level;\n  }\n\n  var shouldGroup = options.group || options.group_level;\n\n  var reduceFun;\n  if (builtInReduce[view.reduceFun]) {\n    reduceFun = builtInReduce[view.reduceFun];\n  } else {\n    reduceFun = evalfunc(\n      view.reduceFun.toString(), null, sum, log$2, Array.isArray, JSON.parse);\n  }\n\n  var groups = [];\n  var lvl = isNaN(options.group_level) ? Number.POSITIVE_INFINITY :\n    options.group_level;\n  results.forEach(function (e) {\n    var last = groups[groups.length - 1];\n    var groupKey = shouldGroup ? e.key : null;\n\n    // only set group_level for array keys\n    if (shouldGroup && Array.isArray(groupKey)) {\n      groupKey = groupKey.slice(0, lvl);\n    }\n\n    if (last && collate$2(last.groupKey, groupKey) === 0) {\n      last.keys.push([e.key, e.id]);\n      last.values.push(e.value);\n      return;\n    }\n    groups.push({\n      keys: [[e.key, e.id]],\n      values: [e.value],\n      groupKey: groupKey\n    });\n  });\n  results = [];\n  for (var i = 0, len = groups.length; i < len; i++) {\n    var e = groups[i];\n    var reduceTry = tryCode(view.sourceDB, reduceFun,\n      [e.keys, e.values, false]);\n    if (reduceTry.error && reduceTry.error instanceof BuiltInError) {\n      // CouchDB returns an error if a built-in errors out\n      throw reduceTry.error;\n    }\n    results.push({\n      // CouchDB just sets the value to null if a non-built-in errors out\n      value: reduceTry.error ? null : reduceTry.output,\n      key: e.groupKey\n    });\n  }\n  // no total_rows/offset when reducing\n  return {rows: sliceResults(results, options.limit, options.skip)};\n}\n\nfunction queryView(view, opts) {\n  return sequentialize(getQueue(view), function () {\n    return queryViewInQueue(view, opts);\n  })();\n}\n\nfunction queryViewInQueue(view, opts) {\n  var totalRows;\n  var shouldReduce = view.reduceFun && opts.reduce !== false;\n  var skip = opts.skip || 0;\n  if (typeof opts.keys !== 'undefined' && !opts.keys.length) {\n    // equivalent query\n    opts.limit = 0;\n    delete opts.keys;\n  }\n\n  function fetchFromView(viewOpts) {\n    viewOpts.include_docs = true;\n    return view.db.allDocs(viewOpts).then(function (res) {\n      totalRows = res.total_rows;\n      return res.rows.map(function (result) {\n\n        // implicit migration - in older versions of PouchDB,\n        // we explicitly stored the doc as {id: ..., key: ..., value: ...}\n        // this is tested in a migration test\n        /* istanbul ignore next */\n        if ('value' in result.doc && typeof result.doc.value === 'object' &&\n            result.doc.value !== null) {\n          var keys = Object.keys(result.doc.value).sort();\n          // this detection method is not perfect, but it's unlikely the user\n          // emitted a value which was an object with these 3 exact keys\n          var expectedKeys = ['id', 'key', 'value'];\n          if (!(keys < expectedKeys || keys > expectedKeys)) {\n            return result.doc.value;\n          }\n        }\n\n        var parsedKeyAndDocId = parseIndexableString(result.doc._id);\n        return {\n          key: parsedKeyAndDocId[0],\n          id: parsedKeyAndDocId[1],\n          value: ('value' in result.doc ? result.doc.value : null)\n        };\n      });\n    });\n  }\n\n  function onMapResultsReady(rows) {\n    var finalResults;\n    if (shouldReduce) {\n      finalResults = reduceView(view, rows, opts);\n    } else {\n      finalResults = {\n        total_rows: totalRows,\n        offset: skip,\n        rows: rows\n      };\n    }\n    if (opts.include_docs) {\n      var docIds = uniq(rows.map(rowToDocId));\n\n      return view.sourceDB.allDocs({\n        keys: docIds,\n        include_docs: true,\n        conflicts: opts.conflicts,\n        attachments: opts.attachments,\n        binary: opts.binary\n      }).then(function (allDocsRes) {\n        var docIdsToDocs = {};\n        allDocsRes.rows.forEach(function (row) {\n          if (row.doc) {\n            docIdsToDocs['$' + row.id] = row.doc;\n          }\n        });\n        rows.forEach(function (row) {\n          var docId = rowToDocId(row);\n          var doc = docIdsToDocs['$' + docId];\n          if (doc) {\n            row.doc = doc;\n          }\n        });\n        return finalResults;\n      });\n    } else {\n      return finalResults;\n    }\n  }\n\n  if (typeof opts.keys !== 'undefined') {\n    var keys = opts.keys;\n    var fetchPromises = keys.map(function (key) {\n      var viewOpts = {\n        startkey : toIndexableString([key]),\n        endkey   : toIndexableString([key, {}])\n      };\n      return fetchFromView(viewOpts);\n    });\n    return PouchPromise.all(fetchPromises).then(flatten).then(onMapResultsReady);\n  } else { // normal query, no 'keys'\n    var viewOpts = {\n      descending : opts.descending\n    };\n    if (opts.start_key) {\n        opts.startkey = opts.start_key;\n    }\n    if (opts.end_key) {\n        opts.endkey = opts.end_key;\n    }\n    if (typeof opts.startkey !== 'undefined') {\n      viewOpts.startkey = opts.descending ?\n        toIndexableString([opts.startkey, {}]) :\n        toIndexableString([opts.startkey]);\n    }\n    if (typeof opts.endkey !== 'undefined') {\n      var inclusiveEnd = opts.inclusive_end !== false;\n      if (opts.descending) {\n        inclusiveEnd = !inclusiveEnd;\n      }\n\n      viewOpts.endkey = toIndexableString(\n        inclusiveEnd ? [opts.endkey, {}] : [opts.endkey]);\n    }\n    if (typeof opts.key !== 'undefined') {\n      var keyStart = toIndexableString([opts.key]);\n      var keyEnd = toIndexableString([opts.key, {}]);\n      if (viewOpts.descending) {\n        viewOpts.endkey = keyStart;\n        viewOpts.startkey = keyEnd;\n      } else {\n        viewOpts.startkey = keyStart;\n        viewOpts.endkey = keyEnd;\n      }\n    }\n    if (!shouldReduce) {\n      if (typeof opts.limit === 'number') {\n        viewOpts.limit = opts.limit;\n      }\n      viewOpts.skip = skip;\n    }\n    return fetchFromView(viewOpts).then(onMapResultsReady);\n  }\n}\n\nfunction httpViewCleanup(db) {\n  return db.request({\n    method: 'POST',\n    url: '_view_cleanup'\n  });\n}\n\nfunction localViewCleanup(db) {\n  return db.get('_local/mrviews').then(function (metaDoc) {\n    var docsToViews = {};\n    Object.keys(metaDoc.views).forEach(function (fullViewName) {\n      var parts = parseViewName(fullViewName);\n      var designDocName = '_design/' + parts[0];\n      var viewName = parts[1];\n      docsToViews[designDocName] = docsToViews[designDocName] || {};\n      docsToViews[designDocName][viewName] = true;\n    });\n    var opts = {\n      keys : Object.keys(docsToViews),\n      include_docs : true\n    };\n    return db.allDocs(opts).then(function (res) {\n      var viewsToStatus = {};\n      res.rows.forEach(function (row) {\n        var ddocName = row.key.substring(8);\n        Object.keys(docsToViews[row.key]).forEach(function (viewName) {\n          var fullViewName = ddocName + '/' + viewName;\n          /* istanbul ignore if */\n          if (!metaDoc.views[fullViewName]) {\n            // new format, without slashes, to support PouchDB 2.2.0\n            // migration test in pouchdb's browser.migration.js verifies this\n            fullViewName = viewName;\n          }\n          var viewDBNames = Object.keys(metaDoc.views[fullViewName]);\n          // design doc deleted, or view function nonexistent\n          var statusIsGood = row.doc && row.doc.views &&\n            row.doc.views[viewName];\n          viewDBNames.forEach(function (viewDBName) {\n            viewsToStatus[viewDBName] =\n              viewsToStatus[viewDBName] || statusIsGood;\n          });\n        });\n      });\n      var dbsToDelete = Object.keys(viewsToStatus).filter(\n        function (viewDBName) { return !viewsToStatus[viewDBName]; });\n      var destroyPromises = dbsToDelete.map(function (viewDBName) {\n        return sequentialize(getQueue(viewDBName), function () {\n          return new db.constructor(viewDBName, db.__opts).destroy();\n        })();\n      });\n      return PouchPromise.all(destroyPromises).then(function () {\n        return {ok: true};\n      });\n    });\n  }, defaultsTo({ok: true}));\n}\n\nvar viewCleanup = callbackify(function () {\n  var db = this;\n  if (db._ddocCache) {\n    delete db._ddocCache;\n  }\n  if (db.type() === 'http') {\n    return httpViewCleanup(db);\n  }\n  /* istanbul ignore next */\n  if (typeof db._viewCleanup === 'function') {\n    return customViewCleanup(db);\n  }\n  return localViewCleanup(db);\n});\n\nfunction queryPromised(db, fun, opts) {\n  if (db.type() === 'http') {\n    return httpQuery(db, fun, opts);\n  }\n\n  /* istanbul ignore next */\n  if (typeof db._query === 'function') {\n    return customQuery(db, fun, opts);\n  }\n\n  if (typeof fun !== 'string') {\n    // temp_view\n    checkQueryParseError(opts, fun);\n\n    var createViewOpts = {\n      db : db,\n      viewName : 'temp_view/temp_view',\n      map : fun.map,\n      reduce : fun.reduce,\n      temporary : true\n    };\n    tempViewQueue.add(function () {\n      return createView(createViewOpts).then(function (view) {\n        function cleanup() {\n          return view.db.destroy();\n        }\n        return fin(updateView(view).then(function () {\n          return queryView(view, opts);\n        }), cleanup);\n      });\n    });\n    return tempViewQueue.finish();\n  } else {\n    // persistent view\n    var fullViewName = fun;\n    var parts = parseViewName(fullViewName);\n    var designDocName = parts[0];\n    var viewName = parts[1];\n    return db.getView(designDocName, viewName).then(function (fun) {\n      checkQueryParseError(opts, fun);\n\n      var createViewOpts = {\n        db : db,\n        viewName : fullViewName,\n        map : fun.map,\n        reduce : fun.reduce\n      };\n      return createView(createViewOpts).then(function (view) {\n        if (opts.stale === 'ok' || opts.stale === 'update_after') {\n          if (opts.stale === 'update_after') {\n            process.nextTick(function () {\n              updateView(view);\n            });\n          }\n          return queryView(view, opts);\n        } else { // stale not ok\n          return updateView(view).then(function () {\n            return queryView(view, opts);\n          });\n        }\n      });\n    });\n  }\n}\n\nvar query = function (fun, opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n  opts = opts ? coerceOptions(opts) : {};\n\n  if (typeof fun === 'function') {\n    fun = {map : fun};\n  }\n\n  var db = this;\n  var promise = PouchPromise.resolve().then(function () {\n    return queryPromised(db, fun, opts);\n  });\n  promisedCallback(promise, callback);\n  return promise;\n};\n\nfunction QueryParseError(message) {\n  this.status = 400;\n  this.name = 'query_parse_error';\n  this.message = message;\n  this.error = true;\n  try {\n    Error.captureStackTrace(this, QueryParseError);\n  } catch (e) {}\n}\n\ninherits(QueryParseError, Error);\n\nfunction BuiltInError(message) {\n  this.status = 500;\n  this.name = 'invalid_value';\n  this.message = message;\n  this.error = true;\n  try {\n    Error.captureStackTrace(this, BuiltInError);\n  } catch (e) {}\n}\n\ninherits(BuiltInError, Error);\n\nvar mapreduce = {\n  query: query,\n  viewCleanup: viewCleanup\n};\n\nfunction arrayBufferToBase64(buffer) {\n  return btoa$1(arrayBufferToBinaryString(buffer));\n}\n\nfunction preprocessAttachments$1(docInfos, blobType, callback) {\n\n  if (!docInfos.length) {\n    return callback();\n  }\n\n  var docv = 0;\n\n  function parseBase64(data) {\n    try {\n      return atob$1(data);\n    } catch (e) {\n      var err = createError(BAD_ARG,\n        'Attachment is not a valid base64 string');\n      return {error: err};\n    }\n  }\n\n  function preprocessAttachment(att, callback) {\n    if (att.stub) {\n      return callback();\n    }\n    if (typeof att.data === 'string') {\n      // input is assumed to be a base64 string\n\n      var asBinary = parseBase64(att.data);\n      if (asBinary.error) {\n        return callback(asBinary.error);\n      }\n\n      att.length = asBinary.length;\n      if (blobType === 'blob') {\n        att.data = binStringToBluffer(asBinary, att.content_type);\n      } else if (blobType === 'base64') {\n        att.data = btoa$1(asBinary);\n      } else { // binary\n        att.data = asBinary;\n      }\n      md5(asBinary).then(function (result) {\n        att.digest = 'md5-' + result;\n        callback();\n      });\n    } else { // input is a blob\n      readAsArrayBuffer(att.data, function (buff) {\n        if (blobType === 'binary') {\n          att.data = arrayBufferToBinaryString(buff);\n        } else if (blobType === 'base64') {\n          att.data = arrayBufferToBase64(buff);\n        }\n        md5(buff).then(function (result) {\n          att.digest = 'md5-' + result;\n          att.length = buff.byteLength;\n          callback();\n        });\n      });\n    }\n  }\n\n  var overallErr;\n\n  docInfos.forEach(function (docInfo) {\n    var attachments = docInfo.data && docInfo.data._attachments ?\n      Object.keys(docInfo.data._attachments) : [];\n    var recv = 0;\n\n    if (!attachments.length) {\n      return done();\n    }\n\n    function processedAttachment(err) {\n      overallErr = err;\n      recv++;\n      if (recv === attachments.length) {\n        done();\n      }\n    }\n\n    for (var key in docInfo.data._attachments) {\n      if (docInfo.data._attachments.hasOwnProperty(key)) {\n        preprocessAttachment(docInfo.data._attachments[key],\n          processedAttachment);\n      }\n    }\n  });\n\n  function done() {\n    docv++;\n    if (docInfos.length === docv) {\n      if (overallErr) {\n        callback(overallErr);\n      } else {\n        callback();\n      }\n    }\n  }\n}\n\nfunction sortByPos$1(a, b) {\n  return a.pos - b.pos;\n}\n\n// classic binary search\nfunction binarySearch(arr, item, comparator) {\n  var low = 0;\n  var high = arr.length;\n  var mid;\n  while (low < high) {\n    mid = (low + high) >>> 1;\n    if (comparator(arr[mid], item) < 0) {\n      low = mid + 1;\n    } else {\n      high = mid;\n    }\n  }\n  return low;\n}\n\n// assuming the arr is sorted, insert the item in the proper place\nfunction insertSorted(arr, item, comparator) {\n  var idx = binarySearch(arr, item, comparator);\n  arr.splice(idx, 0, item);\n}\n\n// Turn a path as a flat array into a tree with a single branch.\n// If any should be stemmed from the beginning of the array, that's passed\n// in as the second argument\nfunction pathToTree(path, numStemmed) {\n  var root;\n  var leaf;\n  for (var i = numStemmed, len = path.length; i < len; i++) {\n    var node = path[i];\n    var currentLeaf = [node.id, node.opts, []];\n    if (leaf) {\n      leaf[2].push(currentLeaf);\n      leaf = currentLeaf;\n    } else {\n      root = leaf = currentLeaf;\n    }\n  }\n  return root;\n}\n\n// compare the IDs of two trees\nfunction compareTree(a, b) {\n  return a[0] < b[0] ? -1 : 1;\n}\n\n// Merge two trees together\n// The roots of tree1 and tree2 must be the same revision\nfunction mergeTree(in_tree1, in_tree2) {\n  var queue = [{tree1: in_tree1, tree2: in_tree2}];\n  var conflicts = false;\n  while (queue.length > 0) {\n    var item = queue.pop();\n    var tree1 = item.tree1;\n    var tree2 = item.tree2;\n\n    if (tree1[1].status || tree2[1].status) {\n      tree1[1].status =\n        (tree1[1].status ===  'available' ||\n        tree2[1].status === 'available') ? 'available' : 'missing';\n    }\n\n    for (var i = 0; i < tree2[2].length; i++) {\n      if (!tree1[2][0]) {\n        conflicts = 'new_leaf';\n        tree1[2][0] = tree2[2][i];\n        continue;\n      }\n\n      var merged = false;\n      for (var j = 0; j < tree1[2].length; j++) {\n        if (tree1[2][j][0] === tree2[2][i][0]) {\n          queue.push({tree1: tree1[2][j], tree2: tree2[2][i]});\n          merged = true;\n        }\n      }\n      if (!merged) {\n        conflicts = 'new_branch';\n        insertSorted(tree1[2], tree2[2][i], compareTree);\n      }\n    }\n  }\n  return {conflicts: conflicts, tree: in_tree1};\n}\n\nfunction doMerge(tree, path, dontExpand) {\n  var restree = [];\n  var conflicts = false;\n  var merged = false;\n  var res;\n\n  if (!tree.length) {\n    return {tree: [path], conflicts: 'new_leaf'};\n  }\n\n  for (var i = 0, len = tree.length; i < len; i++) {\n    var branch = tree[i];\n    if (branch.pos === path.pos && branch.ids[0] === path.ids[0]) {\n      // Paths start at the same position and have the same root, so they need\n      // merged\n      res = mergeTree(branch.ids, path.ids);\n      restree.push({pos: branch.pos, ids: res.tree});\n      conflicts = conflicts || res.conflicts;\n      merged = true;\n    } else if (dontExpand !== true) {\n      // The paths start at a different position, take the earliest path and\n      // traverse up until it as at the same point from root as the path we\n      // want to merge.  If the keys match we return the longer path with the\n      // other merged After stemming we dont want to expand the trees\n\n      var t1 = branch.pos < path.pos ? branch : path;\n      var t2 = branch.pos < path.pos ? path : branch;\n      var diff = t2.pos - t1.pos;\n\n      var candidateParents = [];\n\n      var trees = [];\n      trees.push({ids: t1.ids, diff: diff, parent: null, parentIdx: null});\n      while (trees.length > 0) {\n        var item = trees.pop();\n        if (item.diff === 0) {\n          if (item.ids[0] === t2.ids[0]) {\n            candidateParents.push(item);\n          }\n          continue;\n        }\n        var elements = item.ids[2];\n        for (var j = 0, elementsLen = elements.length; j < elementsLen; j++) {\n          trees.push({\n            ids: elements[j],\n            diff: item.diff - 1,\n            parent: item.ids,\n            parentIdx: j\n          });\n        }\n      }\n\n      var el = candidateParents[0];\n\n      if (!el) {\n        restree.push(branch);\n      } else {\n        res = mergeTree(el.ids, t2.ids);\n        el.parent[2][el.parentIdx] = res.tree;\n        restree.push({pos: t1.pos, ids: t1.ids});\n        conflicts = conflicts || res.conflicts;\n        merged = true;\n      }\n    } else {\n      restree.push(branch);\n    }\n  }\n\n  // We didnt find\n  if (!merged) {\n    restree.push(path);\n  }\n\n  restree.sort(sortByPos$1);\n\n  return {\n    tree: restree,\n    conflicts: conflicts || 'internal_node'\n  };\n}\n\n// To ensure we dont grow the revision tree infinitely, we stem old revisions\nfunction stem(tree, depth) {\n  // First we break out the tree into a complete list of root to leaf paths\n  var paths = rootToLeaf(tree);\n  var maybeStem = {};\n\n  var result;\n  for (var i = 0, len = paths.length; i < len; i++) {\n    // Then for each path, we cut off the start of the path based on the\n    // `depth` to stem to, and generate a new set of flat trees\n    var path = paths[i];\n    var stemmed = path.ids;\n    var numStemmed = Math.max(0, stemmed.length - depth);\n    var stemmedNode = {\n      pos: path.pos + numStemmed,\n      ids: pathToTree(stemmed, numStemmed)\n    };\n\n    for (var s = 0; s < numStemmed; s++) {\n      var rev = (path.pos + s) + '-' + stemmed[s].id;\n      maybeStem[rev] = true;\n    }\n\n    // Then we remerge all those flat trees together, ensuring that we dont\n    // connect trees that would go beyond the depth limit\n    if (result) {\n      result = doMerge(result, stemmedNode, true).tree;\n    } else {\n      result = [stemmedNode];\n    }\n  }\n\n  traverseRevTree(result, function (isLeaf, pos, revHash) {\n    // some revisions may have been removed in a branch but not in another\n    delete maybeStem[pos + '-' + revHash];\n  });\n\n  return {\n    tree: result,\n    revs: Object.keys(maybeStem)\n  };\n}\n\nfunction merge(tree, path, depth) {\n  var newTree = doMerge(tree, path);\n  var stemmed = stem(newTree.tree, depth);\n  return {\n    tree: stemmed.tree,\n    stemmedRevs: stemmed.revs,\n    conflicts: newTree.conflicts\n  };\n}\n\n// return true if a rev exists in the rev tree, false otherwise\nfunction revExists(revs, rev) {\n  var toVisit = revs.slice();\n  var splitRev = rev.split('-');\n  var targetPos = parseInt(splitRev[0], 10);\n  var targetId = splitRev[1];\n\n  var node;\n  while ((node = toVisit.pop())) {\n    if (node.pos === targetPos && node.ids[0] === targetId) {\n      return true;\n    }\n    var branches = node.ids[2];\n    for (var i = 0, len = branches.length; i < len; i++) {\n      toVisit.push({pos: node.pos + 1, ids: branches[i]});\n    }\n  }\n  return false;\n}\n\nfunction updateDoc(revLimit, prev, docInfo, results,\n                   i, cb, writeDoc, newEdits) {\n\n  if (revExists(prev.rev_tree, docInfo.metadata.rev)) {\n    results[i] = docInfo;\n    return cb();\n  }\n\n  // sometimes this is pre-calculated. historically not always\n  var previousWinningRev = prev.winningRev || winningRev(prev);\n  var previouslyDeleted = 'deleted' in prev ? prev.deleted :\n    isDeleted(prev, previousWinningRev);\n  var deleted = 'deleted' in docInfo.metadata ? docInfo.metadata.deleted :\n    isDeleted(docInfo.metadata);\n  var isRoot = /^1-/.test(docInfo.metadata.rev);\n\n  if (previouslyDeleted && !deleted && newEdits && isRoot) {\n    var newDoc = docInfo.data;\n    newDoc._rev = previousWinningRev;\n    newDoc._id = docInfo.metadata.id;\n    docInfo = parseDoc(newDoc, newEdits);\n  }\n\n  var merged = merge(prev.rev_tree, docInfo.metadata.rev_tree[0], revLimit);\n\n  var inConflict = newEdits && (((previouslyDeleted && deleted) ||\n    (!previouslyDeleted && merged.conflicts !== 'new_leaf') ||\n    (previouslyDeleted && !deleted && merged.conflicts === 'new_branch')));\n\n  if (inConflict) {\n    var err = createError(REV_CONFLICT);\n    results[i] = err;\n    return cb();\n  }\n\n  var newRev = docInfo.metadata.rev;\n  docInfo.metadata.rev_tree = merged.tree;\n  docInfo.stemmedRevs = merged.stemmedRevs || [];\n  /* istanbul ignore else */\n  if (prev.rev_map) {\n    docInfo.metadata.rev_map = prev.rev_map; // used only by leveldb\n  }\n\n  // recalculate\n  var winningRev$$ = winningRev(docInfo.metadata);\n  var winningRevIsDeleted = isDeleted(docInfo.metadata, winningRev$$);\n\n  // calculate the total number of documents that were added/removed,\n  // from the perspective of total_rows/doc_count\n  var delta = (previouslyDeleted === winningRevIsDeleted) ? 0 :\n    previouslyDeleted < winningRevIsDeleted ? -1 : 1;\n\n  var newRevIsDeleted;\n  if (newRev === winningRev$$) {\n    // if the new rev is the same as the winning rev, we can reuse that value\n    newRevIsDeleted = winningRevIsDeleted;\n  } else {\n    // if they're not the same, then we need to recalculate\n    newRevIsDeleted = isDeleted(docInfo.metadata, newRev);\n  }\n\n  writeDoc(docInfo, winningRev$$, winningRevIsDeleted, newRevIsDeleted,\n    true, delta, i, cb);\n}\n\nfunction rootIsMissing(docInfo) {\n  return docInfo.metadata.rev_tree[0].ids[1].status === 'missing';\n}\n\nfunction processDocs(revLimit, docInfos, api, fetchedDocs, tx, results,\n                     writeDoc, opts, overallCallback) {\n\n  // Default to 1000 locally\n  revLimit = revLimit || 1000;\n\n  function insertDoc(docInfo, resultsIdx, callback) {\n    // Cant insert new deleted documents\n    var winningRev$$ = winningRev(docInfo.metadata);\n    var deleted = isDeleted(docInfo.metadata, winningRev$$);\n    if ('was_delete' in opts && deleted) {\n      results[resultsIdx] = createError(MISSING_DOC, 'deleted');\n      return callback();\n    }\n\n    // 4712 - detect whether a new document was inserted with a _rev\n    var inConflict = newEdits && rootIsMissing(docInfo);\n\n    if (inConflict) {\n      var err = createError(REV_CONFLICT);\n      results[resultsIdx] = err;\n      return callback();\n    }\n\n    var delta = deleted ? 0 : 1;\n\n    writeDoc(docInfo, winningRev$$, deleted, deleted, false,\n      delta, resultsIdx, callback);\n  }\n\n  var newEdits = opts.new_edits;\n  var idsToDocs = new pouchdbCollections.Map();\n\n  var docsDone = 0;\n  var docsToDo = docInfos.length;\n\n  function checkAllDocsDone() {\n    if (++docsDone === docsToDo && overallCallback) {\n      overallCallback();\n    }\n  }\n\n  docInfos.forEach(function (currentDoc, resultsIdx) {\n\n    if (currentDoc._id && isLocalId(currentDoc._id)) {\n      var fun = currentDoc._deleted ? '_removeLocal' : '_putLocal';\n      api[fun](currentDoc, {ctx: tx}, function (err, res) {\n        results[resultsIdx] = err || res;\n        checkAllDocsDone();\n      });\n      return;\n    }\n\n    var id = currentDoc.metadata.id;\n    if (idsToDocs.has(id)) {\n      docsToDo--; // duplicate\n      idsToDocs.get(id).push([currentDoc, resultsIdx]);\n    } else {\n      idsToDocs.set(id, [[currentDoc, resultsIdx]]);\n    }\n  });\n\n  // in the case of new_edits, the user can provide multiple docs\n  // with the same id. these need to be processed sequentially\n  idsToDocs.forEach(function (docs, id) {\n    var numDone = 0;\n\n    function docWritten() {\n      if (++numDone < docs.length) {\n        nextDoc();\n      } else {\n        checkAllDocsDone();\n      }\n    }\n    function nextDoc() {\n      var value = docs[numDone];\n      var currentDoc = value[0];\n      var resultsIdx = value[1];\n\n      if (fetchedDocs.has(id)) {\n        updateDoc(revLimit, fetchedDocs.get(id), currentDoc, results,\n          resultsIdx, docWritten, writeDoc, newEdits);\n      } else {\n        // Ensure stemming applies to new writes as well\n        var merged = merge([], currentDoc.metadata.rev_tree[0], revLimit);\n        currentDoc.metadata.rev_tree = merged.tree;\n        currentDoc.stemmedRevs = merged.stemmedRevs || [];\n        insertDoc(currentDoc, resultsIdx, docWritten);\n      }\n    }\n    nextDoc();\n  });\n}\n\n// compact a tree by marking its non-leafs as missing,\n// and return a list of revs to delete\nfunction compactTree(metadata) {\n  var revs = [];\n  traverseRevTree(metadata.rev_tree, function (isLeaf, pos,\n                                               revHash, ctx, opts) {\n    if (opts.status === 'available' && !isLeaf) {\n      revs.push(pos + '-' + revHash);\n      opts.status = 'missing';\n    }\n  });\n  return revs;\n}\n\n// IndexedDB requires a versioned database structure, so we use the\n// version here to manage migrations.\nvar ADAPTER_VERSION = 5;\n\n// The object stores created for each database\n// DOC_STORE stores the document meta data, its revision history and state\n// Keyed by document id\nvar DOC_STORE = 'document-store';\n// BY_SEQ_STORE stores a particular version of a document, keyed by its\n// sequence id\nvar BY_SEQ_STORE = 'by-sequence';\n// Where we store attachments\nvar ATTACH_STORE = 'attach-store';\n// Where we store many-to-many relations\n// between attachment digests and seqs\nvar ATTACH_AND_SEQ_STORE = 'attach-seq-store';\n\n// Where we store database-wide meta data in a single record\n// keyed by id: META_STORE\nvar META_STORE = 'meta-store';\n// Where we store local documents\nvar LOCAL_STORE = 'local-store';\n// Where we detect blob support\nvar DETECT_BLOB_SUPPORT_STORE = 'detect-blob-support';\n\nfunction slowJsonParse(str) {\n  try {\n    return JSON.parse(str);\n  } catch (e) {\n    /* istanbul ignore next */\n    return vuvuzela.parse(str);\n  }\n}\n\nfunction safeJsonParse(str) {\n  // try/catch is deoptimized in V8, leading to slower\n  // times than we'd like to have. Most documents are _not_\n  // huge, and do not require a slower code path just to parse them.\n  // We can be pretty sure that a document under 50000 characters\n  // will not be so deeply nested as to throw a stack overflow error\n  // (depends on the engine and available memory, though, so this is\n  // just a hunch). 50000 was chosen based on the average length\n  // of this string in our test suite, to try to find a number that covers\n  // most of our test cases (26 over this size, 26378 under it).\n  if (str.length < 50000) {\n    return JSON.parse(str);\n  }\n  return slowJsonParse(str);\n}\n\nfunction safeJsonStringify(json) {\n  try {\n    return JSON.stringify(json);\n  } catch (e) {\n    /* istanbul ignore next */\n    return vuvuzela.stringify(json);\n  }\n}\n\nfunction tryCode$1(fun, that, args, PouchDB) {\n  try {\n    fun.apply(that, args);\n  } catch (err) {\n    // Shouldn't happen, but in some odd cases\n    // IndexedDB implementations might throw a sync\n    // error, in which case this will at least log it.\n    PouchDB.emit('error', err);\n  }\n}\n\nvar taskQueue = {\n  running: false,\n  queue: []\n};\n\nfunction applyNext(PouchDB) {\n  if (taskQueue.running || !taskQueue.queue.length) {\n    return;\n  }\n  taskQueue.running = true;\n  var item = taskQueue.queue.shift();\n  item.action(function (err, res) {\n    tryCode$1(item.callback, this, [err, res], PouchDB);\n    taskQueue.running = false;\n    process.nextTick(function () {\n      applyNext(PouchDB);\n    });\n  });\n}\n\nfunction idbError(callback) {\n  return function (evt) {\n    var message = 'unknown_error';\n    if (evt.target && evt.target.error) {\n      message = evt.target.error.name || evt.target.error.message;\n    }\n    callback(createError(IDB_ERROR, message, evt.type));\n  };\n}\n\n// Unfortunately, the metadata has to be stringified\n// when it is put into the database, because otherwise\n// IndexedDB can throw errors for deeply-nested objects.\n// Originally we just used JSON.parse/JSON.stringify; now\n// we use this custom vuvuzela library that avoids recursion.\n// If we could do it all over again, we'd probably use a\n// format for the revision trees other than JSON.\nfunction encodeMetadata(metadata, winningRev, deleted) {\n  return {\n    data: safeJsonStringify(metadata),\n    winningRev: winningRev,\n    deletedOrLocal: deleted ? '1' : '0',\n    seq: metadata.seq, // highest seq for this doc\n    id: metadata.id\n  };\n}\n\nfunction decodeMetadata(storedObject) {\n  if (!storedObject) {\n    return null;\n  }\n  var metadata = safeJsonParse(storedObject.data);\n  metadata.winningRev = storedObject.winningRev;\n  metadata.deleted = storedObject.deletedOrLocal === '1';\n  metadata.seq = storedObject.seq;\n  return metadata;\n}\n\n// read the doc back out from the database. we don't store the\n// _id or _rev because we already have _doc_id_rev.\nfunction decodeDoc(doc) {\n  if (!doc) {\n    return doc;\n  }\n  var idx = doc._doc_id_rev.lastIndexOf(':');\n  doc._id = doc._doc_id_rev.substring(0, idx - 1);\n  doc._rev = doc._doc_id_rev.substring(idx + 1);\n  delete doc._doc_id_rev;\n  return doc;\n}\n\n// Read a blob from the database, encoding as necessary\n// and translating from base64 if the IDB doesn't support\n// native Blobs\nfunction readBlobData(body, type, asBlob, callback) {\n  if (asBlob) {\n    if (!body) {\n      callback(createBlob([''], {type: type}));\n    } else if (typeof body !== 'string') { // we have blob support\n      callback(body);\n    } else { // no blob support\n      callback(b64ToBluffer(body, type));\n    }\n  } else { // as base64 string\n    if (!body) {\n      callback('');\n    } else if (typeof body !== 'string') { // we have blob support\n      readAsBinaryString(body, function (binary) {\n        callback(btoa$1(binary));\n      });\n    } else { // no blob support\n      callback(body);\n    }\n  }\n}\n\nfunction fetchAttachmentsIfNecessary(doc, opts, txn, cb) {\n  var attachments = Object.keys(doc._attachments || {});\n  if (!attachments.length) {\n    return cb && cb();\n  }\n  var numDone = 0;\n\n  function checkDone() {\n    if (++numDone === attachments.length && cb) {\n      cb();\n    }\n  }\n\n  function fetchAttachment(doc, att) {\n    var attObj = doc._attachments[att];\n    var digest = attObj.digest;\n    var req = txn.objectStore(ATTACH_STORE).get(digest);\n    req.onsuccess = function (e) {\n      attObj.body = e.target.result.body;\n      checkDone();\n    };\n  }\n\n  attachments.forEach(function (att) {\n    if (opts.attachments && opts.include_docs) {\n      fetchAttachment(doc, att);\n    } else {\n      doc._attachments[att].stub = true;\n      checkDone();\n    }\n  });\n}\n\n// IDB-specific postprocessing necessary because\n// we don't know whether we stored a true Blob or\n// a base64-encoded string, and if it's a Blob it\n// needs to be read outside of the transaction context\nfunction postProcessAttachments(results, asBlob) {\n  return PouchPromise.all(results.map(function (row) {\n    if (row.doc && row.doc._attachments) {\n      var attNames = Object.keys(row.doc._attachments);\n      return PouchPromise.all(attNames.map(function (att) {\n        var attObj = row.doc._attachments[att];\n        if (!('body' in attObj)) { // already processed\n          return;\n        }\n        var body = attObj.body;\n        var type = attObj.content_type;\n        return new PouchPromise(function (resolve) {\n          readBlobData(body, type, asBlob, function (data) {\n            row.doc._attachments[att] = jsExtend.extend(\n              pick(attObj, ['digest', 'content_type']),\n              {data: data}\n            );\n            resolve();\n          });\n        });\n      }));\n    }\n  }));\n}\n\nfunction compactRevs(revs, docId, txn) {\n\n  var possiblyOrphanedDigests = [];\n  var seqStore = txn.objectStore(BY_SEQ_STORE);\n  var attStore = txn.objectStore(ATTACH_STORE);\n  var attAndSeqStore = txn.objectStore(ATTACH_AND_SEQ_STORE);\n  var count = revs.length;\n\n  function checkDone() {\n    count--;\n    if (!count) { // done processing all revs\n      deleteOrphanedAttachments();\n    }\n  }\n\n  function deleteOrphanedAttachments() {\n    if (!possiblyOrphanedDigests.length) {\n      return;\n    }\n    possiblyOrphanedDigests.forEach(function (digest) {\n      var countReq = attAndSeqStore.index('digestSeq').count(\n        IDBKeyRange.bound(\n          digest + '::', digest + '::\\uffff', false, false));\n      countReq.onsuccess = function (e) {\n        var count = e.target.result;\n        if (!count) {\n          // orphaned\n          attStore.delete(digest);\n        }\n      };\n    });\n  }\n\n  revs.forEach(function (rev) {\n    var index = seqStore.index('_doc_id_rev');\n    var key = docId + \"::\" + rev;\n    index.getKey(key).onsuccess = function (e) {\n      var seq = e.target.result;\n      if (typeof seq !== 'number') {\n        return checkDone();\n      }\n      seqStore.delete(seq);\n\n      var cursor = attAndSeqStore.index('seq')\n        .openCursor(IDBKeyRange.only(seq));\n\n      cursor.onsuccess = function (event) {\n        var cursor = event.target.result;\n        if (cursor) {\n          var digest = cursor.value.digestSeq.split('::')[0];\n          possiblyOrphanedDigests.push(digest);\n          attAndSeqStore.delete(cursor.primaryKey);\n          cursor.continue();\n        } else { // done\n          checkDone();\n        }\n      };\n    };\n  });\n}\n\nfunction openTransactionSafely(idb, stores, mode) {\n  try {\n    return {\n      txn: idb.transaction(stores, mode)\n    };\n  } catch (err) {\n    return {\n      error: err\n    };\n  }\n}\n\nfunction idbBulkDocs(dbOpts, req, opts, api, idb, idbChanges, callback) {\n  var docInfos = req.docs;\n  var txn;\n  var docStore;\n  var bySeqStore;\n  var attachStore;\n  var attachAndSeqStore;\n  var docInfoError;\n  var docCountDelta = 0;\n\n  for (var i = 0, len = docInfos.length; i < len; i++) {\n    var doc = docInfos[i];\n    if (doc._id && isLocalId(doc._id)) {\n      continue;\n    }\n    doc = docInfos[i] = parseDoc(doc, opts.new_edits);\n    if (doc.error && !docInfoError) {\n      docInfoError = doc;\n    }\n  }\n\n  if (docInfoError) {\n    return callback(docInfoError);\n  }\n\n  var results = new Array(docInfos.length);\n  var fetchedDocs = new pouchdbCollections.Map();\n  var preconditionErrored = false;\n  var blobType = api._meta.blobSupport ? 'blob' : 'base64';\n\n  preprocessAttachments$1(docInfos, blobType, function (err) {\n    if (err) {\n      return callback(err);\n    }\n    startTransaction();\n  });\n\n  function startTransaction() {\n\n    var stores = [\n      DOC_STORE, BY_SEQ_STORE,\n      ATTACH_STORE,\n      LOCAL_STORE, ATTACH_AND_SEQ_STORE\n    ];\n    var txnResult = openTransactionSafely(idb, stores, 'readwrite');\n    if (txnResult.error) {\n      return callback(txnResult.error);\n    }\n    txn = txnResult.txn;\n    txn.onabort = idbError(callback);\n    txn.ontimeout = idbError(callback);\n    txn.oncomplete = complete;\n    docStore = txn.objectStore(DOC_STORE);\n    bySeqStore = txn.objectStore(BY_SEQ_STORE);\n    attachStore = txn.objectStore(ATTACH_STORE);\n    attachAndSeqStore = txn.objectStore(ATTACH_AND_SEQ_STORE);\n\n    verifyAttachments(function (err) {\n      if (err) {\n        preconditionErrored = true;\n        return callback(err);\n      }\n      fetchExistingDocs();\n    });\n  }\n\n  function idbProcessDocs() {\n    processDocs(dbOpts.revs_limit, docInfos, api, fetchedDocs,\n                txn, results, writeDoc, opts);\n  }\n\n  function fetchExistingDocs() {\n\n    if (!docInfos.length) {\n      return;\n    }\n\n    var numFetched = 0;\n\n    function checkDone() {\n      if (++numFetched === docInfos.length) {\n        idbProcessDocs();\n      }\n    }\n\n    function readMetadata(event) {\n      var metadata = decodeMetadata(event.target.result);\n\n      if (metadata) {\n        fetchedDocs.set(metadata.id, metadata);\n      }\n      checkDone();\n    }\n\n    for (var i = 0, len = docInfos.length; i < len; i++) {\n      var docInfo = docInfos[i];\n      if (docInfo._id && isLocalId(docInfo._id)) {\n        checkDone(); // skip local docs\n        continue;\n      }\n      var req = docStore.get(docInfo.metadata.id);\n      req.onsuccess = readMetadata;\n    }\n  }\n\n  function complete() {\n    if (preconditionErrored) {\n      return;\n    }\n\n    idbChanges.notify(api._meta.name);\n    api._meta.docCount += docCountDelta;\n    callback(null, results);\n  }\n\n  function verifyAttachment(digest, callback) {\n\n    var req = attachStore.get(digest);\n    req.onsuccess = function (e) {\n      if (!e.target.result) {\n        var err = createError(MISSING_STUB,\n          'unknown stub attachment with digest ' +\n          digest);\n        err.status = 412;\n        callback(err);\n      } else {\n        callback();\n      }\n    };\n  }\n\n  function verifyAttachments(finish) {\n\n\n    var digests = [];\n    docInfos.forEach(function (docInfo) {\n      if (docInfo.data && docInfo.data._attachments) {\n        Object.keys(docInfo.data._attachments).forEach(function (filename) {\n          var att = docInfo.data._attachments[filename];\n          if (att.stub) {\n            digests.push(att.digest);\n          }\n        });\n      }\n    });\n    if (!digests.length) {\n      return finish();\n    }\n    var numDone = 0;\n    var err;\n\n    function checkDone() {\n      if (++numDone === digests.length) {\n        finish(err);\n      }\n    }\n    digests.forEach(function (digest) {\n      verifyAttachment(digest, function (attErr) {\n        if (attErr && !err) {\n          err = attErr;\n        }\n        checkDone();\n      });\n    });\n  }\n\n  function writeDoc(docInfo, winningRev, winningRevIsDeleted, newRevIsDeleted,\n                    isUpdate, delta, resultsIdx, callback) {\n\n    docCountDelta += delta;\n\n    docInfo.metadata.winningRev = winningRev;\n    docInfo.metadata.deleted = winningRevIsDeleted;\n\n    var doc = docInfo.data;\n    doc._id = docInfo.metadata.id;\n    doc._rev = docInfo.metadata.rev;\n\n    if (newRevIsDeleted) {\n      doc._deleted = true;\n    }\n\n    var hasAttachments = doc._attachments &&\n      Object.keys(doc._attachments).length;\n    if (hasAttachments) {\n      return writeAttachments(docInfo, winningRev, winningRevIsDeleted,\n        isUpdate, resultsIdx, callback);\n    }\n\n    finishDoc(docInfo, winningRev, winningRevIsDeleted,\n      isUpdate, resultsIdx, callback);\n  }\n\n  function autoCompact(docInfo) {\n\n    var revsToDelete = compactTree(docInfo.metadata);\n    compactRevs(revsToDelete, docInfo.metadata.id, txn);\n  }\n\n  function finishDoc(docInfo, winningRev, winningRevIsDeleted,\n                     isUpdate, resultsIdx, callback) {\n\n    var doc = docInfo.data;\n    var metadata = docInfo.metadata;\n\n    doc._doc_id_rev = metadata.id + '::' + metadata.rev;\n    delete doc._id;\n    delete doc._rev;\n\n    function afterPutDoc(e) {\n      if (isUpdate && api.auto_compaction) {\n        autoCompact(docInfo);\n      } else if (docInfo.stemmedRevs.length) {\n        compactRevs(docInfo.stemmedRevs, docInfo.metadata.id, txn);\n      }\n\n      metadata.seq = e.target.result;\n      // Current _rev is calculated from _rev_tree on read\n      delete metadata.rev;\n      var metadataToStore = encodeMetadata(metadata, winningRev,\n        winningRevIsDeleted);\n      var metaDataReq = docStore.put(metadataToStore);\n      metaDataReq.onsuccess = afterPutMetadata;\n    }\n\n    function afterPutDocError(e) {\n      // ConstraintError, need to update, not put (see #1638 for details)\n      e.preventDefault(); // avoid transaction abort\n      e.stopPropagation(); // avoid transaction onerror\n      var index = bySeqStore.index('_doc_id_rev');\n      var getKeyReq = index.getKey(doc._doc_id_rev);\n      getKeyReq.onsuccess = function (e) {\n        var putReq = bySeqStore.put(doc, e.target.result);\n        putReq.onsuccess = afterPutDoc;\n      };\n    }\n\n    function afterPutMetadata() {\n      results[resultsIdx] = {\n        ok: true,\n        id: metadata.id,\n        rev: winningRev\n      };\n      fetchedDocs.set(docInfo.metadata.id, docInfo.metadata);\n      insertAttachmentMappings(docInfo, metadata.seq, callback);\n    }\n\n    var putReq = bySeqStore.put(doc);\n\n    putReq.onsuccess = afterPutDoc;\n    putReq.onerror = afterPutDocError;\n  }\n\n  function writeAttachments(docInfo, winningRev, winningRevIsDeleted,\n                            isUpdate, resultsIdx, callback) {\n\n\n    var doc = docInfo.data;\n\n    var numDone = 0;\n    var attachments = Object.keys(doc._attachments);\n\n    function collectResults() {\n      if (numDone === attachments.length) {\n        finishDoc(docInfo, winningRev, winningRevIsDeleted,\n          isUpdate, resultsIdx, callback);\n      }\n    }\n\n    function attachmentSaved() {\n      numDone++;\n      collectResults();\n    }\n\n    attachments.forEach(function (key) {\n      var att = docInfo.data._attachments[key];\n      if (!att.stub) {\n        var data = att.data;\n        delete att.data;\n        var digest = att.digest;\n        saveAttachment(digest, data, attachmentSaved);\n      } else {\n        numDone++;\n        collectResults();\n      }\n    });\n  }\n\n  // map seqs to attachment digests, which\n  // we will need later during compaction\n  function insertAttachmentMappings(docInfo, seq, callback) {\n\n    var attsAdded = 0;\n    var attsToAdd = Object.keys(docInfo.data._attachments || {});\n\n    if (!attsToAdd.length) {\n      return callback();\n    }\n\n    function checkDone() {\n      if (++attsAdded === attsToAdd.length) {\n        callback();\n      }\n    }\n\n    function add(att) {\n      var digest = docInfo.data._attachments[att].digest;\n      var req = attachAndSeqStore.put({\n        seq: seq,\n        digestSeq: digest + '::' + seq\n      });\n\n      req.onsuccess = checkDone;\n      req.onerror = function (e) {\n        // this callback is for a constaint error, which we ignore\n        // because this docid/rev has already been associated with\n        // the digest (e.g. when new_edits == false)\n        e.preventDefault(); // avoid transaction abort\n        e.stopPropagation(); // avoid transaction onerror\n        checkDone();\n      };\n    }\n    for (var i = 0; i < attsToAdd.length; i++) {\n      add(attsToAdd[i]); // do in parallel\n    }\n  }\n\n  function saveAttachment(digest, data, callback) {\n\n\n    var getKeyReq = attachStore.count(digest);\n    getKeyReq.onsuccess = function(e) {\n      var count = e.target.result;\n      if (count) {\n        return callback(); // already exists\n      }\n      var newAtt = {\n        digest: digest,\n        body: data\n      };\n      var putReq = attachStore.put(newAtt);\n      putReq.onsuccess = callback;\n    };\n  }\n}\n\nfunction createKeyRange(start, end, inclusiveEnd, key, descending) {\n  try {\n    if (start && end) {\n      if (descending) {\n        return IDBKeyRange.bound(end, start, !inclusiveEnd, false);\n      } else {\n        return IDBKeyRange.bound(start, end, false, !inclusiveEnd);\n      }\n    } else if (start) {\n      if (descending) {\n        return IDBKeyRange.upperBound(start);\n      } else {\n        return IDBKeyRange.lowerBound(start);\n      }\n    } else if (end) {\n      if (descending) {\n        return IDBKeyRange.lowerBound(end, !inclusiveEnd);\n      } else {\n        return IDBKeyRange.upperBound(end, !inclusiveEnd);\n      }\n    } else if (key) {\n      return IDBKeyRange.only(key);\n    }\n  } catch (e) {\n    return {error: e};\n  }\n  return null;\n}\n\nfunction handleKeyRangeError(api, opts, err, callback) {\n  if (err.name === \"DataError\" && err.code === 0) {\n    // data error, start is less than end\n    return callback(null, {\n      total_rows: api._meta.docCount,\n      offset: opts.skip,\n      rows: []\n    });\n  }\n  callback(createError(IDB_ERROR, err.name, err.message));\n}\n\nfunction idbAllDocs(opts, api, idb, callback) {\n\n  function allDocsQuery(opts, callback) {\n    var start = 'startkey' in opts ? opts.startkey : false;\n    var end = 'endkey' in opts ? opts.endkey : false;\n    var key = 'key' in opts ? opts.key : false;\n    var skip = opts.skip || 0;\n    var limit = typeof opts.limit === 'number' ? opts.limit : -1;\n    var inclusiveEnd = opts.inclusive_end !== false;\n    var descending = 'descending' in opts && opts.descending ? 'prev' : null;\n\n    var keyRange = createKeyRange(start, end, inclusiveEnd, key, descending);\n    if (keyRange && keyRange.error) {\n      return handleKeyRangeError(api, opts, keyRange.error, callback);\n    }\n\n    var stores = [DOC_STORE, BY_SEQ_STORE];\n\n    if (opts.attachments) {\n      stores.push(ATTACH_STORE);\n    }\n    var txnResult = openTransactionSafely(idb, stores, 'readonly');\n    if (txnResult.error) {\n      return callback(txnResult.error);\n    }\n    var txn = txnResult.txn;\n    var docStore = txn.objectStore(DOC_STORE);\n    var seqStore = txn.objectStore(BY_SEQ_STORE);\n    var cursor = descending ?\n      docStore.openCursor(keyRange, descending) :\n      docStore.openCursor(keyRange);\n    var docIdRevIndex = seqStore.index('_doc_id_rev');\n    var results = [];\n    var docCount = 0;\n\n    // if the user specifies include_docs=true, then we don't\n    // want to block the main cursor while we're fetching the doc\n    function fetchDocAsynchronously(metadata, row, winningRev) {\n      var key = metadata.id + \"::\" + winningRev;\n      docIdRevIndex.get(key).onsuccess =  function onGetDoc(e) {\n        row.doc = decodeDoc(e.target.result);\n        if (opts.conflicts) {\n          row.doc._conflicts = collectConflicts(metadata);\n        }\n        fetchAttachmentsIfNecessary(row.doc, opts, txn);\n      };\n    }\n\n    function allDocsInner(cursor, winningRev, metadata) {\n      var row = {\n        id: metadata.id,\n        key: metadata.id,\n        value: {\n          rev: winningRev\n        }\n      };\n      var deleted = metadata.deleted;\n      if (opts.deleted === 'ok') {\n        results.push(row);\n        // deleted docs are okay with \"keys\" requests\n        if (deleted) {\n          row.value.deleted = true;\n          row.doc = null;\n        } else if (opts.include_docs) {\n          fetchDocAsynchronously(metadata, row, winningRev);\n        }\n      } else if (!deleted && skip-- <= 0) {\n        results.push(row);\n        if (opts.include_docs) {\n          fetchDocAsynchronously(metadata, row, winningRev);\n        }\n        if (--limit === 0) {\n          return;\n        }\n      }\n      cursor.continue();\n    }\n\n    function onGetCursor(e) {\n      docCount = api._meta.docCount; // do this within the txn for consistency\n      var cursor = e.target.result;\n      if (!cursor) {\n        return;\n      }\n      var metadata = decodeMetadata(cursor.value);\n      var winningRev = metadata.winningRev;\n\n      allDocsInner(cursor, winningRev, metadata);\n    }\n\n    function onResultsReady() {\n      callback(null, {\n        total_rows: docCount,\n        offset: opts.skip,\n        rows: results\n      });\n    }\n\n    function onTxnComplete() {\n      if (opts.attachments) {\n        postProcessAttachments(results, opts.binary).then(onResultsReady);\n      } else {\n        onResultsReady();\n      }\n    }\n\n    txn.oncomplete = onTxnComplete;\n    cursor.onsuccess = onGetCursor;\n  }\n\n  function allDocs(opts, callback) {\n\n    if (opts.limit === 0) {\n      return callback(null, {\n        total_rows: api._meta.docCount,\n        offset: opts.skip,\n        rows: []\n      });\n    }\n    allDocsQuery(opts, callback);\n  }\n\n  allDocs(opts, callback);\n}\n\n//\n// Blobs are not supported in all versions of IndexedDB, notably\n// Chrome <37 and Android <5. In those versions, storing a blob will throw.\n//\n// Various other blob bugs exist in Chrome v37-42 (inclusive).\n// Detecting them is expensive and confusing to users, and Chrome 37-42\n// is at very low usage worldwide, so we do a hacky userAgent check instead.\n//\n// content-type bug: https://code.google.com/p/chromium/issues/detail?id=408120\n// 404 bug: https://code.google.com/p/chromium/issues/detail?id=447916\n// FileReader bug: https://code.google.com/p/chromium/issues/detail?id=447836\n//\nfunction checkBlobSupport(txn) {\n  return new PouchPromise(function (resolve) {\n    var blob = createBlob(['']);\n    txn.objectStore(DETECT_BLOB_SUPPORT_STORE).put(blob, 'key');\n\n    txn.onabort = function (e) {\n      // If the transaction aborts now its due to not being able to\n      // write to the database, likely due to the disk being full\n      e.preventDefault();\n      e.stopPropagation();\n      resolve(false);\n    };\n\n    txn.oncomplete = function () {\n      var matchedChrome = navigator.userAgent.match(/Chrome\\/(\\d+)/);\n      var matchedEdge = navigator.userAgent.match(/Edge\\//);\n      // MS Edge pretends to be Chrome 42:\n      // https://msdn.microsoft.com/en-us/library/hh869301%28v=vs.85%29.aspx\n      resolve(matchedEdge || !matchedChrome ||\n        parseInt(matchedChrome[1], 10) >= 43);\n    };\n  }).catch(function () {\n    return false; // error, so assume unsupported\n  });\n}\n\ninherits(Changes$1, events.EventEmitter);\n\n/* istanbul ignore next */\nfunction attachBrowserEvents(self) {\n  if (isChromeApp()) {\n    chrome.storage.onChanged.addListener(function (e) {\n      // make sure it's event addressed to us\n      if (e.db_name != null) {\n        //object only has oldValue, newValue members\n        self.emit(e.dbName.newValue);\n      }\n    });\n  } else if (hasLocalStorage()) {\n    if (typeof addEventListener !== 'undefined') {\n      addEventListener(\"storage\", function (e) {\n        self.emit(e.key);\n      });\n    } else { // old IE\n      window.attachEvent(\"storage\", function (e) {\n        self.emit(e.key);\n      });\n    }\n  }\n}\n\nfunction Changes$1() {\n  events.EventEmitter.call(this);\n  this._listeners = {};\n\n  attachBrowserEvents(this);\n}\nChanges$1.prototype.addListener = function (dbName, id, db, opts) {\n  /* istanbul ignore if */\n  if (this._listeners[id]) {\n    return;\n  }\n  var self = this;\n  var inprogress = false;\n  function eventFunction() {\n    /* istanbul ignore if */\n    if (!self._listeners[id]) {\n      return;\n    }\n    if (inprogress) {\n      inprogress = 'waiting';\n      return;\n    }\n    inprogress = true;\n    var changesOpts = pick(opts, [\n      'style', 'include_docs', 'attachments', 'conflicts', 'filter',\n      'doc_ids', 'view', 'since', 'query_params', 'binary'\n    ]);\n\n    /* istanbul ignore next */\n    function onError() {\n      inprogress = false;\n    }\n\n    db.changes(changesOpts).on('change', function (c) {\n      if (c.seq > opts.since && !opts.cancelled) {\n        opts.since = c.seq;\n        opts.onChange(c);\n      }\n    }).on('complete', function () {\n      if (inprogress === 'waiting') {\n        setTimeout(function(){\n          eventFunction();\n        },0);\n      }\n      inprogress = false;\n    }).on('error', onError);\n  }\n  this._listeners[id] = eventFunction;\n  this.on(dbName, eventFunction);\n};\n\nChanges$1.prototype.removeListener = function (dbName, id) {\n  /* istanbul ignore if */\n  if (!(id in this._listeners)) {\n    return;\n  }\n  events.EventEmitter.prototype.removeListener.call(this, dbName,\n    this._listeners[id]);\n};\n\n\n/* istanbul ignore next */\nChanges$1.prototype.notifyLocalWindows = function (dbName) {\n  //do a useless change on a storage thing\n  //in order to get other windows's listeners to activate\n  if (isChromeApp()) {\n    chrome.storage.local.set({dbName: dbName});\n  } else if (hasLocalStorage()) {\n    localStorage[dbName] = (localStorage[dbName] === \"a\") ? \"b\" : \"a\";\n  }\n};\n\nChanges$1.prototype.notify = function (dbName) {\n  this.emit(dbName);\n  this.notifyLocalWindows(dbName);\n};\n\nvar cachedDBs = new pouchdbCollections.Map();\nvar blobSupportPromise;\nvar idbChanges = new Changes$1();\nvar openReqList = new pouchdbCollections.Map();\n\nfunction IdbPouch(opts, callback) {\n  var api = this;\n\n  taskQueue.queue.push({\n    action: function (thisCallback) {\n      init(api, opts, thisCallback);\n    },\n    callback: callback\n  });\n  applyNext(api.constructor);\n}\n\nfunction init(api, opts, callback) {\n\n  var dbName = opts.name;\n\n  var idb = null;\n  api._meta = null;\n\n  // called when creating a fresh new database\n  function createSchema(db) {\n    var docStore = db.createObjectStore(DOC_STORE, {keyPath : 'id'});\n    db.createObjectStore(BY_SEQ_STORE, {autoIncrement: true})\n      .createIndex('_doc_id_rev', '_doc_id_rev', {unique: true});\n    db.createObjectStore(ATTACH_STORE, {keyPath: 'digest'});\n    db.createObjectStore(META_STORE, {keyPath: 'id', autoIncrement: false});\n    db.createObjectStore(DETECT_BLOB_SUPPORT_STORE);\n\n    // added in v2\n    docStore.createIndex('deletedOrLocal', 'deletedOrLocal', {unique : false});\n\n    // added in v3\n    db.createObjectStore(LOCAL_STORE, {keyPath: '_id'});\n\n    // added in v4\n    var attAndSeqStore = db.createObjectStore(ATTACH_AND_SEQ_STORE,\n      {autoIncrement: true});\n    attAndSeqStore.createIndex('seq', 'seq');\n    attAndSeqStore.createIndex('digestSeq', 'digestSeq', {unique: true});\n  }\n\n  // migration to version 2\n  // unfortunately \"deletedOrLocal\" is a misnomer now that we no longer\n  // store local docs in the main doc-store, but whaddyagonnado\n  function addDeletedOrLocalIndex(txn, callback) {\n    var docStore = txn.objectStore(DOC_STORE);\n    docStore.createIndex('deletedOrLocal', 'deletedOrLocal', {unique : false});\n\n    docStore.openCursor().onsuccess = function (event) {\n      var cursor = event.target.result;\n      if (cursor) {\n        var metadata = cursor.value;\n        var deleted = isDeleted(metadata);\n        metadata.deletedOrLocal = deleted ? \"1\" : \"0\";\n        docStore.put(metadata);\n        cursor.continue();\n      } else {\n        callback();\n      }\n    };\n  }\n\n  // migration to version 3 (part 1)\n  function createLocalStoreSchema(db) {\n    db.createObjectStore(LOCAL_STORE, {keyPath: '_id'})\n      .createIndex('_doc_id_rev', '_doc_id_rev', {unique: true});\n  }\n\n  // migration to version 3 (part 2)\n  function migrateLocalStore(txn, cb) {\n    var localStore = txn.objectStore(LOCAL_STORE);\n    var docStore = txn.objectStore(DOC_STORE);\n    var seqStore = txn.objectStore(BY_SEQ_STORE);\n\n    var cursor = docStore.openCursor();\n    cursor.onsuccess = function (event) {\n      var cursor = event.target.result;\n      if (cursor) {\n        var metadata = cursor.value;\n        var docId = metadata.id;\n        var local = isLocalId(docId);\n        var rev = winningRev(metadata);\n        if (local) {\n          var docIdRev = docId + \"::\" + rev;\n          // remove all seq entries\n          // associated with this docId\n          var start = docId + \"::\";\n          var end = docId + \"::~\";\n          var index = seqStore.index('_doc_id_rev');\n          var range = IDBKeyRange.bound(start, end, false, false);\n          var seqCursor = index.openCursor(range);\n          seqCursor.onsuccess = function (e) {\n            seqCursor = e.target.result;\n            if (!seqCursor) {\n              // done\n              docStore.delete(cursor.primaryKey);\n              cursor.continue();\n            } else {\n              var data = seqCursor.value;\n              if (data._doc_id_rev === docIdRev) {\n                localStore.put(data);\n              }\n              seqStore.delete(seqCursor.primaryKey);\n              seqCursor.continue();\n            }\n          };\n        } else {\n          cursor.continue();\n        }\n      } else if (cb) {\n        cb();\n      }\n    };\n  }\n\n  // migration to version 4 (part 1)\n  function addAttachAndSeqStore(db) {\n    var attAndSeqStore = db.createObjectStore(ATTACH_AND_SEQ_STORE,\n      {autoIncrement: true});\n    attAndSeqStore.createIndex('seq', 'seq');\n    attAndSeqStore.createIndex('digestSeq', 'digestSeq', {unique: true});\n  }\n\n  // migration to version 4 (part 2)\n  function migrateAttsAndSeqs(txn, callback) {\n    var seqStore = txn.objectStore(BY_SEQ_STORE);\n    var attStore = txn.objectStore(ATTACH_STORE);\n    var attAndSeqStore = txn.objectStore(ATTACH_AND_SEQ_STORE);\n\n    // need to actually populate the table. this is the expensive part,\n    // so as an optimization, check first that this database even\n    // contains attachments\n    var req = attStore.count();\n    req.onsuccess = function (e) {\n      var count = e.target.result;\n      if (!count) {\n        return callback(); // done\n      }\n\n      seqStore.openCursor().onsuccess = function (e) {\n        var cursor = e.target.result;\n        if (!cursor) {\n          return callback(); // done\n        }\n        var doc = cursor.value;\n        var seq = cursor.primaryKey;\n        var atts = Object.keys(doc._attachments || {});\n        var digestMap = {};\n        for (var j = 0; j < atts.length; j++) {\n          var att = doc._attachments[atts[j]];\n          digestMap[att.digest] = true; // uniq digests, just in case\n        }\n        var digests = Object.keys(digestMap);\n        for (j = 0; j < digests.length; j++) {\n          var digest = digests[j];\n          attAndSeqStore.put({\n            seq: seq,\n            digestSeq: digest + '::' + seq\n          });\n        }\n        cursor.continue();\n      };\n    };\n  }\n\n  // migration to version 5\n  // Instead of relying on on-the-fly migration of metadata,\n  // this brings the doc-store to its modern form:\n  // - metadata.winningrev\n  // - metadata.seq\n  // - stringify the metadata when storing it\n  function migrateMetadata(txn) {\n\n    function decodeMetadataCompat(storedObject) {\n      if (!storedObject.data) {\n        // old format, when we didn't store it stringified\n        storedObject.deleted = storedObject.deletedOrLocal === '1';\n        return storedObject;\n      }\n      return decodeMetadata(storedObject);\n    }\n\n    // ensure that every metadata has a winningRev and seq,\n    // which was previously created on-the-fly but better to migrate\n    var bySeqStore = txn.objectStore(BY_SEQ_STORE);\n    var docStore = txn.objectStore(DOC_STORE);\n    var cursor = docStore.openCursor();\n    cursor.onsuccess = function (e) {\n      var cursor = e.target.result;\n      if (!cursor) {\n        return; // done\n      }\n      var metadata = decodeMetadataCompat(cursor.value);\n\n      metadata.winningRev = metadata.winningRev ||\n        winningRev(metadata);\n\n      function fetchMetadataSeq() {\n        // metadata.seq was added post-3.2.0, so if it's missing,\n        // we need to fetch it manually\n        var start = metadata.id + '::';\n        var end = metadata.id + '::\\uffff';\n        var req = bySeqStore.index('_doc_id_rev').openCursor(\n          IDBKeyRange.bound(start, end));\n\n        var metadataSeq = 0;\n        req.onsuccess = function (e) {\n          var cursor = e.target.result;\n          if (!cursor) {\n            metadata.seq = metadataSeq;\n            return onGetMetadataSeq();\n          }\n          var seq = cursor.primaryKey;\n          if (seq > metadataSeq) {\n            metadataSeq = seq;\n          }\n          cursor.continue();\n        };\n      }\n\n      function onGetMetadataSeq() {\n        var metadataToStore = encodeMetadata(metadata,\n          metadata.winningRev, metadata.deleted);\n\n        var req = docStore.put(metadataToStore);\n        req.onsuccess = function () {\n          cursor.continue();\n        };\n      }\n\n      if (metadata.seq) {\n        return onGetMetadataSeq();\n      }\n\n      fetchMetadataSeq();\n    };\n\n  }\n\n  api.type = function () {\n    return 'idb';\n  };\n\n  api._id = toPromise(function (callback) {\n    callback(null, api._meta.instanceId);\n  });\n\n  api._bulkDocs = function idb_bulkDocs(req, reqOpts, callback) {\n    idbBulkDocs(opts, req, reqOpts, api, idb, idbChanges, callback);\n  };\n\n  // First we look up the metadata in the ids database, then we fetch the\n  // current revision(s) from the by sequence store\n  api._get = function idb_get(id, opts, callback) {\n    var doc;\n    var metadata;\n    var err;\n    var txn = opts.ctx;\n    if (!txn) {\n      var txnResult = openTransactionSafely(idb,\n        [DOC_STORE, BY_SEQ_STORE, ATTACH_STORE], 'readonly');\n      if (txnResult.error) {\n        return callback(txnResult.error);\n      }\n      txn = txnResult.txn;\n    }\n\n    function finish() {\n      callback(err, {doc: doc, metadata: metadata, ctx: txn});\n    }\n\n    txn.objectStore(DOC_STORE).get(id).onsuccess = function (e) {\n      metadata = decodeMetadata(e.target.result);\n      // we can determine the result here if:\n      // 1. there is no such document\n      // 2. the document is deleted and we don't ask about specific rev\n      // When we ask with opts.rev we expect the answer to be either\n      // doc (possibly with _deleted=true) or missing error\n      if (!metadata) {\n        err = createError(MISSING_DOC, 'missing');\n        return finish();\n      }\n      if (isDeleted(metadata) && !opts.rev) {\n        err = createError(MISSING_DOC, \"deleted\");\n        return finish();\n      }\n      var objectStore = txn.objectStore(BY_SEQ_STORE);\n\n      var rev = opts.rev || metadata.winningRev;\n      var key = metadata.id + '::' + rev;\n\n      objectStore.index('_doc_id_rev').get(key).onsuccess = function (e) {\n        doc = e.target.result;\n        if (doc) {\n          doc = decodeDoc(doc);\n        }\n        if (!doc) {\n          err = createError(MISSING_DOC, 'missing');\n          return finish();\n        }\n        finish();\n      };\n    };\n  };\n\n  api._getAttachment = function (attachment, opts, callback) {\n    var txn;\n    if (opts.ctx) {\n      txn = opts.ctx;\n    } else {\n      var txnResult = openTransactionSafely(idb,\n        [DOC_STORE, BY_SEQ_STORE, ATTACH_STORE], 'readonly');\n      if (txnResult.error) {\n        return callback(txnResult.error);\n      }\n      txn = txnResult.txn;\n    }\n    var digest = attachment.digest;\n    var type = attachment.content_type;\n\n    txn.objectStore(ATTACH_STORE).get(digest).onsuccess = function (e) {\n      var body = e.target.result.body;\n      readBlobData(body, type, opts.binary, function (blobData) {\n        callback(null, blobData);\n      });\n    };\n  };\n\n  api._info = function idb_info(callback) {\n\n    if (idb === null || !cachedDBs.has(dbName)) {\n      var error = new Error('db isn\\'t open');\n      error.id = 'idbNull';\n      return callback(error);\n    }\n    var updateSeq;\n    var docCount;\n\n    var txnResult = openTransactionSafely(idb, [BY_SEQ_STORE], 'readonly');\n    if (txnResult.error) {\n      return callback(txnResult.error);\n    }\n    var txn = txnResult.txn;\n    var cursor = txn.objectStore(BY_SEQ_STORE).openCursor(null, 'prev');\n    cursor.onsuccess = function (event) {\n      var cursor = event.target.result;\n      updateSeq = cursor ? cursor.key : 0;\n      // count within the same txn for consistency\n      docCount = api._meta.docCount;\n    };\n\n    txn.oncomplete = function () {\n      callback(null, {\n        doc_count: docCount,\n        update_seq: updateSeq,\n        // for debugging\n        idb_attachment_format: (api._meta.blobSupport ? 'binary' : 'base64')\n      });\n    };\n  };\n\n  api._allDocs = function idb_allDocs(opts, callback) {\n    idbAllDocs(opts, api, idb, callback);\n  };\n\n  api._changes = function (opts) {\n    opts = clone(opts);\n\n    if (opts.continuous) {\n      var id = dbName + ':' + uuid();\n      idbChanges.addListener(dbName, id, api, opts);\n      idbChanges.notify(dbName);\n      return {\n        cancel: function () {\n          idbChanges.removeListener(dbName, id);\n        }\n      };\n    }\n\n    var docIds = opts.doc_ids && new pouchdbCollections.Set(opts.doc_ids);\n\n    opts.since = opts.since || 0;\n    var lastSeq = opts.since;\n\n    var limit = 'limit' in opts ? opts.limit : -1;\n    if (limit === 0) {\n      limit = 1; // per CouchDB _changes spec\n    }\n    var returnDocs;\n    if ('return_docs' in opts) {\n      returnDocs = opts.return_docs;\n    } else if ('returnDocs' in opts) {\n      // TODO: Remove 'returnDocs' in favor of 'return_docs' in a future release\n      returnDocs = opts.returnDocs;\n    } else {\n      returnDocs = true;\n    }\n\n    var results = [];\n    var numResults = 0;\n    var filter = filterChange(opts);\n    var docIdsToMetadata = new pouchdbCollections.Map();\n\n    var txn;\n    var bySeqStore;\n    var docStore;\n    var docIdRevIndex;\n\n    function onGetCursor(cursor) {\n\n      var doc = decodeDoc(cursor.value);\n      var seq = cursor.key;\n\n      if (docIds && !docIds.has(doc._id)) {\n        return cursor.continue();\n      }\n\n      var metadata;\n\n      function onGetMetadata() {\n        if (metadata.seq !== seq) {\n          // some other seq is later\n          return cursor.continue();\n        }\n\n        lastSeq = seq;\n\n        if (metadata.winningRev === doc._rev) {\n          return onGetWinningDoc(doc);\n        }\n\n        fetchWinningDoc();\n      }\n\n      function fetchWinningDoc() {\n        var docIdRev = doc._id + '::' + metadata.winningRev;\n        var req = docIdRevIndex.get(docIdRev);\n        req.onsuccess = function (e) {\n          onGetWinningDoc(decodeDoc(e.target.result));\n        };\n      }\n\n      function onGetWinningDoc(winningDoc) {\n\n        var change = opts.processChange(winningDoc, metadata, opts);\n        change.seq = metadata.seq;\n\n        var filtered = filter(change);\n        if (typeof filtered === 'object') {\n          return opts.complete(filtered);\n        }\n\n        if (filtered) {\n          numResults++;\n          if (returnDocs) {\n            results.push(change);\n          }\n          // process the attachment immediately\n          // for the benefit of live listeners\n          if (opts.attachments && opts.include_docs) {\n            fetchAttachmentsIfNecessary(winningDoc, opts, txn, function () {\n              postProcessAttachments([change], opts.binary).then(function () {\n                opts.onChange(change);\n              });\n            });\n          } else {\n            opts.onChange(change);\n          }\n        }\n        if (numResults !== limit) {\n          cursor.continue();\n        }\n      }\n\n      metadata = docIdsToMetadata.get(doc._id);\n      if (metadata) { // cached\n        return onGetMetadata();\n      }\n      // metadata not cached, have to go fetch it\n      docStore.get(doc._id).onsuccess = function (event) {\n        metadata = decodeMetadata(event.target.result);\n        docIdsToMetadata.set(doc._id, metadata);\n        onGetMetadata();\n      };\n    }\n\n    function onsuccess(event) {\n      var cursor = event.target.result;\n\n      if (!cursor) {\n        return;\n      }\n      onGetCursor(cursor);\n    }\n\n    function fetchChanges() {\n      var objectStores = [DOC_STORE, BY_SEQ_STORE];\n      if (opts.attachments) {\n        objectStores.push(ATTACH_STORE);\n      }\n      var txnResult = openTransactionSafely(idb, objectStores, 'readonly');\n      if (txnResult.error) {\n        return opts.complete(txnResult.error);\n      }\n      txn = txnResult.txn;\n      txn.onabort = idbError(opts.complete);\n      txn.oncomplete = onTxnComplete;\n\n      bySeqStore = txn.objectStore(BY_SEQ_STORE);\n      docStore = txn.objectStore(DOC_STORE);\n      docIdRevIndex = bySeqStore.index('_doc_id_rev');\n\n      var req;\n\n      if (opts.descending) {\n        req = bySeqStore.openCursor(null, 'prev');\n      } else {\n        req = bySeqStore.openCursor(IDBKeyRange.lowerBound(opts.since, true));\n      }\n\n      req.onsuccess = onsuccess;\n    }\n\n    fetchChanges();\n\n    function onTxnComplete() {\n\n      function finish() {\n        opts.complete(null, {\n          results: results,\n          last_seq: lastSeq\n        });\n      }\n\n      if (!opts.continuous && opts.attachments) {\n        // cannot guarantee that postProcessing was already done,\n        // so do it again\n        postProcessAttachments(results).then(finish);\n      } else {\n        finish();\n      }\n    }\n  };\n\n  api._close = function (callback) {\n    if (idb === null) {\n      return callback(createError(NOT_OPEN));\n    }\n\n    // https://developer.mozilla.org/en-US/docs/IndexedDB/IDBDatabase#close\n    // \"Returns immediately and closes the connection in a separate thread...\"\n    idb.close();\n    cachedDBs.delete(dbName);\n    idb = null;\n    callback();\n  };\n\n  api._getRevisionTree = function (docId, callback) {\n    var txnResult = openTransactionSafely(idb, [DOC_STORE], 'readonly');\n    if (txnResult.error) {\n      return callback(txnResult.error);\n    }\n    var txn = txnResult.txn;\n    var req = txn.objectStore(DOC_STORE).get(docId);\n    req.onsuccess = function (event) {\n      var doc = decodeMetadata(event.target.result);\n      if (!doc) {\n        callback(createError(MISSING_DOC));\n      } else {\n        callback(null, doc.rev_tree);\n      }\n    };\n  };\n\n  // This function removes revisions of document docId\n  // which are listed in revs and sets this document\n  // revision to to rev_tree\n  api._doCompaction = function (docId, revs, callback) {\n    var stores = [\n      DOC_STORE,\n      BY_SEQ_STORE,\n      ATTACH_STORE,\n      ATTACH_AND_SEQ_STORE\n    ];\n    var txnResult = openTransactionSafely(idb, stores, 'readwrite');\n    if (txnResult.error) {\n      return callback(txnResult.error);\n    }\n    var txn = txnResult.txn;\n\n    var docStore = txn.objectStore(DOC_STORE);\n\n    docStore.get(docId).onsuccess = function (event) {\n      var metadata = decodeMetadata(event.target.result);\n      traverseRevTree(metadata.rev_tree, function (isLeaf, pos,\n                                                         revHash, ctx, opts) {\n        var rev = pos + '-' + revHash;\n        if (revs.indexOf(rev) !== -1) {\n          opts.status = 'missing';\n        }\n      });\n      compactRevs(revs, docId, txn);\n      var winningRev = metadata.winningRev;\n      var deleted = metadata.deleted;\n      txn.objectStore(DOC_STORE).put(\n        encodeMetadata(metadata, winningRev, deleted));\n    };\n    txn.onabort = idbError(callback);\n    txn.oncomplete = function () {\n      callback();\n    };\n  };\n\n\n  api._getLocal = function (id, callback) {\n    var txnResult = openTransactionSafely(idb, [LOCAL_STORE], 'readonly');\n    if (txnResult.error) {\n      return callback(txnResult.error);\n    }\n    var tx = txnResult.txn;\n    var req = tx.objectStore(LOCAL_STORE).get(id);\n\n    req.onerror = idbError(callback);\n    req.onsuccess = function (e) {\n      var doc = e.target.result;\n      if (!doc) {\n        callback(createError(MISSING_DOC));\n      } else {\n        delete doc['_doc_id_rev']; // for backwards compat\n        callback(null, doc);\n      }\n    };\n  };\n\n  api._putLocal = function (doc, opts, callback) {\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n    delete doc._revisions; // ignore this, trust the rev\n    var oldRev = doc._rev;\n    var id = doc._id;\n    if (!oldRev) {\n      doc._rev = '0-1';\n    } else {\n      doc._rev = '0-' + (parseInt(oldRev.split('-')[1], 10) + 1);\n    }\n\n    var tx = opts.ctx;\n    var ret;\n    if (!tx) {\n      var txnResult = openTransactionSafely(idb, [LOCAL_STORE], 'readwrite');\n      if (txnResult.error) {\n        return callback(txnResult.error);\n      }\n      tx = txnResult.txn;\n      tx.onerror = idbError(callback);\n      tx.oncomplete = function () {\n        if (ret) {\n          callback(null, ret);\n        }\n      };\n    }\n\n    var oStore = tx.objectStore(LOCAL_STORE);\n    var req;\n    if (oldRev) {\n      req = oStore.get(id);\n      req.onsuccess = function (e) {\n        var oldDoc = e.target.result;\n        if (!oldDoc || oldDoc._rev !== oldRev) {\n          callback(createError(REV_CONFLICT));\n        } else { // update\n          var req = oStore.put(doc);\n          req.onsuccess = function () {\n            ret = {ok: true, id: doc._id, rev: doc._rev};\n            if (opts.ctx) { // return immediately\n              callback(null, ret);\n            }\n          };\n        }\n      };\n    } else { // new doc\n      req = oStore.add(doc);\n      req.onerror = function (e) {\n        // constraint error, already exists\n        callback(createError(REV_CONFLICT));\n        e.preventDefault(); // avoid transaction abort\n        e.stopPropagation(); // avoid transaction onerror\n      };\n      req.onsuccess = function () {\n        ret = {ok: true, id: doc._id, rev: doc._rev};\n        if (opts.ctx) { // return immediately\n          callback(null, ret);\n        }\n      };\n    }\n  };\n\n  api._removeLocal = function (doc, opts, callback) {\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n    var tx = opts.ctx;\n    if (!tx) {\n      var txnResult = openTransactionSafely(idb, [LOCAL_STORE], 'readwrite');\n      if (txnResult.error) {\n        return callback(txnResult.error);\n      }\n      tx = txnResult.txn;\n      tx.oncomplete = function () {\n        if (ret) {\n          callback(null, ret);\n        }\n      };\n    }\n    var ret;\n    var id = doc._id;\n    var oStore = tx.objectStore(LOCAL_STORE);\n    var req = oStore.get(id);\n\n    req.onerror = idbError(callback);\n    req.onsuccess = function (e) {\n      var oldDoc = e.target.result;\n      if (!oldDoc || oldDoc._rev !== doc._rev) {\n        callback(createError(MISSING_DOC));\n      } else {\n        oStore.delete(id);\n        ret = {ok: true, id: id, rev: '0-0'};\n        if (opts.ctx) { // return immediately\n          callback(null, ret);\n        }\n      }\n    };\n  };\n\n  api._destroy = function (opts, callback) {\n    idbChanges.removeAllListeners(dbName);\n\n    //Close open request for \"dbName\" database to fix ie delay.\n    var openReq = openReqList.get(dbName);\n    if (openReq && openReq.result) {\n      openReq.result.close();\n      cachedDBs.delete(dbName);\n    }\n    var req = indexedDB.deleteDatabase(dbName);\n\n    req.onsuccess = function () {\n      //Remove open request from the list.\n      openReqList.delete(dbName);\n      if (hasLocalStorage() && (dbName in localStorage)) {\n        delete localStorage[dbName];\n      }\n      callback(null, { 'ok': true });\n    };\n\n    req.onerror = idbError(callback);\n  };\n\n  var cached = cachedDBs.get(dbName);\n\n  if (cached) {\n    idb = cached.idb;\n    api._meta = cached.global;\n    process.nextTick(function () {\n      callback(null, api);\n    });\n    return;\n  }\n\n  var req;\n  if (opts.storage) {\n    req = tryStorageOption(dbName, opts.storage);\n  } else {\n    req = indexedDB.open(dbName, ADAPTER_VERSION);\n  }\n\n  openReqList.set(dbName, req);\n\n  req.onupgradeneeded = function (e) {\n    var db = e.target.result;\n    if (e.oldVersion < 1) {\n      return createSchema(db); // new db, initial schema\n    }\n    // do migrations\n\n    var txn = e.currentTarget.transaction;\n    // these migrations have to be done in this function, before\n    // control is returned to the event loop, because IndexedDB\n\n    if (e.oldVersion < 3) {\n      createLocalStoreSchema(db); // v2 -> v3\n    }\n    if (e.oldVersion < 4) {\n      addAttachAndSeqStore(db); // v3 -> v4\n    }\n\n    var migrations = [\n      addDeletedOrLocalIndex, // v1 -> v2\n      migrateLocalStore,      // v2 -> v3\n      migrateAttsAndSeqs,     // v3 -> v4\n      migrateMetadata         // v4 -> v5\n    ];\n\n    var i = e.oldVersion;\n\n    function next() {\n      var migration = migrations[i - 1];\n      i++;\n      if (migration) {\n        migration(txn, next);\n      }\n    }\n\n    next();\n  };\n\n  req.onsuccess = function (e) {\n\n    idb = e.target.result;\n\n    idb.onversionchange = function () {\n      idb.close();\n      cachedDBs.delete(dbName);\n    };\n\n    idb.onabort = function (e) {\n      console.error('Database has a global failure', e.target.error);\n      idb.close();\n      cachedDBs.delete(dbName);\n    };\n\n    var txn = idb.transaction([\n      META_STORE,\n      DETECT_BLOB_SUPPORT_STORE,\n      DOC_STORE\n    ], 'readwrite');\n\n    var req = txn.objectStore(META_STORE).get(META_STORE);\n\n    var blobSupport = null;\n    var docCount = null;\n    var instanceId = null;\n\n    req.onsuccess = function (e) {\n\n      var checkSetupComplete = function () {\n        if (blobSupport === null || docCount === null ||\n            instanceId === null) {\n          return;\n        } else {\n          api._meta = {\n            name: dbName,\n            instanceId: instanceId,\n            blobSupport: blobSupport,\n            docCount: docCount\n          };\n\n          cachedDBs.set(dbName, {\n            idb: idb,\n            global: api._meta\n          });\n          callback(null, api);\n        }\n      };\n\n      //\n      // fetch/store the id\n      //\n\n      var meta = e.target.result || {id: META_STORE};\n      if (dbName  + '_id' in meta) {\n        instanceId = meta[dbName + '_id'];\n        checkSetupComplete();\n      } else {\n        instanceId = uuid();\n        meta[dbName + '_id'] = instanceId;\n        txn.objectStore(META_STORE).put(meta).onsuccess = function () {\n          checkSetupComplete();\n        };\n      }\n\n      //\n      // check blob support\n      //\n\n      if (!blobSupportPromise) {\n        // make sure blob support is only checked once\n        blobSupportPromise = checkBlobSupport(txn);\n      }\n\n      blobSupportPromise.then(function (val) {\n        blobSupport = val;\n        checkSetupComplete();\n      });\n\n      //\n      // count docs\n      //\n\n      var index = txn.objectStore(DOC_STORE).index('deletedOrLocal');\n      index.count(IDBKeyRange.only('0')).onsuccess = function (e) {\n        docCount = e.target.result;\n        checkSetupComplete();\n      };\n\n    };\n  };\n\n  req.onerror = function() {\n    var msg = 'Failed to open indexedDB, are you in private browsing mode?';\n    console.error(msg);\n    callback(createError(IDB_ERROR, msg));\n  };\n}\n\nIdbPouch.valid = function () {\n  // Issue #2533, we finally gave up on doing bug\n  // detection instead of browser sniffing. Safari brought us\n  // to our knees.\n  var isSafari = typeof openDatabase !== 'undefined' &&\n    /(Safari|iPhone|iPad|iPod)/.test(navigator.userAgent) &&\n    !/Chrome/.test(navigator.userAgent) &&\n    !/BlackBerry/.test(navigator.platform);\n\n  // some outdated implementations of IDB that appear on Samsung\n  // and HTC Android devices <4.4 are missing IDBKeyRange\n  return !isSafari && typeof indexedDB !== 'undefined' &&\n    typeof IDBKeyRange !== 'undefined';\n};\n\nfunction tryStorageOption(dbName, storage) {\n  try { // option only available in Firefox 26+\n    return indexedDB.open(dbName, {\n      version: ADAPTER_VERSION,\n      storage: storage\n    });\n  } catch(err) {\n      return indexedDB.open(dbName, ADAPTER_VERSION);\n  }\n}\n\n//\n// Parsing hex strings. Yeah.\n//\n// So basically we need this because of a bug in WebSQL:\n// https://code.google.com/p/chromium/issues/detail?id=422690\n// https://bugs.webkit.org/show_bug.cgi?id=137637\n//\n// UTF-8 and UTF-16 are provided as separate functions\n// for meager performance improvements\n//\n\nfunction decodeUtf8(str) {\n  return decodeURIComponent(window.escape(str));\n}\n\nfunction hexToInt(charCode) {\n  // '0'-'9' is 48-57\n  // 'A'-'F' is 65-70\n  // SQLite will only give us uppercase hex\n  return charCode < 65 ? (charCode - 48) : (charCode - 55);\n}\n\n\n// Example:\n// pragma encoding=utf8;\n// select hex('A');\n// returns '41'\nfunction parseHexUtf8(str, start, end) {\n  var result = '';\n  while (start < end) {\n    result += String.fromCharCode(\n      (hexToInt(str.charCodeAt(start++)) << 4) |\n        hexToInt(str.charCodeAt(start++)));\n  }\n  return result;\n}\n\n// Example:\n// pragma encoding=utf16;\n// select hex('A');\n// returns '4100'\n// notice that the 00 comes after the 41 (i.e. it's swizzled)\nfunction parseHexUtf16(str, start, end) {\n  var result = '';\n  while (start < end) {\n    // UTF-16, so swizzle the bytes\n    result += String.fromCharCode(\n      (hexToInt(str.charCodeAt(start + 2)) << 12) |\n        (hexToInt(str.charCodeAt(start + 3)) << 8) |\n        (hexToInt(str.charCodeAt(start)) << 4) |\n        hexToInt(str.charCodeAt(start + 1)));\n    start += 4;\n  }\n  return result;\n}\n\nfunction parseHexString(str, encoding) {\n  if (encoding === 'UTF-8') {\n    return decodeUtf8(parseHexUtf8(str, 0, str.length));\n  } else {\n    return parseHexUtf16(str, 0, str.length);\n  }\n}\n\nfunction quote(str) {\n  return \"'\" + str + \"'\";\n}\n\nvar ADAPTER_VERSION$1 = 7; // used to manage migrations\n\n// The object stores created for each database\n// DOC_STORE stores the document meta data, its revision history and state\nvar DOC_STORE$1 = quote('document-store');\n// BY_SEQ_STORE stores a particular version of a document, keyed by its\n// sequence id\nvar BY_SEQ_STORE$1 = quote('by-sequence');\n// Where we store attachments\nvar ATTACH_STORE$1 = quote('attach-store');\nvar LOCAL_STORE$1 = quote('local-store');\nvar META_STORE$1 = quote('metadata-store');\n// where we store many-to-many relations between attachment\n// digests and seqs\nvar ATTACH_AND_SEQ_STORE$1 = quote('attach-seq-store');\n\nfunction createOpenDBFunction() {\n  if (typeof sqlitePlugin !== 'undefined') {\n    // The SQLite Plugin started deviating pretty heavily from the\n    // standard openDatabase() function, as they started adding more features.\n    // It's better to just use their \"new\" format and pass in a big ol'\n    // options object.\n    return sqlitePlugin.openDatabase.bind(sqlitePlugin);\n  }\n\n  if (typeof openDatabase !== 'undefined') {\n    return function openDB(opts) {\n      // Traditional WebSQL API\n      return openDatabase(opts.name, opts.version, opts.description, opts.size);\n    };\n  }\n}\n\nfunction valid() {\n  // SQLitePlugin leaks this global object, which we can use\n  // to detect if it's installed or not. The benefit is that it's\n  // declared immediately, before the 'deviceready' event has fired.\n  return typeof openDatabase !== 'undefined' ||\n    typeof SQLitePlugin !== 'undefined';\n}\n\n// escapeBlob and unescapeBlob are workarounds for a websql bug:\n// https://code.google.com/p/chromium/issues/detail?id=422690\n// https://bugs.webkit.org/show_bug.cgi?id=137637\n// The goal is to never actually insert the \\u0000 character\n// in the database.\nfunction escapeBlob(str) {\n  return str\n    .replace(/\\u0002/g, '\\u0002\\u0002')\n    .replace(/\\u0001/g, '\\u0001\\u0002')\n    .replace(/\\u0000/g, '\\u0001\\u0001');\n}\n\nfunction unescapeBlob(str) {\n  return str\n    .replace(/\\u0001\\u0001/g, '\\u0000')\n    .replace(/\\u0001\\u0002/g, '\\u0001')\n    .replace(/\\u0002\\u0002/g, '\\u0002');\n}\n\nfunction stringifyDoc(doc) {\n  // don't bother storing the id/rev. it uses lots of space,\n  // in persistent map/reduce especially\n  delete doc._id;\n  delete doc._rev;\n  return JSON.stringify(doc);\n}\n\nfunction unstringifyDoc(doc, id, rev) {\n  doc = JSON.parse(doc);\n  doc._id = id;\n  doc._rev = rev;\n  return doc;\n}\n\n// question mark groups IN queries, e.g. 3 -> '(?,?,?)'\nfunction qMarks(num) {\n  var s = '(';\n  while (num--) {\n    s += '?';\n    if (num) {\n      s += ',';\n    }\n  }\n  return s + ')';\n}\n\nfunction select(selector, table, joiner, where, orderBy) {\n  return 'SELECT ' + selector + ' FROM ' +\n    (typeof table === 'string' ? table : table.join(' JOIN ')) +\n    (joiner ? (' ON ' + joiner) : '') +\n    (where ? (' WHERE ' +\n    (typeof where === 'string' ? where : where.join(' AND '))) : '') +\n    (orderBy ? (' ORDER BY ' + orderBy) : '');\n}\n\nfunction compactRevs$1(revs, docId, tx) {\n\n  if (!revs.length) {\n    return;\n  }\n\n  var numDone = 0;\n  var seqs = [];\n\n  function checkDone() {\n    if (++numDone === revs.length) { // done\n      deleteOrphans();\n    }\n  }\n\n  function deleteOrphans() {\n    // find orphaned attachment digests\n\n    if (!seqs.length) {\n      return;\n    }\n\n    var sql = 'SELECT DISTINCT digest AS digest FROM ' +\n      ATTACH_AND_SEQ_STORE$1 + ' WHERE seq IN ' + qMarks(seqs.length);\n\n    tx.executeSql(sql, seqs, function (tx, res) {\n\n      var digestsToCheck = [];\n      for (var i = 0; i < res.rows.length; i++) {\n        digestsToCheck.push(res.rows.item(i).digest);\n      }\n      if (!digestsToCheck.length) {\n        return;\n      }\n\n      var sql = 'DELETE FROM ' + ATTACH_AND_SEQ_STORE$1 +\n        ' WHERE seq IN (' +\n        seqs.map(function () { return '?'; }).join(',') +\n        ')';\n      tx.executeSql(sql, seqs, function (tx) {\n\n        var sql = 'SELECT digest FROM ' + ATTACH_AND_SEQ_STORE$1 +\n          ' WHERE digest IN (' +\n          digestsToCheck.map(function () { return '?'; }).join(',') +\n          ')';\n        tx.executeSql(sql, digestsToCheck, function (tx, res) {\n          var nonOrphanedDigests = new pouchdbCollections.Set();\n          for (var i = 0; i < res.rows.length; i++) {\n            nonOrphanedDigests.add(res.rows.item(i).digest);\n          }\n          digestsToCheck.forEach(function (digest) {\n            if (nonOrphanedDigests.has(digest)) {\n              return;\n            }\n            tx.executeSql(\n              'DELETE FROM ' + ATTACH_AND_SEQ_STORE$1 + ' WHERE digest=?',\n              [digest]);\n            tx.executeSql(\n              'DELETE FROM ' + ATTACH_STORE$1 + ' WHERE digest=?', [digest]);\n          });\n        });\n      });\n    });\n  }\n\n  // update by-seq and attach stores in parallel\n  revs.forEach(function (rev) {\n    var sql = 'SELECT seq FROM ' + BY_SEQ_STORE$1 +\n      ' WHERE doc_id=? AND rev=?';\n\n    tx.executeSql(sql, [docId, rev], function (tx, res) {\n      if (!res.rows.length) { // already deleted\n        return checkDone();\n      }\n      var seq = res.rows.item(0).seq;\n      seqs.push(seq);\n\n      tx.executeSql(\n        'DELETE FROM ' + BY_SEQ_STORE$1 + ' WHERE seq=?', [seq], checkDone);\n    });\n  });\n}\n\nfunction websqlError(callback) {\n  return function (event) {\n    console.error('WebSQL threw an error', event);\n    // event may actually be a SQLError object, so report is as such\n    var errorNameMatch = event && event.constructor.toString()\n        .match(/function ([^\\(]+)/);\n    var errorName = (errorNameMatch && errorNameMatch[1]) || event.type;\n    var errorReason = event.target || event.message;\n    callback(createError(WSQ_ERROR, errorReason, errorName));\n  };\n}\n\nfunction getSize(opts) {\n  if ('size' in opts) {\n    // triggers immediate popup in iOS, fixes #2347\n    // e.g. 5000001 asks for 5 MB, 10000001 asks for 10 MB,\n    return opts.size * 1000000;\n  }\n  // In iOS, doesn't matter as long as it's <= 5000000.\n  // Except that if you request too much, our tests fail\n  // because of the native \"do you accept?\" popup.\n  // In Android <=4.3, this value is actually used as an\n  // honest-to-god ceiling for data, so we need to\n  // set it to a decently high number.\n  var isAndroid = typeof navigator !== 'undefined' &&\n    /Android/.test(navigator.userAgent);\n  return isAndroid ? 5000000 : 1; // in PhantomJS, if you use 0 it will crash\n}\n\nfunction openDBSafely(openDBFunction, opts) {\n  try {\n    return {\n      db: openDBFunction(opts)\n    };\n  } catch (err) {\n    return {\n      error: err\n    };\n  }\n}\n\nvar cachedDatabases = new pouchdbCollections.Map();\n\nfunction openDB(opts) {\n  var cachedResult = cachedDatabases.get(opts.name);\n  if (!cachedResult) {\n    var openDBFun = createOpenDBFunction();\n    cachedResult = openDBSafely(openDBFun, opts);\n    cachedDatabases.set(opts.name, cachedResult);\n    if (cachedResult.db) {\n      cachedResult.db._sqlitePlugin = typeof sqlitePlugin !== 'undefined';\n    }\n  }\n  return cachedResult;\n}\n\nfunction websqlBulkDocs(dbOpts, req, opts, api, db, websqlChanges, callback) {\n  var newEdits = opts.new_edits;\n  var userDocs = req.docs;\n\n  // Parse the docs, give them a sequence number for the result\n  var docInfos = userDocs.map(function (doc) {\n    if (doc._id && isLocalId(doc._id)) {\n      return doc;\n    }\n    var newDoc = parseDoc(doc, newEdits);\n    return newDoc;\n  });\n\n  var docInfoErrors = docInfos.filter(function (docInfo) {\n    return docInfo.error;\n  });\n  if (docInfoErrors.length) {\n    return callback(docInfoErrors[0]);\n  }\n\n  var tx;\n  var results = new Array(docInfos.length);\n  var fetchedDocs = new pouchdbCollections.Map();\n\n  var preconditionErrored;\n  function complete() {\n    if (preconditionErrored) {\n      return callback(preconditionErrored);\n    }\n    websqlChanges.notify(api._name);\n    api._docCount = -1; // invalidate\n    callback(null, results);\n  }\n\n  function verifyAttachment(digest, callback) {\n    var sql = 'SELECT count(*) as cnt FROM ' + ATTACH_STORE$1 +\n      ' WHERE digest=?';\n    tx.executeSql(sql, [digest], function (tx, result) {\n      if (result.rows.item(0).cnt === 0) {\n        var err = createError(MISSING_STUB,\n          'unknown stub attachment with digest ' +\n          digest);\n        callback(err);\n      } else {\n        callback();\n      }\n    });\n  }\n\n  function verifyAttachments(finish) {\n    var digests = [];\n    docInfos.forEach(function (docInfo) {\n      if (docInfo.data && docInfo.data._attachments) {\n        Object.keys(docInfo.data._attachments).forEach(function (filename) {\n          var att = docInfo.data._attachments[filename];\n          if (att.stub) {\n            digests.push(att.digest);\n          }\n        });\n      }\n    });\n    if (!digests.length) {\n      return finish();\n    }\n    var numDone = 0;\n    var err;\n\n    function checkDone() {\n      if (++numDone === digests.length) {\n        finish(err);\n      }\n    }\n    digests.forEach(function (digest) {\n      verifyAttachment(digest, function (attErr) {\n        if (attErr && !err) {\n          err = attErr;\n        }\n        checkDone();\n      });\n    });\n  }\n\n  function writeDoc(docInfo, winningRev, winningRevIsDeleted, newRevIsDeleted,\n                    isUpdate, delta, resultsIdx, callback) {\n\n    function finish() {\n      var data = docInfo.data;\n      var deletedInt = newRevIsDeleted ? 1 : 0;\n\n      var id = data._id;\n      var rev = data._rev;\n      var json = stringifyDoc(data);\n      var sql = 'INSERT INTO ' + BY_SEQ_STORE$1 +\n        ' (doc_id, rev, json, deleted) VALUES (?, ?, ?, ?);';\n      var sqlArgs = [id, rev, json, deletedInt];\n\n      // map seqs to attachment digests, which\n      // we will need later during compaction\n      function insertAttachmentMappings(seq, callback) {\n        var attsAdded = 0;\n        var attsToAdd = Object.keys(data._attachments || {});\n\n        if (!attsToAdd.length) {\n          return callback();\n        }\n        function checkDone() {\n          if (++attsAdded === attsToAdd.length) {\n            callback();\n          }\n          return false; // ack handling a constraint error\n        }\n        function add(att) {\n          var sql = 'INSERT INTO ' + ATTACH_AND_SEQ_STORE$1 +\n            ' (digest, seq) VALUES (?,?)';\n          var sqlArgs = [data._attachments[att].digest, seq];\n          tx.executeSql(sql, sqlArgs, checkDone, checkDone);\n          // second callback is for a constaint error, which we ignore\n          // because this docid/rev has already been associated with\n          // the digest (e.g. when new_edits == false)\n        }\n        for (var i = 0; i < attsToAdd.length; i++) {\n          add(attsToAdd[i]); // do in parallel\n        }\n      }\n\n      tx.executeSql(sql, sqlArgs, function (tx, result) {\n        var seq = result.insertId;\n        insertAttachmentMappings(seq, function () {\n          dataWritten(tx, seq);\n        });\n      }, function () {\n        // constraint error, recover by updating instead (see #1638)\n        var fetchSql = select('seq', BY_SEQ_STORE$1, null,\n          'doc_id=? AND rev=?');\n        tx.executeSql(fetchSql, [id, rev], function (tx, res) {\n          var seq = res.rows.item(0).seq;\n          var sql = 'UPDATE ' + BY_SEQ_STORE$1 +\n            ' SET json=?, deleted=? WHERE doc_id=? AND rev=?;';\n          var sqlArgs = [json, deletedInt, id, rev];\n          tx.executeSql(sql, sqlArgs, function (tx) {\n            insertAttachmentMappings(seq, function () {\n              dataWritten(tx, seq);\n            });\n          });\n        });\n        return false; // ack that we've handled the error\n      });\n    }\n\n    function collectResults(attachmentErr) {\n      if (!err) {\n        if (attachmentErr) {\n          err = attachmentErr;\n          callback(err);\n        } else if (recv === attachments.length) {\n          finish();\n        }\n      }\n    }\n\n    var err = null;\n    var recv = 0;\n\n    docInfo.data._id = docInfo.metadata.id;\n    docInfo.data._rev = docInfo.metadata.rev;\n    var attachments = Object.keys(docInfo.data._attachments || {});\n\n\n    if (newRevIsDeleted) {\n      docInfo.data._deleted = true;\n    }\n\n    function attachmentSaved(err) {\n      recv++;\n      collectResults(err);\n    }\n\n    attachments.forEach(function (key) {\n      var att = docInfo.data._attachments[key];\n      if (!att.stub) {\n        var data = att.data;\n        delete att.data;\n        var digest = att.digest;\n        saveAttachment(digest, data, attachmentSaved);\n      } else {\n        recv++;\n        collectResults();\n      }\n    });\n\n    if (!attachments.length) {\n      finish();\n    }\n\n    function dataWritten(tx, seq) {\n      var id = docInfo.metadata.id;\n      if (isUpdate && api.auto_compaction) {\n        compactRevs$1(compactTree(docInfo.metadata), id, tx);\n      } else if (docInfo.stemmedRevs.length) {\n        compactRevs$1(docInfo.stemmedRevs, id, tx);\n      }\n\n      docInfo.metadata.seq = seq;\n      delete docInfo.metadata.rev;\n\n      var sql = isUpdate ?\n      'UPDATE ' + DOC_STORE$1 +\n      ' SET json=?, max_seq=?, winningseq=' +\n      '(SELECT seq FROM ' + BY_SEQ_STORE$1 +\n      ' WHERE doc_id=' + DOC_STORE$1 + '.id AND rev=?) WHERE id=?'\n        : 'INSERT INTO ' + DOC_STORE$1 +\n      ' (id, winningseq, max_seq, json) VALUES (?,?,?,?);';\n      var metadataStr = safeJsonStringify(docInfo.metadata);\n      var params = isUpdate ?\n        [metadataStr, seq, winningRev, id] :\n        [id, seq, seq, metadataStr];\n      tx.executeSql(sql, params, function () {\n        results[resultsIdx] = {\n          ok: true,\n          id: docInfo.metadata.id,\n          rev: winningRev\n        };\n        fetchedDocs.set(id, docInfo.metadata);\n        callback();\n      });\n    }\n  }\n\n  function websqlProcessDocs() {\n    processDocs(dbOpts.revs_limit, docInfos, api, fetchedDocs, tx,\n                results, writeDoc, opts);\n  }\n\n  function fetchExistingDocs(callback) {\n    if (!docInfos.length) {\n      return callback();\n    }\n\n    var numFetched = 0;\n\n    function checkDone() {\n      if (++numFetched === docInfos.length) {\n        callback();\n      }\n    }\n\n    docInfos.forEach(function (docInfo) {\n      if (docInfo._id && isLocalId(docInfo._id)) {\n        return checkDone(); // skip local docs\n      }\n      var id = docInfo.metadata.id;\n      tx.executeSql('SELECT json FROM ' + DOC_STORE$1 +\n      ' WHERE id = ?', [id], function (tx, result) {\n        if (result.rows.length) {\n          var metadata = safeJsonParse(result.rows.item(0).json);\n          fetchedDocs.set(id, metadata);\n        }\n        checkDone();\n      });\n    });\n  }\n\n  function saveAttachment(digest, data, callback) {\n    var sql = 'SELECT digest FROM ' + ATTACH_STORE$1 + ' WHERE digest=?';\n    tx.executeSql(sql, [digest], function (tx, result) {\n      if (result.rows.length) { // attachment already exists\n        return callback();\n      }\n      // we could just insert before selecting and catch the error,\n      // but my hunch is that it's cheaper not to serialize the blob\n      // from JS to C if we don't have to (TODO: confirm this)\n      sql = 'INSERT INTO ' + ATTACH_STORE$1 +\n      ' (digest, body, escaped) VALUES (?,?,1)';\n      tx.executeSql(sql, [digest, escapeBlob(data)], function () {\n        callback();\n      }, function () {\n        // ignore constaint errors, means it already exists\n        callback();\n        return false; // ack we handled the error\n      });\n    });\n  }\n\n  preprocessAttachments$1(docInfos, 'binary', function (err) {\n    if (err) {\n      return callback(err);\n    }\n    db.transaction(function (txn) {\n      tx = txn;\n      verifyAttachments(function (err) {\n        if (err) {\n          preconditionErrored = err;\n        } else {\n          fetchExistingDocs(websqlProcessDocs);\n        }\n      });\n    }, websqlError(callback), complete);\n  });\n}\n\nvar websqlChanges = new Changes$1();\n\nfunction fetchAttachmentsIfNecessary$1(doc, opts, api, txn, cb) {\n  var attachments = Object.keys(doc._attachments || {});\n  if (!attachments.length) {\n    return cb && cb();\n  }\n  var numDone = 0;\n\n  function checkDone() {\n    if (++numDone === attachments.length && cb) {\n      cb();\n    }\n  }\n\n  function fetchAttachment(doc, att) {\n    var attObj = doc._attachments[att];\n    var attOpts = {binary: opts.binary, ctx: txn};\n    api._getAttachment(attObj, attOpts, function (_, data) {\n      doc._attachments[att] = jsExtend.extend(\n        pick(attObj, ['digest', 'content_type']),\n        { data: data }\n      );\n      checkDone();\n    });\n  }\n\n  attachments.forEach(function (att) {\n    if (opts.attachments && opts.include_docs) {\n      fetchAttachment(doc, att);\n    } else {\n      doc._attachments[att].stub = true;\n      checkDone();\n    }\n  });\n}\n\nvar POUCH_VERSION = 1;\n\n// these indexes cover the ground for most allDocs queries\nvar BY_SEQ_STORE_DELETED_INDEX_SQL =\n  'CREATE INDEX IF NOT EXISTS \\'by-seq-deleted-idx\\' ON ' +\n  BY_SEQ_STORE$1 + ' (seq, deleted)';\nvar BY_SEQ_STORE_DOC_ID_REV_INDEX_SQL =\n  'CREATE UNIQUE INDEX IF NOT EXISTS \\'by-seq-doc-id-rev\\' ON ' +\n    BY_SEQ_STORE$1 + ' (doc_id, rev)';\nvar DOC_STORE_WINNINGSEQ_INDEX_SQL =\n  'CREATE INDEX IF NOT EXISTS \\'doc-winningseq-idx\\' ON ' +\n  DOC_STORE$1 + ' (winningseq)';\nvar ATTACH_AND_SEQ_STORE_SEQ_INDEX_SQL =\n  'CREATE INDEX IF NOT EXISTS \\'attach-seq-seq-idx\\' ON ' +\n    ATTACH_AND_SEQ_STORE$1 + ' (seq)';\nvar ATTACH_AND_SEQ_STORE_ATTACH_INDEX_SQL =\n  'CREATE UNIQUE INDEX IF NOT EXISTS \\'attach-seq-digest-idx\\' ON ' +\n    ATTACH_AND_SEQ_STORE$1 + ' (digest, seq)';\n\nvar DOC_STORE_AND_BY_SEQ_JOINER = BY_SEQ_STORE$1 +\n  '.seq = ' + DOC_STORE$1 + '.winningseq';\n\nvar SELECT_DOCS = BY_SEQ_STORE$1 + '.seq AS seq, ' +\n  BY_SEQ_STORE$1 + '.deleted AS deleted, ' +\n  BY_SEQ_STORE$1 + '.json AS data, ' +\n  BY_SEQ_STORE$1 + '.rev AS rev, ' +\n  DOC_STORE$1 + '.json AS metadata';\n\nfunction WebSqlPouch(opts, callback) {\n  var api = this;\n  var instanceId = null;\n  var size = getSize(opts);\n  var idRequests = [];\n  var encoding;\n\n  api._docCount = -1; // cache sqlite count(*) for performance\n  api._name = opts.name;\n\n  var openDBResult = openDB({\n    name: api._name,\n    version: POUCH_VERSION,\n    description: api._name,\n    size: size,\n    location: opts.location,\n    createFromLocation: opts.createFromLocation,\n    androidDatabaseImplementation: opts.androidDatabaseImplementation\n  });\n  if (openDBResult.error) {\n    return websqlError(callback)(openDBResult.error);\n  }\n  var db = openDBResult.db;\n  if (typeof db.readTransaction !== 'function') {\n    // doesn't exist in sqlite plugin\n    db.readTransaction = db.transaction;\n  }\n\n  function dbCreated() {\n    // note the db name in case the browser upgrades to idb\n    if (hasLocalStorage()) {\n      window.localStorage['_pouch__websqldb_' + api._name] = true;\n    }\n    callback(null, api);\n  }\n\n  // In this migration, we added the 'deleted' and 'local' columns to the\n  // by-seq and doc store tables.\n  // To preserve existing user data, we re-process all the existing JSON\n  // and add these values.\n  // Called migration2 because it corresponds to adapter version (db_version) #2\n  function runMigration2(tx, callback) {\n    // index used for the join in the allDocs query\n    tx.executeSql(DOC_STORE_WINNINGSEQ_INDEX_SQL);\n\n    tx.executeSql('ALTER TABLE ' + BY_SEQ_STORE$1 +\n      ' ADD COLUMN deleted TINYINT(1) DEFAULT 0', [], function () {\n      tx.executeSql(BY_SEQ_STORE_DELETED_INDEX_SQL);\n      tx.executeSql('ALTER TABLE ' + DOC_STORE$1 +\n        ' ADD COLUMN local TINYINT(1) DEFAULT 0', [], function () {\n        tx.executeSql('CREATE INDEX IF NOT EXISTS \\'doc-store-local-idx\\' ON ' +\n          DOC_STORE$1 + ' (local, id)');\n\n        var sql = 'SELECT ' + DOC_STORE$1 + '.winningseq AS seq, ' + DOC_STORE$1 +\n          '.json AS metadata FROM ' + BY_SEQ_STORE$1 + ' JOIN ' + DOC_STORE$1 +\n          ' ON ' + BY_SEQ_STORE$1 + '.seq = ' + DOC_STORE$1 + '.winningseq';\n\n        tx.executeSql(sql, [], function (tx, result) {\n\n          var deleted = [];\n          var local = [];\n\n          for (var i = 0; i < result.rows.length; i++) {\n            var item = result.rows.item(i);\n            var seq = item.seq;\n            var metadata = JSON.parse(item.metadata);\n            if (isDeleted(metadata)) {\n              deleted.push(seq);\n            }\n            if (isLocalId(metadata.id)) {\n              local.push(metadata.id);\n            }\n          }\n          tx.executeSql('UPDATE ' + DOC_STORE$1 + 'SET local = 1 WHERE id IN ' +\n            qMarks(local.length), local, function () {\n            tx.executeSql('UPDATE ' + BY_SEQ_STORE$1 +\n              ' SET deleted = 1 WHERE seq IN ' +\n              qMarks(deleted.length), deleted, callback);\n          });\n        });\n      });\n    });\n  }\n\n  // in this migration, we make all the local docs unversioned\n  function runMigration3(tx, callback) {\n    var local = 'CREATE TABLE IF NOT EXISTS ' + LOCAL_STORE$1 +\n      ' (id UNIQUE, rev, json)';\n    tx.executeSql(local, [], function () {\n      var sql = 'SELECT ' + DOC_STORE$1 + '.id AS id, ' +\n        BY_SEQ_STORE$1 + '.json AS data ' +\n        'FROM ' + BY_SEQ_STORE$1 + ' JOIN ' +\n        DOC_STORE$1 + ' ON ' + BY_SEQ_STORE$1 + '.seq = ' +\n        DOC_STORE$1 + '.winningseq WHERE local = 1';\n      tx.executeSql(sql, [], function (tx, res) {\n        var rows = [];\n        for (var i = 0; i < res.rows.length; i++) {\n          rows.push(res.rows.item(i));\n        }\n        function doNext() {\n          if (!rows.length) {\n            return callback(tx);\n          }\n          var row = rows.shift();\n          var rev = JSON.parse(row.data)._rev;\n          tx.executeSql('INSERT INTO ' + LOCAL_STORE$1 +\n              ' (id, rev, json) VALUES (?,?,?)',\n              [row.id, rev, row.data], function (tx) {\n            tx.executeSql('DELETE FROM ' + DOC_STORE$1 + ' WHERE id=?',\n                [row.id], function (tx) {\n              tx.executeSql('DELETE FROM ' + BY_SEQ_STORE$1 + ' WHERE seq=?',\n                  [row.seq], function () {\n                doNext();\n              });\n            });\n          });\n        }\n        doNext();\n      });\n    });\n  }\n\n  // in this migration, we remove doc_id_rev and just use rev\n  function runMigration4(tx, callback) {\n\n    function updateRows(rows) {\n      function doNext() {\n        if (!rows.length) {\n          return callback(tx);\n        }\n        var row = rows.shift();\n        var doc_id_rev = parseHexString(row.hex, encoding);\n        var idx = doc_id_rev.lastIndexOf('::');\n        var doc_id = doc_id_rev.substring(0, idx);\n        var rev = doc_id_rev.substring(idx + 2);\n        var sql = 'UPDATE ' + BY_SEQ_STORE$1 +\n          ' SET doc_id=?, rev=? WHERE doc_id_rev=?';\n        tx.executeSql(sql, [doc_id, rev, doc_id_rev], function () {\n          doNext();\n        });\n      }\n      doNext();\n    }\n\n    var sql = 'ALTER TABLE ' + BY_SEQ_STORE$1 + ' ADD COLUMN doc_id';\n    tx.executeSql(sql, [], function (tx) {\n      var sql = 'ALTER TABLE ' + BY_SEQ_STORE$1 + ' ADD COLUMN rev';\n      tx.executeSql(sql, [], function (tx) {\n        tx.executeSql(BY_SEQ_STORE_DOC_ID_REV_INDEX_SQL, [], function (tx) {\n          var sql = 'SELECT hex(doc_id_rev) as hex FROM ' + BY_SEQ_STORE$1;\n          tx.executeSql(sql, [], function (tx, res) {\n            var rows = [];\n            for (var i = 0; i < res.rows.length; i++) {\n              rows.push(res.rows.item(i));\n            }\n            updateRows(rows);\n          });\n        });\n      });\n    });\n  }\n\n  // in this migration, we add the attach_and_seq table\n  // for issue #2818\n  function runMigration5(tx, callback) {\n\n    function migrateAttsAndSeqs(tx) {\n      // need to actually populate the table. this is the expensive part,\n      // so as an optimization, check first that this database even\n      // contains attachments\n      var sql = 'SELECT COUNT(*) AS cnt FROM ' + ATTACH_STORE$1;\n      tx.executeSql(sql, [], function (tx, res) {\n        var count = res.rows.item(0).cnt;\n        if (!count) {\n          return callback(tx);\n        }\n\n        var offset = 0;\n        var pageSize = 10;\n        function nextPage() {\n          var sql = select(\n            SELECT_DOCS + ', ' + DOC_STORE$1 + '.id AS id',\n            [DOC_STORE$1, BY_SEQ_STORE$1],\n            DOC_STORE_AND_BY_SEQ_JOINER,\n            null,\n            DOC_STORE$1 + '.id '\n          );\n          sql += ' LIMIT ' + pageSize + ' OFFSET ' + offset;\n          offset += pageSize;\n          tx.executeSql(sql, [], function (tx, res) {\n            if (!res.rows.length) {\n              return callback(tx);\n            }\n            var digestSeqs = {};\n            function addDigestSeq(digest, seq) {\n              // uniq digest/seq pairs, just in case there are dups\n              var seqs = digestSeqs[digest] = (digestSeqs[digest] || []);\n              if (seqs.indexOf(seq) === -1) {\n                seqs.push(seq);\n              }\n            }\n            for (var i = 0; i < res.rows.length; i++) {\n              var row = res.rows.item(i);\n              var doc = unstringifyDoc(row.data, row.id, row.rev);\n              var atts = Object.keys(doc._attachments || {});\n              for (var j = 0; j < atts.length; j++) {\n                var att = doc._attachments[atts[j]];\n                addDigestSeq(att.digest, row.seq);\n              }\n            }\n            var digestSeqPairs = [];\n            Object.keys(digestSeqs).forEach(function (digest) {\n              var seqs = digestSeqs[digest];\n              seqs.forEach(function (seq) {\n                digestSeqPairs.push([digest, seq]);\n              });\n            });\n            if (!digestSeqPairs.length) {\n              return nextPage();\n            }\n            var numDone = 0;\n            digestSeqPairs.forEach(function (pair) {\n              var sql = 'INSERT INTO ' + ATTACH_AND_SEQ_STORE$1 +\n                ' (digest, seq) VALUES (?,?)';\n              tx.executeSql(sql, pair, function () {\n                if (++numDone === digestSeqPairs.length) {\n                  nextPage();\n                }\n              });\n            });\n          });\n        }\n        nextPage();\n      });\n    }\n\n    var attachAndRev = 'CREATE TABLE IF NOT EXISTS ' +\n      ATTACH_AND_SEQ_STORE$1 + ' (digest, seq INTEGER)';\n    tx.executeSql(attachAndRev, [], function (tx) {\n      tx.executeSql(\n        ATTACH_AND_SEQ_STORE_ATTACH_INDEX_SQL, [], function (tx) {\n          tx.executeSql(\n            ATTACH_AND_SEQ_STORE_SEQ_INDEX_SQL, [],\n            migrateAttsAndSeqs);\n        });\n    });\n  }\n\n  // in this migration, we use escapeBlob() and unescapeBlob()\n  // instead of reading out the binary as HEX, which is slow\n  function runMigration6(tx, callback) {\n    var sql = 'ALTER TABLE ' + ATTACH_STORE$1 +\n      ' ADD COLUMN escaped TINYINT(1) DEFAULT 0';\n    tx.executeSql(sql, [], callback);\n  }\n\n  // issue #3136, in this migration we need a \"latest seq\" as well\n  // as the \"winning seq\" in the doc store\n  function runMigration7(tx, callback) {\n    var sql = 'ALTER TABLE ' + DOC_STORE$1 +\n      ' ADD COLUMN max_seq INTEGER';\n    tx.executeSql(sql, [], function (tx) {\n      var sql = 'UPDATE ' + DOC_STORE$1 + ' SET max_seq=(SELECT MAX(seq) FROM ' +\n        BY_SEQ_STORE$1 + ' WHERE doc_id=id)';\n      tx.executeSql(sql, [], function (tx) {\n        // add unique index after filling, else we'll get a constraint\n        // error when we do the ALTER TABLE\n        var sql =\n          'CREATE UNIQUE INDEX IF NOT EXISTS \\'doc-max-seq-idx\\' ON ' +\n          DOC_STORE$1 + ' (max_seq)';\n        tx.executeSql(sql, [], callback);\n      });\n    });\n  }\n\n  function checkEncoding(tx, cb) {\n    // UTF-8 on chrome/android, UTF-16 on safari < 7.1\n    tx.executeSql('SELECT HEX(\"a\") AS hex', [], function (tx, res) {\n        var hex = res.rows.item(0).hex;\n        encoding = hex.length === 2 ? 'UTF-8' : 'UTF-16';\n        cb();\n      }\n    );\n  }\n\n  function onGetInstanceId() {\n    while (idRequests.length > 0) {\n      var idCallback = idRequests.pop();\n      idCallback(null, instanceId);\n    }\n  }\n\n  function onGetVersion(tx, dbVersion) {\n    if (dbVersion === 0) {\n      // initial schema\n\n      var meta = 'CREATE TABLE IF NOT EXISTS ' + META_STORE$1 +\n        ' (dbid, db_version INTEGER)';\n      var attach = 'CREATE TABLE IF NOT EXISTS ' + ATTACH_STORE$1 +\n        ' (digest UNIQUE, escaped TINYINT(1), body BLOB)';\n      var attachAndRev = 'CREATE TABLE IF NOT EXISTS ' +\n        ATTACH_AND_SEQ_STORE$1 + ' (digest, seq INTEGER)';\n      // TODO: migrate winningseq to INTEGER\n      var doc = 'CREATE TABLE IF NOT EXISTS ' + DOC_STORE$1 +\n        ' (id unique, json, winningseq, max_seq INTEGER UNIQUE)';\n      var seq = 'CREATE TABLE IF NOT EXISTS ' + BY_SEQ_STORE$1 +\n        ' (seq INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT, ' +\n        'json, deleted TINYINT(1), doc_id, rev)';\n      var local = 'CREATE TABLE IF NOT EXISTS ' + LOCAL_STORE$1 +\n        ' (id UNIQUE, rev, json)';\n\n      // creates\n      tx.executeSql(attach);\n      tx.executeSql(local);\n      tx.executeSql(attachAndRev, [], function () {\n        tx.executeSql(ATTACH_AND_SEQ_STORE_SEQ_INDEX_SQL);\n        tx.executeSql(ATTACH_AND_SEQ_STORE_ATTACH_INDEX_SQL);\n      });\n      tx.executeSql(doc, [], function () {\n        tx.executeSql(DOC_STORE_WINNINGSEQ_INDEX_SQL);\n        tx.executeSql(seq, [], function () {\n          tx.executeSql(BY_SEQ_STORE_DELETED_INDEX_SQL);\n          tx.executeSql(BY_SEQ_STORE_DOC_ID_REV_INDEX_SQL);\n          tx.executeSql(meta, [], function () {\n            // mark the db version, and new dbid\n            var initSeq = 'INSERT INTO ' + META_STORE$1 +\n              ' (db_version, dbid) VALUES (?,?)';\n            instanceId = uuid();\n            var initSeqArgs = [ADAPTER_VERSION$1, instanceId];\n            tx.executeSql(initSeq, initSeqArgs, function () {\n              onGetInstanceId();\n            });\n          });\n        });\n      });\n    } else { // version > 0\n\n      var setupDone = function () {\n        var migrated = dbVersion < ADAPTER_VERSION$1;\n        if (migrated) {\n          // update the db version within this transaction\n          tx.executeSql('UPDATE ' + META_STORE$1 + ' SET db_version = ' +\n            ADAPTER_VERSION$1);\n        }\n        // notify db.id() callers\n        var sql = 'SELECT dbid FROM ' + META_STORE$1;\n        tx.executeSql(sql, [], function (tx, result) {\n          instanceId = result.rows.item(0).dbid;\n          onGetInstanceId();\n        });\n      };\n\n      // would love to use promises here, but then websql\n      // ends the transaction early\n      var tasks = [\n        runMigration2,\n        runMigration3,\n        runMigration4,\n        runMigration5,\n        runMigration6,\n        runMigration7,\n        setupDone\n      ];\n\n      // run each migration sequentially\n      var i = dbVersion;\n      var nextMigration = function (tx) {\n        tasks[i - 1](tx, nextMigration);\n        i++;\n      };\n      nextMigration(tx);\n    }\n  }\n\n  function setup() {\n    db.transaction(function (tx) {\n      // first check the encoding\n      checkEncoding(tx, function () {\n        // then get the version\n        fetchVersion(tx);\n      });\n    }, websqlError(callback), dbCreated);\n  }\n\n  function fetchVersion(tx) {\n    var sql = 'SELECT sql FROM sqlite_master WHERE tbl_name = ' + META_STORE$1;\n    tx.executeSql(sql, [], function (tx, result) {\n      if (!result.rows.length) {\n        // database hasn't even been created yet (version 0)\n        onGetVersion(tx, 0);\n      } else if (!/db_version/.test(result.rows.item(0).sql)) {\n        // table was created, but without the new db_version column,\n        // so add it.\n        tx.executeSql('ALTER TABLE ' + META_STORE$1 +\n          ' ADD COLUMN db_version INTEGER', [], function () {\n          // before version 2, this column didn't even exist\n          onGetVersion(tx, 1);\n        });\n      } else { // column exists, we can safely get it\n        tx.executeSql('SELECT db_version FROM ' + META_STORE$1,\n          [], function (tx, result) {\n          var dbVersion = result.rows.item(0).db_version;\n          onGetVersion(tx, dbVersion);\n        });\n      }\n    });\n  }\n\n  setup();\n\n  api.type = function () {\n    return 'websql';\n  };\n\n  api._id = toPromise(function (callback) {\n    callback(null, instanceId);\n  });\n\n  api._info = function (callback) {\n    db.readTransaction(function (tx) {\n      countDocs(tx, function (docCount) {\n        var sql = 'SELECT MAX(seq) AS seq FROM ' + BY_SEQ_STORE$1;\n        tx.executeSql(sql, [], function (tx, res) {\n          var updateSeq = res.rows.item(0).seq || 0;\n          callback(null, {\n            doc_count: docCount,\n            update_seq: updateSeq,\n            // for debugging\n            sqlite_plugin: db._sqlitePlugin,\n            websql_encoding: encoding\n          });\n        });\n      });\n    }, websqlError(callback));\n  };\n\n  api._bulkDocs = function (req, reqOpts, callback) {\n    websqlBulkDocs(opts, req, reqOpts, api, db, websqlChanges, callback);\n  };\n\n  api._get = function (id, opts, callback) {\n    var doc;\n    var metadata;\n    var err;\n    var tx = opts.ctx;\n    if (!tx) {\n      return db.readTransaction(function (txn) {\n        api._get(id, jsExtend.extend({ctx: txn}, opts), callback);\n      });\n    }\n\n    function finish() {\n      callback(err, {doc: doc, metadata: metadata, ctx: tx});\n    }\n\n    var sql;\n    var sqlArgs;\n    if (opts.rev) {\n      sql = select(\n        SELECT_DOCS,\n        [DOC_STORE$1, BY_SEQ_STORE$1],\n        DOC_STORE$1 + '.id=' + BY_SEQ_STORE$1 + '.doc_id',\n        [BY_SEQ_STORE$1 + '.doc_id=?', BY_SEQ_STORE$1 + '.rev=?']);\n      sqlArgs = [id, opts.rev];\n    } else {\n      sql = select(\n        SELECT_DOCS,\n        [DOC_STORE$1, BY_SEQ_STORE$1],\n        DOC_STORE_AND_BY_SEQ_JOINER,\n        DOC_STORE$1 + '.id=?');\n      sqlArgs = [id];\n    }\n    tx.executeSql(sql, sqlArgs, function (a, results) {\n      if (!results.rows.length) {\n        err = createError(MISSING_DOC, 'missing');\n        return finish();\n      }\n      var item = results.rows.item(0);\n      metadata = safeJsonParse(item.metadata);\n      if (item.deleted && !opts.rev) {\n        err = createError(MISSING_DOC, 'deleted');\n        return finish();\n      }\n      doc = unstringifyDoc(item.data, metadata.id, item.rev);\n      finish();\n    });\n  };\n\n  function countDocs(tx, callback) {\n\n    if (api._docCount !== -1) {\n      return callback(api._docCount);\n    }\n\n    // count the total rows\n    var sql = select(\n      'COUNT(' + DOC_STORE$1 + '.id) AS \\'num\\'',\n      [DOC_STORE$1, BY_SEQ_STORE$1],\n      DOC_STORE_AND_BY_SEQ_JOINER,\n      BY_SEQ_STORE$1 + '.deleted=0');\n\n    tx.executeSql(sql, [], function (tx, result) {\n      api._docCount = result.rows.item(0).num;\n      callback(api._docCount);\n    });\n  }\n\n  api._allDocs = function (opts, callback) {\n    var results = [];\n    var totalRows;\n\n    var start = 'startkey' in opts ? opts.startkey : false;\n    var end = 'endkey' in opts ? opts.endkey : false;\n    var key = 'key' in opts ? opts.key : false;\n    var descending = 'descending' in opts ? opts.descending : false;\n    var limit = 'limit' in opts ? opts.limit : -1;\n    var offset = 'skip' in opts ? opts.skip : 0;\n    var inclusiveEnd = opts.inclusive_end !== false;\n\n    var sqlArgs = [];\n    var criteria = [];\n\n    if (key !== false) {\n      criteria.push(DOC_STORE$1 + '.id = ?');\n      sqlArgs.push(key);\n    } else if (start !== false || end !== false) {\n      if (start !== false) {\n        criteria.push(DOC_STORE$1 + '.id ' + (descending ? '<=' : '>=') + ' ?');\n        sqlArgs.push(start);\n      }\n      if (end !== false) {\n        var comparator = descending ? '>' : '<';\n        if (inclusiveEnd) {\n          comparator += '=';\n        }\n        criteria.push(DOC_STORE$1 + '.id ' + comparator + ' ?');\n        sqlArgs.push(end);\n      }\n      if (key !== false) {\n        criteria.push(DOC_STORE$1 + '.id = ?');\n        sqlArgs.push(key);\n      }\n    }\n\n    if (opts.deleted !== 'ok') {\n      // report deleted if keys are specified\n      criteria.push(BY_SEQ_STORE$1 + '.deleted = 0');\n    }\n\n    db.readTransaction(function (tx) {\n\n      // first count up the total rows\n      countDocs(tx, function (count) {\n        totalRows = count;\n\n        if (limit === 0) {\n          return;\n        }\n\n        // then actually fetch the documents\n        var sql = select(\n          SELECT_DOCS,\n          [DOC_STORE$1, BY_SEQ_STORE$1],\n          DOC_STORE_AND_BY_SEQ_JOINER,\n          criteria,\n          DOC_STORE$1 + '.id ' + (descending ? 'DESC' : 'ASC')\n          );\n        sql += ' LIMIT ' + limit + ' OFFSET ' + offset;\n\n        tx.executeSql(sql, sqlArgs, function (tx, result) {\n          for (var i = 0, l = result.rows.length; i < l; i++) {\n            var item = result.rows.item(i);\n            var metadata = safeJsonParse(item.metadata);\n            var id = metadata.id;\n            var data = unstringifyDoc(item.data, id, item.rev);\n            var winningRev = data._rev;\n            var doc = {\n              id: id,\n              key: id,\n              value: {rev: winningRev}\n            };\n            if (opts.include_docs) {\n              doc.doc = data;\n              doc.doc._rev = winningRev;\n              if (opts.conflicts) {\n                doc.doc._conflicts = collectConflicts(metadata);\n              }\n              fetchAttachmentsIfNecessary$1(doc.doc, opts, api, tx);\n            }\n            if (item.deleted) {\n              if (opts.deleted === 'ok') {\n                doc.value.deleted = true;\n                doc.doc = null;\n              } else {\n                continue;\n              }\n            }\n            results.push(doc);\n          }\n        });\n      });\n    }, websqlError(callback), function () {\n      callback(null, {\n        total_rows: totalRows,\n        offset: opts.skip,\n        rows: results\n      });\n    });\n  };\n\n  api._changes = function (opts) {\n    opts = clone(opts);\n\n    if (opts.continuous) {\n      var id = api._name + ':' + uuid();\n      websqlChanges.addListener(api._name, id, api, opts);\n      websqlChanges.notify(api._name);\n      return {\n        cancel: function () {\n          websqlChanges.removeListener(api._name, id);\n        }\n      };\n    }\n\n    var descending = opts.descending;\n\n    // Ignore the `since` parameter when `descending` is true\n    opts.since = opts.since && !descending ? opts.since : 0;\n\n    var limit = 'limit' in opts ? opts.limit : -1;\n    if (limit === 0) {\n      limit = 1; // per CouchDB _changes spec\n    }\n\n    var returnDocs;\n    if ('return_docs' in opts) {\n      returnDocs = opts.return_docs;\n    } else if ('returnDocs' in opts) {\n      // TODO: Remove 'returnDocs' in favor of 'return_docs' in a future release\n      returnDocs = opts.returnDocs;\n    } else {\n      returnDocs = true;\n    }\n    var results = [];\n    var numResults = 0;\n\n    function fetchChanges() {\n\n      var selectStmt =\n        DOC_STORE$1 + '.json AS metadata, ' +\n        DOC_STORE$1 + '.max_seq AS maxSeq, ' +\n        BY_SEQ_STORE$1 + '.json AS winningDoc, ' +\n        BY_SEQ_STORE$1 + '.rev AS winningRev ';\n\n      var from = DOC_STORE$1 + ' JOIN ' + BY_SEQ_STORE$1;\n\n      var joiner = DOC_STORE$1 + '.id=' + BY_SEQ_STORE$1 + '.doc_id' +\n        ' AND ' + DOC_STORE$1 + '.winningseq=' + BY_SEQ_STORE$1 + '.seq';\n\n      var criteria = ['maxSeq > ?'];\n      var sqlArgs = [opts.since];\n\n      if (opts.doc_ids) {\n        criteria.push(DOC_STORE$1 + '.id IN ' + qMarks(opts.doc_ids.length));\n        sqlArgs = sqlArgs.concat(opts.doc_ids);\n      }\n\n      var orderBy = 'maxSeq ' + (descending ? 'DESC' : 'ASC');\n\n      var sql = select(selectStmt, from, joiner, criteria, orderBy);\n\n      var filter = filterChange(opts);\n      if (!opts.view && !opts.filter) {\n        // we can just limit in the query\n        sql += ' LIMIT ' + limit;\n      }\n\n      var lastSeq = opts.since || 0;\n      db.readTransaction(function (tx) {\n        tx.executeSql(sql, sqlArgs, function (tx, result) {\n          function reportChange(change) {\n            return function () {\n              opts.onChange(change);\n            };\n          }\n          for (var i = 0, l = result.rows.length; i < l; i++) {\n            var item = result.rows.item(i);\n            var metadata = safeJsonParse(item.metadata);\n            lastSeq = item.maxSeq;\n\n            var doc = unstringifyDoc(item.winningDoc, metadata.id,\n              item.winningRev);\n            var change = opts.processChange(doc, metadata, opts);\n            change.seq = item.maxSeq;\n\n            var filtered = filter(change);\n            if (typeof filtered === 'object') {\n              return opts.complete(filtered);\n            }\n\n            if (filtered) {\n              numResults++;\n              if (returnDocs) {\n                results.push(change);\n              }\n              // process the attachment immediately\n              // for the benefit of live listeners\n              if (opts.attachments && opts.include_docs) {\n                fetchAttachmentsIfNecessary$1(doc, opts, api, tx,\n                  reportChange(change));\n              } else {\n                reportChange(change)();\n              }\n            }\n            if (numResults === limit) {\n              break;\n            }\n          }\n        });\n      }, websqlError(opts.complete), function () {\n        if (!opts.continuous) {\n          opts.complete(null, {\n            results: results,\n            last_seq: lastSeq\n          });\n        }\n      });\n    }\n\n    fetchChanges();\n  };\n\n  api._close = function (callback) {\n    //WebSQL databases do not need to be closed\n    callback();\n  };\n\n  api._getAttachment = function (attachment, opts, callback) {\n    var res;\n    var tx = opts.ctx;\n    var digest = attachment.digest;\n    var type = attachment.content_type;\n    var sql = 'SELECT escaped, ' +\n      'CASE WHEN escaped = 1 THEN body ELSE HEX(body) END AS body FROM ' +\n      ATTACH_STORE$1 + ' WHERE digest=?';\n    tx.executeSql(sql, [digest], function (tx, result) {\n      // websql has a bug where \\u0000 causes early truncation in strings\n      // and blobs. to work around this, we used to use the hex() function,\n      // but that's not performant. after migration 6, we remove \\u0000\n      // and add it back in afterwards\n      var item = result.rows.item(0);\n      var data = item.escaped ? unescapeBlob(item.body) :\n        parseHexString(item.body, encoding);\n      if (opts.binary) {\n        res = binStringToBluffer(data, type);\n      } else {\n        res = btoa$1(data);\n      }\n      callback(null, res);\n    });\n  };\n\n  api._getRevisionTree = function (docId, callback) {\n    db.readTransaction(function (tx) {\n      var sql = 'SELECT json AS metadata FROM ' + DOC_STORE$1 + ' WHERE id = ?';\n      tx.executeSql(sql, [docId], function (tx, result) {\n        if (!result.rows.length) {\n          callback(createError(MISSING_DOC));\n        } else {\n          var data = safeJsonParse(result.rows.item(0).metadata);\n          callback(null, data.rev_tree);\n        }\n      });\n    });\n  };\n\n  api._doCompaction = function (docId, revs, callback) {\n    if (!revs.length) {\n      return callback();\n    }\n    db.transaction(function (tx) {\n\n      // update doc store\n      var sql = 'SELECT json AS metadata FROM ' + DOC_STORE$1 + ' WHERE id = ?';\n      tx.executeSql(sql, [docId], function (tx, result) {\n        var metadata = safeJsonParse(result.rows.item(0).metadata);\n        traverseRevTree(metadata.rev_tree, function (isLeaf, pos,\n                                                           revHash, ctx, opts) {\n          var rev = pos + '-' + revHash;\n          if (revs.indexOf(rev) !== -1) {\n            opts.status = 'missing';\n          }\n        });\n\n        var sql = 'UPDATE ' + DOC_STORE$1 + ' SET json = ? WHERE id = ?';\n        tx.executeSql(sql, [safeJsonStringify(metadata), docId]);\n      });\n\n      compactRevs$1(revs, docId, tx);\n    }, websqlError(callback), function () {\n      callback();\n    });\n  };\n\n  api._getLocal = function (id, callback) {\n    db.readTransaction(function (tx) {\n      var sql = 'SELECT json, rev FROM ' + LOCAL_STORE$1 + ' WHERE id=?';\n      tx.executeSql(sql, [id], function (tx, res) {\n        if (res.rows.length) {\n          var item = res.rows.item(0);\n          var doc = unstringifyDoc(item.json, id, item.rev);\n          callback(null, doc);\n        } else {\n          callback(createError(MISSING_DOC));\n        }\n      });\n    });\n  };\n\n  api._putLocal = function (doc, opts, callback) {\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n    delete doc._revisions; // ignore this, trust the rev\n    var oldRev = doc._rev;\n    var id = doc._id;\n    var newRev;\n    if (!oldRev) {\n      newRev = doc._rev = '0-1';\n    } else {\n      newRev = doc._rev = '0-' + (parseInt(oldRev.split('-')[1], 10) + 1);\n    }\n    var json = stringifyDoc(doc);\n\n    var ret;\n    function putLocal(tx) {\n      var sql;\n      var values;\n      if (oldRev) {\n        sql = 'UPDATE ' + LOCAL_STORE$1 + ' SET rev=?, json=? ' +\n          'WHERE id=? AND rev=?';\n        values = [newRev, json, id, oldRev];\n      } else {\n        sql = 'INSERT INTO ' + LOCAL_STORE$1 + ' (id, rev, json) VALUES (?,?,?)';\n        values = [id, newRev, json];\n      }\n      tx.executeSql(sql, values, function (tx, res) {\n        if (res.rowsAffected) {\n          ret = {ok: true, id: id, rev: newRev};\n          if (opts.ctx) { // return immediately\n            callback(null, ret);\n          }\n        } else {\n          callback(createError(REV_CONFLICT));\n        }\n      }, function () {\n        callback(createError(REV_CONFLICT));\n        return false; // ack that we handled the error\n      });\n    }\n\n    if (opts.ctx) {\n      putLocal(opts.ctx);\n    } else {\n      db.transaction(putLocal, websqlError(callback), function () {\n        if (ret) {\n          callback(null, ret);\n        }\n      });\n    }\n  };\n\n  api._removeLocal = function (doc, opts, callback) {\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n    var ret;\n\n    function removeLocal(tx) {\n      var sql = 'DELETE FROM ' + LOCAL_STORE$1 + ' WHERE id=? AND rev=?';\n      var params = [doc._id, doc._rev];\n      tx.executeSql(sql, params, function (tx, res) {\n        if (!res.rowsAffected) {\n          return callback(createError(MISSING_DOC));\n        }\n        ret = {ok: true, id: doc._id, rev: '0-0'};\n        if (opts.ctx) { // return immediately\n          callback(null, ret);\n        }\n      });\n    }\n\n    if (opts.ctx) {\n      removeLocal(opts.ctx);\n    } else {\n      db.transaction(removeLocal, websqlError(callback), function () {\n        if (ret) {\n          callback(null, ret);\n        }\n      });\n    }\n  };\n\n  api._destroy = function (opts, callback) {\n    websqlChanges.removeAllListeners(api._name);\n    db.transaction(function (tx) {\n      var stores = [DOC_STORE$1, BY_SEQ_STORE$1, ATTACH_STORE$1, META_STORE$1,\n        LOCAL_STORE$1, ATTACH_AND_SEQ_STORE$1];\n      stores.forEach(function (store) {\n        tx.executeSql('DROP TABLE IF EXISTS ' + store, []);\n      });\n    }, websqlError(callback), function () {\n      if (hasLocalStorage()) {\n        delete window.localStorage['_pouch__websqldb_' + api._name];\n        delete window.localStorage[api._name];\n      }\n      callback(null, {'ok': true});\n    });\n  };\n}\n\n// in the browser, use a prefix. in Node, don't bother having one\nWebSqlPouch.use_prefix = !!(typeof process === 'undefined' || process.browser);\n\nWebSqlPouch.valid = valid;\n\nvar adapters = {\n  idb: IdbPouch,\n  websql: WebSqlPouch\n};\n\nPouchDB.ajax = ajax;\nPouchDB.utils = utils;\nPouchDB.Errors = allErrors;\nPouchDB.replicate = replication.replicate;\nPouchDB.sync = sync;\nPouchDB.version = '5.3.1'; // will be automatically supplied by build.sh\nPouchDB.adapter('http', HttpPouch);\nPouchDB.adapter('https', HttpPouch);\n\nPouchDB.plugin(mapreduce);\n\nObject.keys(adapters).forEach(function (adapterName) {\n  PouchDB.adapter(adapterName, adapters[adapterName], true);\n});\n\nmodule.exports = PouchDB;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/pouchdb/lib/index-browser.js\n ** module id = 25\n ** module chunks = 0\n **/","// Generated by CoffeeScript 1.9.2\n(function() {\n  var hasProp = {}.hasOwnProperty,\n    slice = [].slice;\n\n  module.exports = function(source, scope) {\n    var key, keys, value, values;\n    keys = [];\n    values = [];\n    for (key in scope) {\n      if (!hasProp.call(scope, key)) continue;\n      value = scope[key];\n      if (key === 'this') {\n        continue;\n      }\n      keys.push(key);\n      values.push(value);\n    }\n    return Function.apply(null, slice.call(keys).concat([source])).apply(scope[\"this\"], values);\n  };\n\n}).call(this);\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/scope-eval/scope_eval.js\n ** module id = 26\n ** module chunks = 0\n **/","(function (factory) {\n    if (typeof exports === 'object') {\n        // Node/CommonJS\n        module.exports = factory();\n    } else if (typeof define === 'function' && define.amd) {\n        // AMD\n        define(factory);\n    } else {\n        // Browser globals (with support for web workers)\n        var glob;\n\n        try {\n            glob = window;\n        } catch (e) {\n            glob = self;\n        }\n\n        glob.SparkMD5 = factory();\n    }\n}(function (undefined) {\n\n    'use strict';\n\n    /*\n     * Fastest md5 implementation around (JKM md5).\n     * Credits: Joseph Myers\n     *\n     * @see http://www.myersdaily.org/joseph/javascript/md5-text.html\n     * @see http://jsperf.com/md5-shootout/7\n     */\n\n    /* this function is much faster,\n      so if possible we use it. Some IEs\n      are the only ones I know of that\n      need the idiotic second function,\n      generated by an if clause.  */\n    var add32 = function (a, b) {\n        return (a + b) & 0xFFFFFFFF;\n    },\n        hex_chr = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'];\n\n\n    function cmn(q, a, b, x, s, t) {\n        a = add32(add32(a, q), add32(x, t));\n        return add32((a << s) | (a >>> (32 - s)), b);\n    }\n\n    function ff(a, b, c, d, x, s, t) {\n        return cmn((b & c) | ((~b) & d), a, b, x, s, t);\n    }\n\n    function gg(a, b, c, d, x, s, t) {\n        return cmn((b & d) | (c & (~d)), a, b, x, s, t);\n    }\n\n    function hh(a, b, c, d, x, s, t) {\n        return cmn(b ^ c ^ d, a, b, x, s, t);\n    }\n\n    function ii(a, b, c, d, x, s, t) {\n        return cmn(c ^ (b | (~d)), a, b, x, s, t);\n    }\n\n    function md5cycle(x, k) {\n        var a = x[0],\n            b = x[1],\n            c = x[2],\n            d = x[3];\n\n        a = ff(a, b, c, d, k[0], 7, -680876936);\n        d = ff(d, a, b, c, k[1], 12, -389564586);\n        c = ff(c, d, a, b, k[2], 17, 606105819);\n        b = ff(b, c, d, a, k[3], 22, -1044525330);\n        a = ff(a, b, c, d, k[4], 7, -176418897);\n        d = ff(d, a, b, c, k[5], 12, 1200080426);\n        c = ff(c, d, a, b, k[6], 17, -1473231341);\n        b = ff(b, c, d, a, k[7], 22, -45705983);\n        a = ff(a, b, c, d, k[8], 7, 1770035416);\n        d = ff(d, a, b, c, k[9], 12, -1958414417);\n        c = ff(c, d, a, b, k[10], 17, -42063);\n        b = ff(b, c, d, a, k[11], 22, -1990404162);\n        a = ff(a, b, c, d, k[12], 7, 1804603682);\n        d = ff(d, a, b, c, k[13], 12, -40341101);\n        c = ff(c, d, a, b, k[14], 17, -1502002290);\n        b = ff(b, c, d, a, k[15], 22, 1236535329);\n\n        a = gg(a, b, c, d, k[1], 5, -165796510);\n        d = gg(d, a, b, c, k[6], 9, -1069501632);\n        c = gg(c, d, a, b, k[11], 14, 643717713);\n        b = gg(b, c, d, a, k[0], 20, -373897302);\n        a = gg(a, b, c, d, k[5], 5, -701558691);\n        d = gg(d, a, b, c, k[10], 9, 38016083);\n        c = gg(c, d, a, b, k[15], 14, -660478335);\n        b = gg(b, c, d, a, k[4], 20, -405537848);\n        a = gg(a, b, c, d, k[9], 5, 568446438);\n        d = gg(d, a, b, c, k[14], 9, -1019803690);\n        c = gg(c, d, a, b, k[3], 14, -187363961);\n        b = gg(b, c, d, a, k[8], 20, 1163531501);\n        a = gg(a, b, c, d, k[13], 5, -1444681467);\n        d = gg(d, a, b, c, k[2], 9, -51403784);\n        c = gg(c, d, a, b, k[7], 14, 1735328473);\n        b = gg(b, c, d, a, k[12], 20, -1926607734);\n\n        a = hh(a, b, c, d, k[5], 4, -378558);\n        d = hh(d, a, b, c, k[8], 11, -2022574463);\n        c = hh(c, d, a, b, k[11], 16, 1839030562);\n        b = hh(b, c, d, a, k[14], 23, -35309556);\n        a = hh(a, b, c, d, k[1], 4, -1530992060);\n        d = hh(d, a, b, c, k[4], 11, 1272893353);\n        c = hh(c, d, a, b, k[7], 16, -155497632);\n        b = hh(b, c, d, a, k[10], 23, -1094730640);\n        a = hh(a, b, c, d, k[13], 4, 681279174);\n        d = hh(d, a, b, c, k[0], 11, -358537222);\n        c = hh(c, d, a, b, k[3], 16, -722521979);\n        b = hh(b, c, d, a, k[6], 23, 76029189);\n        a = hh(a, b, c, d, k[9], 4, -640364487);\n        d = hh(d, a, b, c, k[12], 11, -421815835);\n        c = hh(c, d, a, b, k[15], 16, 530742520);\n        b = hh(b, c, d, a, k[2], 23, -995338651);\n\n        a = ii(a, b, c, d, k[0], 6, -198630844);\n        d = ii(d, a, b, c, k[7], 10, 1126891415);\n        c = ii(c, d, a, b, k[14], 15, -1416354905);\n        b = ii(b, c, d, a, k[5], 21, -57434055);\n        a = ii(a, b, c, d, k[12], 6, 1700485571);\n        d = ii(d, a, b, c, k[3], 10, -1894986606);\n        c = ii(c, d, a, b, k[10], 15, -1051523);\n        b = ii(b, c, d, a, k[1], 21, -2054922799);\n        a = ii(a, b, c, d, k[8], 6, 1873313359);\n        d = ii(d, a, b, c, k[15], 10, -30611744);\n        c = ii(c, d, a, b, k[6], 15, -1560198380);\n        b = ii(b, c, d, a, k[13], 21, 1309151649);\n        a = ii(a, b, c, d, k[4], 6, -145523070);\n        d = ii(d, a, b, c, k[11], 10, -1120210379);\n        c = ii(c, d, a, b, k[2], 15, 718787259);\n        b = ii(b, c, d, a, k[9], 21, -343485551);\n\n        x[0] = add32(a, x[0]);\n        x[1] = add32(b, x[1]);\n        x[2] = add32(c, x[2]);\n        x[3] = add32(d, x[3]);\n    }\n\n    function md5blk(s) {\n        var md5blks = [],\n            i; /* Andy King said do it this way. */\n\n        for (i = 0; i < 64; i += 4) {\n            md5blks[i >> 2] = s.charCodeAt(i) + (s.charCodeAt(i + 1) << 8) + (s.charCodeAt(i + 2) << 16) + (s.charCodeAt(i + 3) << 24);\n        }\n        return md5blks;\n    }\n\n    function md5blk_array(a) {\n        var md5blks = [],\n            i; /* Andy King said do it this way. */\n\n        for (i = 0; i < 64; i += 4) {\n            md5blks[i >> 2] = a[i] + (a[i + 1] << 8) + (a[i + 2] << 16) + (a[i + 3] << 24);\n        }\n        return md5blks;\n    }\n\n    function md51(s) {\n        var n = s.length,\n            state = [1732584193, -271733879, -1732584194, 271733878],\n            i,\n            length,\n            tail,\n            tmp,\n            lo,\n            hi;\n\n        for (i = 64; i <= n; i += 64) {\n            md5cycle(state, md5blk(s.substring(i - 64, i)));\n        }\n        s = s.substring(i - 64);\n        length = s.length;\n        tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n        for (i = 0; i < length; i += 1) {\n            tail[i >> 2] |= s.charCodeAt(i) << ((i % 4) << 3);\n        }\n        tail[i >> 2] |= 0x80 << ((i % 4) << 3);\n        if (i > 55) {\n            md5cycle(state, tail);\n            for (i = 0; i < 16; i += 1) {\n                tail[i] = 0;\n            }\n        }\n\n        // Beware that the final length might not fit in 32 bits so we take care of that\n        tmp = n * 8;\n        tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);\n        lo = parseInt(tmp[2], 16);\n        hi = parseInt(tmp[1], 16) || 0;\n\n        tail[14] = lo;\n        tail[15] = hi;\n\n        md5cycle(state, tail);\n        return state;\n    }\n\n    function md51_array(a) {\n        var n = a.length,\n            state = [1732584193, -271733879, -1732584194, 271733878],\n            i,\n            length,\n            tail,\n            tmp,\n            lo,\n            hi;\n\n        for (i = 64; i <= n; i += 64) {\n            md5cycle(state, md5blk_array(a.subarray(i - 64, i)));\n        }\n\n        // Not sure if it is a bug, however IE10 will always produce a sub array of length 1\n        // containing the last element of the parent array if the sub array specified starts\n        // beyond the length of the parent array - weird.\n        // https://connect.microsoft.com/IE/feedback/details/771452/typed-array-subarray-issue\n        a = (i - 64) < n ? a.subarray(i - 64) : new Uint8Array(0);\n\n        length = a.length;\n        tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n        for (i = 0; i < length; i += 1) {\n            tail[i >> 2] |= a[i] << ((i % 4) << 3);\n        }\n\n        tail[i >> 2] |= 0x80 << ((i % 4) << 3);\n        if (i > 55) {\n            md5cycle(state, tail);\n            for (i = 0; i < 16; i += 1) {\n                tail[i] = 0;\n            }\n        }\n\n        // Beware that the final length might not fit in 32 bits so we take care of that\n        tmp = n * 8;\n        tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);\n        lo = parseInt(tmp[2], 16);\n        hi = parseInt(tmp[1], 16) || 0;\n\n        tail[14] = lo;\n        tail[15] = hi;\n\n        md5cycle(state, tail);\n\n        return state;\n    }\n\n    function rhex(n) {\n        var s = '',\n            j;\n        for (j = 0; j < 4; j += 1) {\n            s += hex_chr[(n >> (j * 8 + 4)) & 0x0F] + hex_chr[(n >> (j * 8)) & 0x0F];\n        }\n        return s;\n    }\n\n    function hex(x) {\n        var i;\n        for (i = 0; i < x.length; i += 1) {\n            x[i] = rhex(x[i]);\n        }\n        return x.join('');\n    }\n\n    // In some cases the fast add32 function cannot be used..\n    if (hex(md51('hello')) !== '5d41402abc4b2a76b9719d911017c592') {\n        add32 = function (x, y) {\n            var lsw = (x & 0xFFFF) + (y & 0xFFFF),\n                msw = (x >> 16) + (y >> 16) + (lsw >> 16);\n            return (msw << 16) | (lsw & 0xFFFF);\n        };\n    }\n\n    // ---------------------------------------------------\n\n    /**\n     * ArrayBuffer slice polyfill.\n     *\n     * @see https://github.com/ttaubert/node-arraybuffer-slice\n     */\n\n    if (typeof ArrayBuffer !== 'undefined' && !ArrayBuffer.prototype.slice) {\n        (function () {\n            function clamp(val, length) {\n                val = (val | 0) || 0;\n\n                if (val < 0) {\n                    return Math.max(val + length, 0);\n                }\n\n                return Math.min(val, length);\n            }\n\n            ArrayBuffer.prototype.slice = function (from, to) {\n                var length = this.byteLength,\n                    begin = clamp(from, length),\n                    end = length,\n                    num,\n                    target,\n                    targetArray,\n                    sourceArray;\n\n                if (to !== undefined) {\n                    end = clamp(to, length);\n                }\n\n                if (begin > end) {\n                    return new ArrayBuffer(0);\n                }\n\n                num = end - begin;\n                target = new ArrayBuffer(num);\n                targetArray = new Uint8Array(target);\n\n                sourceArray = new Uint8Array(this, begin, num);\n                targetArray.set(sourceArray);\n\n                return target;\n            };\n        })();\n    }\n\n    // ---------------------------------------------------\n\n    /**\n     * Helpers.\n     */\n\n    function toUtf8(str) {\n        if (/[\\u0080-\\uFFFF]/.test(str)) {\n            str = unescape(encodeURIComponent(str));\n        }\n\n        return str;\n    }\n\n    function utf8Str2ArrayBuffer(str, returnUInt8Array) {\n        var length = str.length,\n           buff = new ArrayBuffer(length),\n           arr = new Uint8Array(buff),\n           i;\n\n        for (i = 0; i < length; i += 1) {\n            arr[i] = str.charCodeAt(i);\n        }\n\n        return returnUInt8Array ? arr : buff;\n    }\n\n    function arrayBuffer2Utf8Str(buff) {\n        return String.fromCharCode.apply(null, new Uint8Array(buff));\n    }\n\n    function concatenateArrayBuffers(first, second, returnUInt8Array) {\n        var result = new Uint8Array(first.byteLength + second.byteLength);\n\n        result.set(new Uint8Array(first));\n        result.set(new Uint8Array(second), first.byteLength);\n\n        return returnUInt8Array ? result : result.buffer;\n    }\n\n    function hexToBinaryString(hex) {\n        var bytes = [],\n            length = hex.length,\n            x;\n\n        for (x = 0; x < length - 1; x += 2) {\n            bytes.push(parseInt(hex.substr(x, 2), 16));\n        }\n\n        return String.fromCharCode.apply(String, bytes);\n    }\n\n    // ---------------------------------------------------\n\n    /**\n     * SparkMD5 OOP implementation.\n     *\n     * Use this class to perform an incremental md5, otherwise use the\n     * static methods instead.\n     */\n\n    function SparkMD5() {\n        // call reset to init the instance\n        this.reset();\n    }\n\n    /**\n     * Appends a string.\n     * A conversion will be applied if an utf8 string is detected.\n     *\n     * @param {String} str The string to be appended\n     *\n     * @return {SparkMD5} The instance itself\n     */\n    SparkMD5.prototype.append = function (str) {\n        // Converts the string to utf8 bytes if necessary\n        // Then append as binary\n        this.appendBinary(toUtf8(str));\n\n        return this;\n    };\n\n    /**\n     * Appends a binary string.\n     *\n     * @param {String} contents The binary string to be appended\n     *\n     * @return {SparkMD5} The instance itself\n     */\n    SparkMD5.prototype.appendBinary = function (contents) {\n        this._buff += contents;\n        this._length += contents.length;\n\n        var length = this._buff.length,\n            i;\n\n        for (i = 64; i <= length; i += 64) {\n            md5cycle(this._hash, md5blk(this._buff.substring(i - 64, i)));\n        }\n\n        this._buff = this._buff.substring(i - 64);\n\n        return this;\n    };\n\n    /**\n     * Finishes the incremental computation, reseting the internal state and\n     * returning the result.\n     *\n     * @param {Boolean} raw True to get the raw string, false to get the hex string\n     *\n     * @return {String} The result\n     */\n    SparkMD5.prototype.end = function (raw) {\n        var buff = this._buff,\n            length = buff.length,\n            i,\n            tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n            ret;\n\n        for (i = 0; i < length; i += 1) {\n            tail[i >> 2] |= buff.charCodeAt(i) << ((i % 4) << 3);\n        }\n\n        this._finish(tail, length);\n        ret = hex(this._hash);\n\n        if (raw) {\n            ret = hexToBinaryString(ret);\n        }\n\n        this.reset();\n\n        return ret;\n    };\n\n    /**\n     * Resets the internal state of the computation.\n     *\n     * @return {SparkMD5} The instance itself\n     */\n    SparkMD5.prototype.reset = function () {\n        this._buff = '';\n        this._length = 0;\n        this._hash = [1732584193, -271733879, -1732584194, 271733878];\n\n        return this;\n    };\n\n    /**\n     * Gets the internal state of the computation.\n     *\n     * @return {Object} The state\n     */\n    SparkMD5.prototype.getState = function () {\n        return {\n            buff: this._buff,\n            length: this._length,\n            hash: this._hash\n        };\n    };\n\n    /**\n     * Gets the internal state of the computation.\n     *\n     * @param {Object} state The state\n     *\n     * @return {SparkMD5} The instance itself\n     */\n    SparkMD5.prototype.setState = function (state) {\n        this._buff = state.buff;\n        this._length = state.length;\n        this._hash = state.hash;\n\n        return this;\n    };\n\n    /**\n     * Releases memory used by the incremental buffer and other additional\n     * resources. If you plan to use the instance again, use reset instead.\n     */\n    SparkMD5.prototype.destroy = function () {\n        delete this._hash;\n        delete this._buff;\n        delete this._length;\n    };\n\n    /**\n     * Finish the final calculation based on the tail.\n     *\n     * @param {Array}  tail   The tail (will be modified)\n     * @param {Number} length The length of the remaining buffer\n     */\n    SparkMD5.prototype._finish = function (tail, length) {\n        var i = length,\n            tmp,\n            lo,\n            hi;\n\n        tail[i >> 2] |= 0x80 << ((i % 4) << 3);\n        if (i > 55) {\n            md5cycle(this._hash, tail);\n            for (i = 0; i < 16; i += 1) {\n                tail[i] = 0;\n            }\n        }\n\n        // Do the final computation based on the tail and length\n        // Beware that the final length may not fit in 32 bits so we take care of that\n        tmp = this._length * 8;\n        tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);\n        lo = parseInt(tmp[2], 16);\n        hi = parseInt(tmp[1], 16) || 0;\n\n        tail[14] = lo;\n        tail[15] = hi;\n        md5cycle(this._hash, tail);\n    };\n\n    /**\n     * Performs the md5 hash on a string.\n     * A conversion will be applied if utf8 string is detected.\n     *\n     * @param {String}  str The string\n     * @param {Boolean} raw True to get the raw string, false to get the hex string\n     *\n     * @return {String} The result\n     */\n    SparkMD5.hash = function (str, raw) {\n        // Converts the string to utf8 bytes if necessary\n        // Then compute it using the binary function\n        return SparkMD5.hashBinary(toUtf8(str), raw);\n    };\n\n    /**\n     * Performs the md5 hash on a binary string.\n     *\n     * @param {String}  content The binary string\n     * @param {Boolean} raw     True to get the raw string, false to get the hex string\n     *\n     * @return {String} The result\n     */\n    SparkMD5.hashBinary = function (content, raw) {\n        var hash = md51(content),\n            ret = hex(hash);\n\n        return raw ? hexToBinaryString(ret) : ret;\n    };\n\n    // ---------------------------------------------------\n\n    /**\n     * SparkMD5 OOP implementation for array buffers.\n     *\n     * Use this class to perform an incremental md5 ONLY for array buffers.\n     */\n    SparkMD5.ArrayBuffer = function () {\n        // call reset to init the instance\n        this.reset();\n    };\n\n    /**\n     * Appends an array buffer.\n     *\n     * @param {ArrayBuffer} arr The array to be appended\n     *\n     * @return {SparkMD5.ArrayBuffer} The instance itself\n     */\n    SparkMD5.ArrayBuffer.prototype.append = function (arr) {\n        var buff = concatenateArrayBuffers(this._buff.buffer, arr, true),\n            length = buff.length,\n            i;\n\n        this._length += arr.byteLength;\n\n        for (i = 64; i <= length; i += 64) {\n            md5cycle(this._hash, md5blk_array(buff.subarray(i - 64, i)));\n        }\n\n        this._buff = (i - 64) < length ? new Uint8Array(buff.buffer.slice(i - 64)) : new Uint8Array(0);\n\n        return this;\n    };\n\n    /**\n     * Finishes the incremental computation, reseting the internal state and\n     * returning the result.\n     *\n     * @param {Boolean} raw True to get the raw string, false to get the hex string\n     *\n     * @return {String} The result\n     */\n    SparkMD5.ArrayBuffer.prototype.end = function (raw) {\n        var buff = this._buff,\n            length = buff.length,\n            tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n            i,\n            ret;\n\n        for (i = 0; i < length; i += 1) {\n            tail[i >> 2] |= buff[i] << ((i % 4) << 3);\n        }\n\n        this._finish(tail, length);\n        ret = hex(this._hash);\n\n        if (raw) {\n            ret = hexToBinaryString(ret);\n        }\n\n        this.reset();\n\n        return ret;\n    };\n\n    /**\n     * Resets the internal state of the computation.\n     *\n     * @return {SparkMD5.ArrayBuffer} The instance itself\n     */\n    SparkMD5.ArrayBuffer.prototype.reset = function () {\n        this._buff = new Uint8Array(0);\n        this._length = 0;\n        this._hash = [1732584193, -271733879, -1732584194, 271733878];\n\n        return this;\n    };\n\n    /**\n     * Gets the internal state of the computation.\n     *\n     * @return {Object} The state\n     */\n    SparkMD5.ArrayBuffer.prototype.getState = function () {\n        var state = SparkMD5.prototype.getState.call(this);\n\n        // Convert buffer to a string\n        state.buff = arrayBuffer2Utf8Str(state.buff);\n\n        return state;\n    };\n\n    /**\n     * Gets the internal state of the computation.\n     *\n     * @param {Object} state The state\n     *\n     * @return {SparkMD5.ArrayBuffer} The instance itself\n     */\n    SparkMD5.ArrayBuffer.prototype.setState = function (state) {\n        // Convert string to buffer\n        state.buff = utf8Str2ArrayBuffer(state.buff, true);\n\n        return SparkMD5.prototype.setState.call(this, state);\n    };\n\n    SparkMD5.ArrayBuffer.prototype.destroy = SparkMD5.prototype.destroy;\n\n    SparkMD5.ArrayBuffer.prototype._finish = SparkMD5.prototype._finish;\n\n    /**\n     * Performs the md5 hash on an array buffer.\n     *\n     * @param {ArrayBuffer} arr The array buffer\n     * @param {Boolean}     raw True to get the raw string, false to get the hex one\n     *\n     * @return {String} The result\n     */\n    SparkMD5.ArrayBuffer.hash = function (arr, raw) {\n        var hash = md51_array(new Uint8Array(arr)),\n            ret = hex(hash);\n\n        return raw ? hexToBinaryString(ret) : ret;\n    };\n\n    return SparkMD5;\n}));\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/spark-md5/spark-md5.js\n ** module id = 27\n ** module chunks = 0\n **/","/* global _ */\n(function () {\n\t'use strict';\n\n\t/* jshint ignore:start */\n\t// Underscore's Template Module\n\t// Courtesy of underscorejs.org\n\tvar _ = (function (_) {\n\t\t_.defaults = function (object) {\n\t\t\tif (!object) {\n\t\t\t\treturn object;\n\t\t\t}\n\t\t\tfor (var argsIndex = 1, argsLength = arguments.length; argsIndex < argsLength; argsIndex++) {\n\t\t\t\tvar iterable = arguments[argsIndex];\n\t\t\t\tif (iterable) {\n\t\t\t\t\tfor (var key in iterable) {\n\t\t\t\t\t\tif (object[key] == null) {\n\t\t\t\t\t\t\tobject[key] = iterable[key];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn object;\n\t\t}\n\n\t\t// By default, Underscore uses ERB-style template delimiters, change the\n\t\t// following template settings to use alternative delimiters.\n\t\t_.templateSettings = {\n\t\t\tevaluate    : /<%([\\s\\S]+?)%>/g,\n\t\t\tinterpolate : /<%=([\\s\\S]+?)%>/g,\n\t\t\tescape      : /<%-([\\s\\S]+?)%>/g\n\t\t};\n\n\t\t// When customizing `templateSettings`, if you don't want to define an\n\t\t// interpolation, evaluation or escaping regex, we need one that is\n\t\t// guaranteed not to match.\n\t\tvar noMatch = /(.)^/;\n\n\t\t// Certain characters need to be escaped so that they can be put into a\n\t\t// string literal.\n\t\tvar escapes = {\n\t\t\t\"'\":      \"'\",\n\t\t\t'\\\\':     '\\\\',\n\t\t\t'\\r':     'r',\n\t\t\t'\\n':     'n',\n\t\t\t'\\t':     't',\n\t\t\t'\\u2028': 'u2028',\n\t\t\t'\\u2029': 'u2029'\n\t\t};\n\n\t\tvar escaper = /\\\\|'|\\r|\\n|\\t|\\u2028|\\u2029/g;\n\n\t\t// JavaScript micro-templating, similar to John Resig's implementation.\n\t\t// Underscore templating handles arbitrary delimiters, preserves whitespace,\n\t\t// and correctly escapes quotes within interpolated code.\n\t\t_.template = function(text, data, settings) {\n\t\t\tvar render;\n\t\t\tsettings = _.defaults({}, settings, _.templateSettings);\n\n\t\t\t// Combine delimiters into one regular expression via alternation.\n\t\t\tvar matcher = new RegExp([\n\t\t\t\t(settings.escape || noMatch).source,\n\t\t\t\t(settings.interpolate || noMatch).source,\n\t\t\t\t(settings.evaluate || noMatch).source\n\t\t\t].join('|') + '|$', 'g');\n\n\t\t\t// Compile the template source, escaping string literals appropriately.\n\t\t\tvar index = 0;\n\t\t\tvar source = \"__p+='\";\n\t\t\ttext.replace(matcher, function(match, escape, interpolate, evaluate, offset) {\n\t\t\t\tsource += text.slice(index, offset)\n\t\t\t\t\t.replace(escaper, function(match) { return '\\\\' + escapes[match]; });\n\n\t\t\t\tif (escape) {\n\t\t\t\t\tsource += \"'+\\n((__t=(\" + escape + \"))==null?'':_.escape(__t))+\\n'\";\n\t\t\t\t}\n\t\t\t\tif (interpolate) {\n\t\t\t\t\tsource += \"'+\\n((__t=(\" + interpolate + \"))==null?'':__t)+\\n'\";\n\t\t\t\t}\n\t\t\t\tif (evaluate) {\n\t\t\t\t\tsource += \"';\\n\" + evaluate + \"\\n__p+='\";\n\t\t\t\t}\n\t\t\t\tindex = offset + match.length;\n\t\t\t\treturn match;\n\t\t\t});\n\t\t\tsource += \"';\\n\";\n\n\t\t\t// If a variable is not specified, place data values in local scope.\n\t\t\tif (!settings.variable) source = 'with(obj||{}){\\n' + source + '}\\n';\n\n\t\t\tsource = \"var __t,__p='',__j=Array.prototype.join,\" +\n\t\t\t\t\"print=function(){__p+=__j.call(arguments,'');};\\n\" +\n\t\t\t\tsource + \"return __p;\\n\";\n\n\t\t\ttry {\n\t\t\t\trender = new Function(settings.variable || 'obj', '_', source);\n\t\t\t} catch (e) {\n\t\t\t\te.source = source;\n\t\t\t\tthrow e;\n\t\t\t}\n\n\t\t\tif (data) return render(data, _);\n\t\t\tvar template = function(data) {\n\t\t\t\treturn render.call(this, data, _);\n\t\t\t};\n\n\t\t\t// Provide the compiled function source as a convenience for precompilation.\n\t\t\ttemplate.source = 'function(' + (settings.variable || 'obj') + '){\\n' + source + '}';\n\n\t\t\treturn template;\n\t\t};\n\n\t\treturn _;\n\t})({});\n\n\tif (location.hostname === 'todomvc.com') {\n\t\t(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){\n\t\t(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),\n\t\tm=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)\n\t\t})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');\n\t\tga('create', 'UA-31081062-1', 'auto');\n\t\tga('send', 'pageview');\n\t}\n\t/* jshint ignore:end */\n\n\tfunction redirect() {\n\t\tif (location.hostname === 'tastejs.github.io') {\n\t\t\tlocation.href = location.href.replace('tastejs.github.io/todomvc', 'todomvc.com');\n\t\t}\n\t}\n\n\tfunction findRoot() {\n\t\tvar base = location.href.indexOf('examples/');\n\t\treturn location.href.substr(0, base);\n\t}\n\n\tfunction getFile(file, callback) {\n\t\tif (!location.host) {\n\t\t\treturn console.info('Miss the info bar? Run TodoMVC from a server to avoid a cross-origin error.');\n\t\t}\n\n\t\tvar xhr = new XMLHttpRequest();\n\n\t\txhr.open('GET', findRoot() + file, true);\n\t\txhr.send();\n\n\t\txhr.onload = function () {\n\t\t\tif (xhr.status === 200 && callback) {\n\t\t\t\tcallback(xhr.responseText);\n\t\t\t}\n\t\t};\n\t}\n\n\tfunction Learn(learnJSON, config) {\n\t\tif (!(this instanceof Learn)) {\n\t\t\treturn new Learn(learnJSON, config);\n\t\t}\n\n\t\tvar template, framework;\n\n\t\tif (typeof learnJSON !== 'object') {\n\t\t\ttry {\n\t\t\t\tlearnJSON = JSON.parse(learnJSON);\n\t\t\t} catch (e) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tif (config) {\n\t\t\ttemplate = config.template;\n\t\t\tframework = config.framework;\n\t\t}\n\n\t\tif (!template && learnJSON.templates) {\n\t\t\ttemplate = learnJSON.templates.todomvc;\n\t\t}\n\n\t\tif (!framework && document.querySelector('[data-framework]')) {\n\t\t\tframework = document.querySelector('[data-framework]').dataset.framework;\n\t\t}\n\n\t\tthis.template = template;\n\n\t\tif (learnJSON.backend) {\n\t\t\tthis.frameworkJSON = learnJSON.backend;\n\t\t\tthis.frameworkJSON.issueLabel = framework;\n\t\t\tthis.append({\n\t\t\t\tbackend: true\n\t\t\t});\n\t\t} else if (learnJSON[framework]) {\n\t\t\tthis.frameworkJSON = learnJSON[framework];\n\t\t\tthis.frameworkJSON.issueLabel = framework;\n\t\t\tthis.append();\n\t\t}\n\n\t\tthis.fetchIssueCount();\n\t}\n\n\tLearn.prototype.append = function (opts) {\n\t\tvar aside = document.createElement('aside');\n\t\taside.innerHTML = _.template(this.template, this.frameworkJSON);\n\t\taside.className = 'learn';\n\n\t\tif (opts && opts.backend) {\n\t\t\t// Remove demo link\n\t\t\tvar sourceLinks = aside.querySelector('.source-links');\n\t\t\tvar heading = sourceLinks.firstElementChild;\n\t\t\tvar sourceLink = sourceLinks.lastElementChild;\n\t\t\t// Correct link path\n\t\t\tvar href = sourceLink.getAttribute('href');\n\t\t\tsourceLink.setAttribute('href', href.substr(href.lastIndexOf('http')));\n\t\t\tsourceLinks.innerHTML = heading.outerHTML + sourceLink.outerHTML;\n\t\t} else {\n\t\t\t// Localize demo links\n\t\t\tvar demoLinks = aside.querySelectorAll('.demo-link');\n\t\t\tArray.prototype.forEach.call(demoLinks, function (demoLink) {\n\t\t\t\tif (demoLink.getAttribute('href').substr(0, 4) !== 'http') {\n\t\t\t\t\tdemoLink.setAttribute('href', findRoot() + demoLink.getAttribute('href'));\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\tdocument.body.className = (document.body.className + ' learn-bar').trim();\n\t\tdocument.body.insertAdjacentHTML('afterBegin', aside.outerHTML);\n\t};\n\n\tLearn.prototype.fetchIssueCount = function () {\n\t\tvar issueLink = document.getElementById('issue-count-link');\n\t\tif (issueLink) {\n\t\t\tvar url = issueLink.href.replace('https://github.com', 'https://api.github.com/repos');\n\t\t\tvar xhr = new XMLHttpRequest();\n\t\t\txhr.open('GET', url, true);\n\t\t\txhr.onload = function (e) {\n\t\t\t\tvar parsedResponse = JSON.parse(e.target.responseText);\n\t\t\t\tif (parsedResponse instanceof Array) {\n\t\t\t\t\tvar count = parsedResponse.length;\n\t\t\t\t\tif (count !== 0) {\n\t\t\t\t\t\tissueLink.innerHTML = 'This app has ' + count + ' open issues';\n\t\t\t\t\t\tdocument.getElementById('issue-count').style.display = 'inline';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t\txhr.send();\n\t\t}\n\t};\n\n\tredirect();\n\tgetFile('learn.json', Learn);\n})();\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/todomvc-common/base.js\n ** module id = 28\n ** module chunks = 0\n **/","'use strict';\n\n/**\n * Stringify/parse functions that don't operate\n * recursively, so they avoid call stack exceeded\n * errors.\n */\nexports.stringify = function stringify(input) {\n  var queue = [];\n  queue.push({obj: input});\n\n  var res = '';\n  var next, obj, prefix, val, i, arrayPrefix, keys, k, key, value, objPrefix;\n  while ((next = queue.pop())) {\n    obj = next.obj;\n    prefix = next.prefix || '';\n    val = next.val || '';\n    res += prefix;\n    if (val) {\n      res += val;\n    } else if (typeof obj !== 'object') {\n      res += typeof obj === 'undefined' ? null : JSON.stringify(obj);\n    } else if (obj === null) {\n      res += 'null';\n    } else if (Array.isArray(obj)) {\n      queue.push({val: ']'});\n      for (i = obj.length - 1; i >= 0; i--) {\n        arrayPrefix = i === 0 ? '' : ',';\n        queue.push({obj: obj[i], prefix: arrayPrefix});\n      }\n      queue.push({val: '['});\n    } else { // object\n      keys = [];\n      for (k in obj) {\n        if (obj.hasOwnProperty(k)) {\n          keys.push(k);\n        }\n      }\n      queue.push({val: '}'});\n      for (i = keys.length - 1; i >= 0; i--) {\n        key = keys[i];\n        value = obj[key];\n        objPrefix = (i > 0 ? ',' : '');\n        objPrefix += JSON.stringify(key) + ':';\n        queue.push({obj: value, prefix: objPrefix});\n      }\n      queue.push({val: '{'});\n    }\n  }\n  return res;\n};\n\n// Convenience function for the parse function.\n// This pop function is basically copied from\n// pouchCollate.parseIndexableString\nfunction pop(obj, stack, metaStack) {\n  var lastMetaElement = metaStack[metaStack.length - 1];\n  if (obj === lastMetaElement.element) {\n    // popping a meta-element, e.g. an object whose value is another object\n    metaStack.pop();\n    lastMetaElement = metaStack[metaStack.length - 1];\n  }\n  var element = lastMetaElement.element;\n  var lastElementIndex = lastMetaElement.index;\n  if (Array.isArray(element)) {\n    element.push(obj);\n  } else if (lastElementIndex === stack.length - 2) { // obj with key+value\n    var key = stack.pop();\n    element[key] = obj;\n  } else {\n    stack.push(obj); // obj with key only\n  }\n}\n\nexports.parse = function (str) {\n  var stack = [];\n  var metaStack = []; // stack for arrays and objects\n  var i = 0;\n  var collationIndex,parsedNum,numChar;\n  var parsedString,lastCh,numConsecutiveSlashes,ch;\n  var arrayElement, objElement;\n  while (true) {\n    collationIndex = str[i++];\n    if (collationIndex === '}' ||\n        collationIndex === ']' ||\n        typeof collationIndex === 'undefined') {\n      if (stack.length === 1) {\n        return stack.pop();\n      } else {\n        pop(stack.pop(), stack, metaStack);\n        continue;\n      }\n    }\n    switch (collationIndex) {\n      case ' ':\n      case '\\t':\n      case '\\n':\n      case ':':\n      case ',':\n        break;\n      case 'n':\n        i += 3; // 'ull'\n        pop(null, stack, metaStack);\n        break;\n      case 't':\n        i += 3; // 'rue'\n        pop(true, stack, metaStack);\n        break;\n      case 'f':\n        i += 4; // 'alse'\n        pop(false, stack, metaStack);\n        break;\n      case '0':\n      case '1':\n      case '2':\n      case '3':\n      case '4':\n      case '5':\n      case '6':\n      case '7':\n      case '8':\n      case '9':\n      case '-':\n        parsedNum = '';\n        i--;\n        while (true) {\n          numChar = str[i++];\n          if (/[\\d\\.\\-e\\+]/.test(numChar)) {\n            parsedNum += numChar;\n          } else {\n            i--;\n            break;\n          }\n        }\n        pop(parseFloat(parsedNum), stack, metaStack);\n        break;\n      case '\"':\n        parsedString = '';\n        lastCh = void 0;\n        numConsecutiveSlashes = 0;\n        while (true) {\n          ch = str[i++];\n          if (ch !== '\"' || (lastCh === '\\\\' &&\n              numConsecutiveSlashes % 2 === 1)) {\n            parsedString += ch;\n            lastCh = ch;\n            if (lastCh === '\\\\') {\n              numConsecutiveSlashes++;\n            } else {\n              numConsecutiveSlashes = 0;\n            }\n          } else {\n            break;\n          }\n        }\n        pop(JSON.parse('\"' + parsedString + '\"'), stack, metaStack);\n        break;\n      case '[':\n        arrayElement = { element: [], index: stack.length };\n        stack.push(arrayElement.element);\n        metaStack.push(arrayElement);\n        break;\n      case '{':\n        objElement = { element: {}, index: stack.length };\n        stack.push(objElement.element);\n        metaStack.push(objElement);\n        break;\n      default:\n        throw new Error(\n          'unexpectedly reached end of input: ' + collationIndex);\n    }\n  }\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/vuvuzela/index.js\n ** module id = 29\n ** module chunks = 0\n **/"],"sourceRoot":""}